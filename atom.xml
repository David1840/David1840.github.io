<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-28T09:06:15.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>安卓程序员需要知道的交叉编译和Makefile知识</title>
    <link href="http://yoursite.com/2019/01/05/%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%92%8CMakefile%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/05/安卓程序员需要知道的交叉编译和Makefile知识/</id>
    <published>2019-01-05T07:54:16.000Z</published>
    <updated>2018-12-28T09:06:15.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="交叉编译" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现Camera2 rtmp推流直播</title>
    <link href="http://yoursite.com/2019/01/03/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0Camera2-rtmp%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/03/FFmpeg代码实现Camera2-rtmp推流直播/</id>
    <published>2019-01-03T03:15:04.000Z</published>
    <updated>2018-12-28T08:19:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>作为一个Android开发，老本行还是不能丢，所以将FFmpeg移植到Android平台上，然后自己做了一个摄像头直播的Demo，里面涉及到的知识点还是非常多的，这篇博客就一点点讲一下我是如何完成这个Demo的，做个记录，也希望能对阅读到这篇博客的朋友有所帮助。</p><pre><code>如发现博客中的错误，欢迎留言指出，共同学习。</code></pre><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><h3 id="1、FFmpeg编译移植Android平台"><a href="#1、FFmpeg编译移植Android平台" class="headerlink" title="1、FFmpeg编译移植Android平台"></a>1、FFmpeg编译移植Android平台</h3><h3 id="2、YUV数据"><a href="#2、YUV数据" class="headerlink" title="2、YUV数据"></a>2、YUV数据</h3><h3 id="3、RTMP服务器搭建"><a href="#3、RTMP服务器搭建" class="headerlink" title="3、RTMP服务器搭建"></a>3、RTMP服务器搭建</h3><h2 id="开发"><a href="#开发" class="headerlink" title="开发"></a>开发</h2><h3 id="1、Camrea2预览与数据获取"><a href="#1、Camrea2预览与数据获取" class="headerlink" title="1、Camrea2预览与数据获取"></a>1、Camrea2预览与数据获取</h3><h3 id="2、初始化FFmpeg"><a href="#2、初始化FFmpeg" class="headerlink" title="2、初始化FFmpeg"></a>2、初始化FFmpeg</h3><h3 id="3、推送数据"><a href="#3、推送数据" class="headerlink" title="3、推送数据"></a>3、推送数据</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/azraelly/archive/2013/01/01/2841269.html" target="_blank" rel="noopener">图文详解YUV420数据格式</a></p><p><a href="https://www.polarxiong.com/archives/Android-Image%E7%B1%BB%E6%B5%85%E6%9E%90-%E7%BB%93%E5%90%88YUV_420_888.html" target="_blank" rel="noopener">Android Image类浅析(结合YUV_420_888)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;作为一个Android开发，老本行还是不能丢，所以将FFmpeg移植到Android平台上，然后自己做了一个摄像头直播的Demo，里面涉及到的知识点还是非常多的，这篇博客就一点点讲一下我是如何完成这个Demo的，做个记录，也希望能对阅读到这篇博客的朋友有所帮助。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="直播" scheme="http://yoursite.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android Image类简析(YUV_420_888)</title>
    <link href="http://yoursite.com/2018/12/28/Android-Image%E7%B1%BB%E7%AE%80%E6%9E%90-YUV-420-888/"/>
    <id>http://yoursite.com/2018/12/28/Android-Image类简析-YUV-420-888/</id>
    <published>2018-12-28T06:43:09.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>Android Camera2预览及YUV数据获取</title>
    <link href="http://yoursite.com/2018/12/26/Android-Camera2%E9%A2%84%E8%A7%88%E5%8F%8AYUV%E6%95%B0%E6%8D%AE%E8%8E%B7%E5%8F%96/"/>
    <id>http://yoursite.com/2018/12/26/Android-Camera2预览及YUV数据获取/</id>
    <published>2018-12-26T06:27:01.000Z</published>
    <updated>2018-12-28T08:19:41.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
      <category term="直播" scheme="http://yoursite.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
  <entry>
    <title>C语言回调函数</title>
    <link href="http://yoursite.com/2018/12/23/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/23/C语言回调函数/</id>
    <published>2018-12-23T06:48:51.000Z</published>
    <updated>2018-12-28T07:21:46.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>YUV数据格式解惑</title>
    <link href="http://yoursite.com/2018/12/20/YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E8%A7%A3%E6%83%91/"/>
    <id>http://yoursite.com/2018/12/20/YUV数据格式解惑/</id>
    <published>2018-12-20T06:45:00.000Z</published>
    <updated>2018-12-28T08:49:23.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux中断和中断处理</title>
    <link href="http://yoursite.com/2018/12/18/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/18/Linux中断和中断处理/</id>
    <published>2018-12-18T12:33:10.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断本质上是一种特殊的电信号，有硬件设备发送给处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统处理这些新到来的数据。不同设备对应的中断不同，而每个中断都通过一个唯一的数字标志（中断请求线，IRQ线），操作系统可以根据这些标志提供对应的中断处理程序。</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在响应一个特定中断的时候，内核会执行一个函数，该函数就被称为中断处理程序或中断服务例程。产生中断的每个设备都有一个相应的中断处理程序。</p><p>在Linux中，中断处理程序就是普通的C函数，不过必须按照特定的类型声明，以便内核能够以标准的方式传递处理程序的信息。被内核调用来响应中断，运行于我们称之为中断上下文中的特殊上下文中。</p><p>因为中断随时可能发生，所以中断处理程序也就随时可能发生。所以必须保证中断处理程序能够快速执行，这样才能保证尽可能快地恢复中断代码的执行。</p><h2 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h2><p>又想中断处理程序执行得快，又想中断处理程序完成的工作量多，这两个目的显然有所抵触，所以我们一般把中断处理切为两个部分。</p><p>中断处理程序是上半部（top half）——接收到一个中断，它就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部（bottom half）去。</p><h2 id="注册、释放中断处理程序"><a href="#注册、释放中断处理程序" class="headerlink" title="注册、释放中断处理程序"></a>注册、释放中断处理程序</h2><p>中断处理程序是管理硬件的驱动程序的组成部分。驱动程序可以通过 <code>request-irq()</code>函数注册一个中断处理程序，并且激活给定的中断线，以处理中断。</p><p>卸载驱动时，需要注销相对应的中断处理程序，并释放中断线。<code>free_irq()</code>                                                                    </p><h2 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h2><p><code>static irqreturn_t intr_handler(int irq,void *dev)</code>                                                                                                                                              </p><p>第一个参数irq是这个处理程序要响应的中断的中断号，目前已经没有太大用了。</p><p>第二个参数dev是一个通用指针。可以用来区分共享同一中断处理程序的多个设备。</p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。&lt;/p&gt;
&lt;h2 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;p&gt;中断本质上是一种特殊的电信号，有硬件设备发送给处理器
      
    
    </summary>
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="中断" scheme="http://yoursite.com/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频转图片</title>
    <link href="http://yoursite.com/2018/12/10/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/12/10/FFmpeg代码实现视频转图片/</id>
    <published>2018-12-10T10:59:09.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。</p><h2 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h2><ol><li>打开输入文件 <code>avformat_open_input</code></li><li>找到视频流   <code>av_find_best_stream</code></li><li>找到对应的解码器 <code>avcodec_find_decoder</code></li><li>初始化一个编解码上下文 <code>avcodec_alloc_context3</code></li><li>拷贝流参数到编解码上下文中 <code>avcodec_parameters_to_context</code></li><li>打开解码器 <code>avcodec_open2</code></li><li>读取视频帧 <code>av_read_frame</code></li><li>发送等待解码帧 <code>avcodec_send_packet</code></li><li>接收解码后frame数据 <code>avcodec_receive_frame</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *in_filename, *out_filename;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> AVCodec *codec;</span><br><span class="line">    AVCodecContext *codeCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVStream *stream = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> stream_index;</span><br><span class="line"></span><br><span class="line">    AVPacket avpkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;input file&gt; &lt;output file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    in_filename = argv[<span class="number">1</span>];</span><br><span class="line">    out_filename = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;fmt_ctx, in_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open source file %s\n"</span>, in_filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(fmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find stream information\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    av_init_packet(&amp;avpkt);</span><br><span class="line">    avpkt.data = <span class="literal">NULL</span>;</span><br><span class="line">    avpkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2</span></span><br><span class="line">    stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find %s stream in input file '%s'\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO), in_filename);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream = fmt_ctx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    codec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    codeCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!codeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = avcodec_parameters_to_context(codeCtx, stream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    avcodec_open2(codeCtx, codec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化frame，解码后数据</span></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video frame\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avpkt.stream_index == stream_index) &#123;</span><br><span class="line">            <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">int</span> re = avcodec_send_packet(codeCtx, &amp;avpkt);</span><br><span class="line">            <span class="keyword">if</span> (re &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 9 这里必须用while()，因为一次avcodec_receive_frame可能无法接收到所有数据</span></span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 拼接图片路径、名称</span></span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s/Demo-%d.jpg"</span>, out_filename, frame_count);</span><br><span class="line">                saveJpg(frame, buf); <span class="comment">//保存为jpg图片</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frame_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;avpkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频编码（保存为图片）"><a href="#视频编码（保存为图片）" class="headerlink" title="视频编码（保存为图片）"></a>视频编码（保存为图片）</h2><p>编码整体在流程上和解码一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saveJpg</span><span class="params">(AVFrame *pFrame, <span class="keyword">char</span> *out_name)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> width = pFrame-&gt;width;</span><br><span class="line">    <span class="keyword">int</span> height = pFrame-&gt;height;</span><br><span class="line">    AVCodecContext *pCodeCtx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">// 设置输出文件格式</span></span><br><span class="line">    pFormatCtx-&gt;oformat = av_guess_format(<span class="string">"mjpeg"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化输出AVIOContext</span></span><br><span class="line">    <span class="keyword">if</span> (avio_open(&amp;pFormatCtx-&gt;pb, out_name, AVIO_FLAG_READ_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Couldn't open output file."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个新stream</span></span><br><span class="line">    AVStream *pAVStream = avformat_new_stream(pFormatCtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pAVStream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVCodecParameters *parameters = pAVStream-&gt;codecpar;</span><br><span class="line">    parameters-&gt;codec_id = pFormatCtx-&gt;oformat-&gt;video_codec;</span><br><span class="line">    parameters-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    parameters-&gt;format = AV_PIX_FMT_YUVJ420P;</span><br><span class="line">    parameters-&gt;width = pFrame-&gt;width;</span><br><span class="line">    parameters-&gt;height = pFrame-&gt;height;</span><br><span class="line"></span><br><span class="line">    AVCodec *pCodec = avcodec_find_encoder(pAVStream-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pCodec) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find encoder\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (!pCodeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avcodec_parameters_to_context(pCodeCtx, pAVStream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodeCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open codec."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avformat_write_header(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write_header fail\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y_size = width * height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Encode</span></span><br><span class="line">    <span class="comment">// 给AVPacket分配足够大的空间</span></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    av_new_packet(&amp;pkt, y_size * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码数据</span></span><br><span class="line">    ret = avcodec_send_frame(pCodeCtx, pFrame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_send_frame."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到编码后数据</span></span><br><span class="line">    ret = avcodec_receive_packet(pCodeCtx, &amp;pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_receive_packet"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = av_write_frame(pFormatCtx, &amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not av_write_frame"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_packet_unref(&amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write Trailer</span></span><br><span class="line">    av_write_trailer(pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodeCtx);</span><br><span class="line">    avio_close(pFormatCtx-&gt;pb);</span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/2018/12/10/FFmpeg代码实现视频转图片/decoder.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。&lt;/p&gt;
&lt;h2 id=&quot;视频解码&quot;&gt;&lt;a href=&quot;#视频解码&quot; class=&quot;headerlink&quot; title=&quot;视频解
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现最简版本小咖秀</title>
    <link href="http://yoursite.com/2018/12/07/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E7%89%88%E6%9C%AC%E5%B0%8F%E5%92%96%E7%A7%80/"/>
    <id>http://yoursite.com/2018/12/07/FFmpeg代码实现最简版本小咖秀/</id>
    <published>2018-12-07T08:27:40.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。</p><p>前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。</p><p>源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> err_code;</span><br><span class="line"><span class="keyword">char</span> errors[ERROR_STR_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *src_file1, *src_file2, *out_file;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ifmt_ctx1 = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ifmt_ctx2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *in_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *in_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *out_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *out_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vedio_stream_indes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件最大时长，保证音频和视频数据长度一致</span></span><br><span class="line"><span class="keyword">double</span> max_duration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stream1 = <span class="number">0</span>, stream2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">src_file1 = argv[<span class="number">1</span>];</span><br><span class="line">src_file2 = argv[<span class="number">2</span>];</span><br><span class="line">out_file = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开两个输入文件</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx1, src_file1, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"Could not open src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file1, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx2, src_file2, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Could not open the second src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file2, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出上下文</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to create an context of outfile , %d(%s) \n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个参数里最好的音频流和第二个文件中的视频流下标</span></span><br><span class="line">audio_stream_index = av_find_best_stream(ifmt_ctx1, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">vedio_stream_indes = av_find_best_stream(ifmt_ctx2, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个文件中的音频流</span></span><br><span class="line">in_stream1 = ifmt_ctx1-&gt;streams[audio_stream_index];</span><br><span class="line">stream1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 创建音频输出流</span></span><br><span class="line">out_stream1 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream1) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream1-&gt;codecpar, in_stream1-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream1-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第二个文件中的视频流</span></span><br><span class="line">in_stream2 = ifmt_ctx2-&gt;streams[vedio_stream_indes];</span><br><span class="line">stream2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建视频输出流</span></span><br><span class="line">out_stream2 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream2) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream2-&gt;codecpar, in_stream2-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream2-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">av_dump_format(ofmt_ctx, <span class="number">0</span>, out_file, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个流的长度，确定最终文件的长度</span></span><br><span class="line"><span class="keyword">if</span> (in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base) &gt; in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base)) &#123;</span><br><span class="line">    max_duration = in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max_duration = in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开输出文件</span></span><br><span class="line"><span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, out_file, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">"Could not open output file, %s, %d(%s)\n"</span>,</span><br><span class="line">               out_file, err_code, errors);</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写头信息</span></span><br><span class="line">avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">av_init_packet(&amp;pkt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取音频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx1, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream1-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的音频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == audio_stream_index) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream1-&gt;time_base, out_stream1-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream1;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取视频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx2, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream2-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的视频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == vedio_stream_indes) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream2-&gt;time_base, out_stream2-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream2;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx)；</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx1) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx2) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ofmt_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下，从左到右：输入1、输入2、输出文件。输出文件拿到了输入1的音频、输入2的视频信息，并且时长为输入2的时长。</p><p><img src="/2018/12/07/FFmpeg代码实现最简版本小咖秀/merge1.png" alt=""></p><p>目前只是在做C语言开发，后面会慢慢把重心移到Android平台上，在FFmpeg和Android平台的基础上玩更多有意思的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。&lt;/p&gt;
&lt;p&gt;前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。&lt;/p&gt;

      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频剪切</title>
    <link href="http://yoursite.com/2018/12/06/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    <id>http://yoursite.com/2018/12/06/FFmpeg代码实现视频剪辑/</id>
    <published>2018-12-06T04:07:22.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说起来这个功能的实现也很简单，给定一个起始时间、一个结束时间，把视频文件打开，然后把容器中的每条流从起始时间开始，到结束时间为止的数据拷贝到输出流，然后输出流保存为容器，这样就能看到一个剪切后的视频文件了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="第一步-定义参数"><a href="#第一步-定义参数" class="headerlink" title="第一步 定义参数"></a>第一步 定义参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> start_seconds； <span class="comment">//开始时间</span></span><br><span class="line"><span class="keyword">double</span> end_seconds；   <span class="comment">//结束时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *in_filename； <span class="comment">//输入文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *out_filename；<span class="comment">//输出文件</span></span><br></pre></td></tr></table></figure><h4 id="第二步-初始化上下文"><a href="#第二步-初始化上下文" class="headerlink" title="第二步 初始化上下文"></a>第二步 初始化上下文</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上调用了avformat_alloc_context、av_guess_format这两个函数，即创建了输出上下文，又根据输出文件后缀生成了最适合的输出容器</span></span><br><span class="line">avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename); </span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br></pre></td></tr></table></figure><h4 id="第三步-创建流及参数拷贝"><a href="#第三步-创建流及参数拷贝" class="headerlink" title="第三步 创建流及参数拷贝"></a>第三步 创建流及参数拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        avcodec_parameters_copy(out_stream-&gt;codecpar, in_stream-&gt;codecpar);</span><br><span class="line">        out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第四步-打开输出文件"><a href="#第四步-打开输出文件" class="headerlink" title="第四步 打开输出文件"></a>第四步 打开输出文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br></pre></td></tr></table></figure><h4 id="第五步-处理、写入数据"><a href="#第五步-处理、写入数据" class="headerlink" title="第五步  处理、写入数据"></a>第五步  处理、写入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写头信息</span></span><br><span class="line">ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到指定帧</span></span><br><span class="line">ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, start_seconds * AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据流数量申请空间，并全部初始化为0</span></span><br><span class="line"><span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        in_stream = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间超过要截取的时间，就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_packet_unref(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将截取后的每个流的起始dts 、pts保存下来，作为开始时间，用来做后面的时间基转换</span></span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间基转换</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base,out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>) av_rescale_q((<span class="keyword">int64_t</span>) pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一帧视频播放时间必须在解码时间点之后，当出现pkt.pts &lt; pkt.dts时会导致程序异常，所以我们丢掉有问题的帧，不会有太大影响。</span></span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; pkt.dts) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error write packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">free</span>(dts_start_from);</span><br><span class="line"><span class="built_in">free</span>(pts_start_from);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br></pre></td></tr></table></figure><p>整个处理流程就这样了，还是比较简单的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI开发-Linux C程序移植</title>
    <link href="http://yoursite.com/2018/12/05/Android-JNI%E5%BC%80%E5%8F%91-LinuxC%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/"/>
    <id>http://yoursite.com/2018/12/05/Android-JNI开发-LinuxC程序移植/</id>
    <published>2018-12-05T09:51:16.000Z</published>
    <updated>2018-12-05T11:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要提供一些特有的接口给C就好了，以后只维护一套代码，简单方便。</p><p>经过一天的尝试，最终成功完成了一个满足需求的Demo，整体结构如下：</p><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni1.png" alt=""></p><p>整体来看也比较简单，Java调JNI，JNI启动Linux程序，Linux程序运行中需要操作界面时再用JNI的反射方法调用到Java层修改界面。</p><p>接下来看下具体实现：</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni2.png" alt=""></p><p><strong>LinuxHandler.java 定义native方法和等待反射调用方法</strong></p><p><strong>Androidhandle.c  Linux代码调用方法反射Java层</strong></p><p><strong>demo.c    Linux小组同事提供的测试代码，里面有他们简化的业务逻辑</strong></p><p><strong>linuxhandle.c   JNI方法</strong></p><h4 id="LinuxHandler-java"><a href="#LinuxHandler-java" class="headerlink" title="LinuxHandler.java"></a>LinuxHandler.java</h4><p>Java层启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">startLinux</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"speak C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"showMsg C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了三个方法，native方法startLinux()从Java层启动Linux程序，另外两个是模拟等待反射调用的操作界面方法。</p><h4 id="linuxhandle-c"><a href="#linuxhandle-c" class="headerlink" title="linuxhandle.c"></a>linuxhandle.c</h4><p>真正去启动Linux程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"demo.h"</span> <span class="comment">//Linux C 头文件，调用main()方法</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JavaVM *local_jvm = <span class="literal">NULL</span>; </span><br><span class="line">jobject local_object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_***_linuxdemo_LinuxHandle</span></span><br><span class="line"><span class="comment"> * Method:    startLinux</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_***_linuxdemo_LinuxHandle_startLinux</span><br><span class="line">        (JNIEnv *env, jobject object) &#123;</span><br><span class="line">    (*env)-&gt;GetJavaVM(env, &amp;local_jvm); <span class="comment">//保存到全局变量JVM中</span></span><br><span class="line">    local_object = (*env)-&gt;NewGlobalRef(env, object); <span class="comment">/* 创建对象的本地变量 */</span></span><br><span class="line">    main(); <span class="comment">//启动Linux C程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Androidhandle-c"><a href="#Androidhandle-c" class="headerlink" title="Androidhandle.c"></a>Androidhandle.c</h3><p>等待Linux程序调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage_c</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> JavaVM *local_jvm; <span class="comment">//获取全局JVM，由它获取JNIEnv</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">extern</span> jobject local_object;</span><br><span class="line">    (*local_jvm)-&gt;AttachCurrentThread(local_jvm, &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jclass jclass1 = (*env)-&gt;FindClass(env, <span class="string">"com/***/linuxdemo/LinuxHandle"</span>);</span><br><span class="line">    </span><br><span class="line">    jmethodID methodID = (*env)-&gt;GetMethodID(env, jclass1, <span class="string">"showMsg"</span>,</span><br><span class="line">                                             <span class="string">"(Ljava/lang/String;)V"</span>);</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, local_object, methodID, (*env)-&gt;NewStringUTF(env, message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak_c</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">    LOGE(<span class="string">"speak at C"</span>);</span><br><span class="line">    <span class="comment">//同样反射到Java层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo-c"><a href="#Demo-c" class="headerlink" title="Demo.c"></a>Demo.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Androidhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ......  <span class="comment">//公司业务逻辑代码</span></span><br><span class="line">    speak_c(<span class="string">"1234"</span>);</span><br><span class="line">    showMessage_c(<span class="string">"adc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己做完后也做了多次验证，并且导入第三方SO库测试也没有问题，但因为还只是个验证可行性的Demo，后面就要开始正式做移植的项目了，如果遇到了什么坑我会尽快补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg中的时间戳与时间基</title>
    <link href="http://yoursite.com/2018/12/05/FFmpeg%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E6%97%B6%E9%97%B4%E5%9F%BA/"/>
    <id>http://yoursite.com/2018/12/05/FFmpeg中的时间戳与时间基/</id>
    <published>2018-12-05T05:42:44.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。</p><h3 id="PTS和DTS"><a href="#PTS和DTS" class="headerlink" title="PTS和DTS"></a>PTS和DTS</h3><p>这两个概念其实在刚开始的时候就提到过，今天的概念跟它们还是有很大关系的，所以再说一次概念，具体解释请看<a href="https://www.jianshu.com/p/e3acc140aa90" target="_blank" rel="noopener">音视频基础概念</a>。</p><ul><li>PTS: Decode Time Stamp，显示渲染用的时间戳，告诉我们什么时候需要显示</li><li>DTS: Presentation Time Stamp，视频解码时的时间戳，告诉我们什么时候需要解码</li></ul><h3 id="时间基"><a href="#时间基" class="headerlink" title="时间基"></a>时间基</h3><p>在写代码处理音视频流的时候经常会看到<code>in_stream-&gt;time_base</code>这样的代码，这表示的是输入流的时间基，time_base时间基的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment"> * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment"> * 这是表示帧时间戳的基本时间单位(以秒为单位)。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>可以看出时间基是一个分数，以秒为单位，比如1/50秒，那它到底表示的是什么意思呢？以帧率为例，如果它的时间基是1/50秒，那么就表示每隔1/50秒显示一帧数据，也就是每1秒显示50帧，帧率为50FPS。</p><p>每一帧数据都有对应的PTS，在播放视频或音频的时候我们需要将PTS时间戳转化为以秒为单位的时间，用来最后的展示。那如何计算一桢在整个视频中的时间位置？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算一桢在整个视频中的时间位置</span></span><br><span class="line">timestamp(秒) = pts * av_q2d(st-&gt;time_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算视频长度的方法：</span></span><br><span class="line">time(秒) = st-&gt;duration * av_q2d(st-&gt;time_base);</span><br></pre></td></tr></table></figure><h4 id="内部时间基"><a href="#内部时间基" class="headerlink" title="内部时间基"></a>内部时间基</h4><p>FFmpeg中的所有时间都是以它为一个单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal time base represented as integer</span></span><br><span class="line"><span class="comment"> * 内部时间基</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE            1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部时间基的分数表示，实际上它是AV_TIME_BASE的倒数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE_Q   (AVRational)&#123;1, AV_TIME_BASE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ffmpeg内部的时间与标准的时间转换方法</span></span><br><span class="line">timestamp(ffmpeg内部时间戳) = AV_TIME_BASE * time(秒)</span><br><span class="line">time(秒) = AV_TIME_BASE_Q * timestamp(ffmpeg内部时间戳)</span><br></pre></td></tr></table></figure><p>当需要把视频跳转到N秒的时候可以使用下面的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame(fmt_ctx, index_of_video, N * <span class="built_in">AV_TIME_BASE</span>, <span class="built_in">AVSEEK_FLAG_BACKWARD</span>);</span><br></pre></td></tr></table></figure><p>有时候我们需要在不同的时间基之间做换算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> av_rescale_q(<span class="keyword">int64_t</span> a, AVRational bq, AVRational cq) av_const;</span><br></pre></td></tr></table></figure><p>这个方法实际的操作是 <code>a * bq / cq</code>，看起来简单，但它内部处理了数值溢出的问题，所以我们在操作的时候最好还是直接调用这个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。&lt;/p&gt;
&lt;h3 id=&quot;PTS和DTS&quot;&gt;&lt;a href=&quot;#PTS和DTS&quot; 
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之二叉树的所有路径</title>
    <link href="http://yoursite.com/2018/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2018/12/04/每日一算法之二叉树的所有路径/</id>
    <published>2018-12-04T01:07:40.000Z</published>
    <updated>2018-12-05T03:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>有关二叉树的问题绝大多数都可以通过递归解决。先序遍历二叉树，将每个节点加在字符串的后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int = 0) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">binaryTreePaths</span><span class="params">(root: TreeNode?)</span>: List&lt;String&gt; </span>&#123;</span><br><span class="line">        val result = ArrayList&lt;String&gt;()</span><br><span class="line">        binaryTreePaths2(root, <span class="string">""</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> fun <span class="title">binaryTreePaths2</span><span class="params">(root: TreeNode?, str: String, result: MutableList&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mStr = str</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStr.isEmpty())&#123;</span><br><span class="line">            mStr = root.`val`.toString() + <span class="string">""</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mStr += <span class="string">"-&gt;"</span> + root.`val`</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> || root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            binaryTreePaths2(root.left, mStr, result)</span><br><span class="line">            binaryTreePaths2(root.right, mStr, result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.add(mStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个问题，在leetcode上，同样的代码逻辑，同样的测试用例，Java代码17ms，Kotlin却要用352 ms，这差距有点太大了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-使用第三方SO库</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9SO%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-使用第三方SO库/</id>
    <published>2018-12-03T11:09:27.000Z</published>
    <updated>2018-12-03T12:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要通过我自己的C文件再去调用so库中的方法。</p><h1 id="生成SO库"><a href="#生成SO库" class="headerlink" title="生成SO库"></a>生成SO库</h1><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>新建项目JNISODemo，在MainActivity中定义Native方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function">String <span class="title">getString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="头文件生成"><a href="#头文件生成" class="headerlink" title="头文件生成"></a>头文件生成</h3><p>.h文件的生成是在命令行cd到main目录下，再使用javah生成。</p><p>这次是想介绍下快捷方式。</p><p><strong>File -&gt; Settings -&gt; Tools -&gt; External tools -&gt; +</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-c4046ae731276f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Program:</span>   <span class="variable">$JDKPath</span><span class="variable">$\</span>bin\javah.exe </span><br><span class="line"><span class="symbol">Arguments:</span>  -classpath . -jni -o <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\jni\<span class="variable">$Prompt</span><span class="variable">$ </span> <span class="variable">$FileClass</span><span class="variable">$ </span></span><br><span class="line">Working <span class="symbol">directory:</span> <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\java</span><br></pre></td></tr></table></figure><p>在我们声明native方法的类上点击右键，javah，输入命名（我命名为Test.h)，之后就会先自动创建一个jni文件夹，然后生成一个Test.h文件，copy Test.h，并将命名改为Test.c。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-469baae7078430a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码"><a href="#完成C代码" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>在Test.c中简单完成下我们定义的方法，返回一个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_david_jnisodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jnisodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"This is a test!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             Test</span><br><span class="line">             </span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/jni/Test.c )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_library(log-lib log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       Test</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">ndk </span>&#123;</span><br><span class="line">    ldLibs <span class="string">"log"</span><span class="comment">//实现__android_log_print</span></span><br><span class="line">    abiFilters  <span class="string">"armeabi-v7a"</span> <span class="comment">//平台配置，因为在Android上，就只写了一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译完成后就如下图，产生一个libTest.so的文件，这就是我们要的。把它当做Linux最后打包成的so文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-caee5784088bdb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="导入第三方so"><a href="#导入第三方so" class="headerlink" title="导入第三方so"></a>导入第三方so</h1><p>新建一个项目JNIUseSoDemo，项目结构如下。同样是在MainActivity中定义Native方法，生成UseSo.c。将我们上一步生成的so文件拷贝到jniLibs下（armeabi-v7a是平台）。以及上一步中的头文件也拷贝到jni下。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-120270e98dea640c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码-1"><a href="#完成C代码-1" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>我在UseSo中getString方法去调用了so库中的getString方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span> <span class="comment">//so库的头文件，必须要引用！</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Header for class com_david_jniusesodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jniusesodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Java_com_david_jnisodemo_MainActivity_getString(env, instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当然还没有完成。</p><h3 id="CMakeList-txt-1"><a href="#CMakeList-txt-1" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><p>在CMake中将LibTest.so导入工程</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add_library( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             UseSo</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             src/main/jni/UseSo.c )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#导入第三方so包，并声明为 IMPORTED 属性，指明只是想把 so 导入到项目中</span></span><br><span class="line">add_library( Test</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#指明 so 库的路径，CMAKE_SOURCE_DIR 表示 CMakeLists.txt 的路径             </span></span><br><span class="line">set_target_properties(</span><br><span class="line">             Test</span><br><span class="line">             PROPERTIES IMPORTED_LOCATION</span><br><span class="line">             $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/armeabi-v7a/libTest.so )</span><br><span class="line"></span><br><span class="line"><span class="comment">#指明头文件路径，不然会提示找不到 so 的方法</span></span><br><span class="line">include_directories(src/main/jni/)</span><br><span class="line"></span><br><span class="line">find_library(log-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       UseSo</span><br><span class="line"></span><br><span class="line">                       Test</span><br><span class="line"></span><br><span class="line">                       $&#123;log-<span class="class"><span class="keyword">lib</span>&#125; )</span></span><br></pre></td></tr></table></figure><h3 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ndk</span> &#123;</span><br><span class="line">    <span class="attribute">abiFilters</span> <span class="string">'armeabi-v7a'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用"><a href="#最终调用" class="headerlink" title="最终调用"></a>最终调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"UseSo"</span>); <span class="comment">//加载SO库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">"TEST"</span>,getString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getString</span><span class="params">()</span></span>; <span class="comment">//它会调用Java_com_david_jniusesodemo_MainActivity_getString方法，然后该方法又回去调用so库中的Java_com_david_jnisodemo_MainActivity_getString方法，得到返回字符串。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3809817-07915a8ceb23d42d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>验证没有问题，导入第三方so库完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之奇偶链表</title>
    <link href="http://yoursite.com/2018/12/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/12/03/每日一算法之奇偶链表/</id>
    <published>2018-12-03T07:02:11.000Z</published>
    <updated>2018-12-03T12:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;NULL </span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><p>这道题还是比较简单，下面的代码只是一种解决方法。odd节点指向奇节点，even指向偶节点，将even后的奇节点放在它的前面，然后-&gt;next往后依次，直到结束，所有的奇节点就在前面，偶节点在后，顺序没变。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">oddEvenList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> = <span class="title">odd</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">        odd-&gt;next-&gt;next = tmp;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有遍历节点，将奇偶节点分开成两个链表，最后再将偶链表连在奇链表后面也是可以的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
&lt;p&gt;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。&lt;/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-LOG日志</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-LOG/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-LOG/</id>
    <published>2018-12-03T02:43:38.000Z</published>
    <updated>2018-12-03T03:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便以后查看使用。</p><h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><pre><code>defaultConfig {   ndk {       ldLibs &quot;log&quot; //实现__android_log_print       moduleName &quot;demo&quot;  //设置库(so)文件名称       abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;   }}</code></pre><p><code>ldLibs &quot;log&quot;</code>是实现JNI Log的关键。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG    <span class="meta-string">"MyDemo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGE(<span class="string">"myName : %s"</span>, name); <span class="comment">// Log.e(TAG,"myName : $name")</span></span><br><span class="line">LOGD(<span class="string">"age: %d"</span>,age); <span class="comment">// Log.d(TAG,"age : $age")</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之判断回文联表</title>
    <link href="http://yoursite.com/2018/11/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E8%81%94%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/11/30/每日一算法之判断回文联表/</id>
    <published>2018-11-30T06:36:00.000Z</published>
    <updated>2018-11-30T07:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？（<a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">leetcode原题</a>）</p><p>拿到这个题的时候，看到给出的第二个示例以及要求O(1) 空间复杂度就知道要利用链表逆序思想，将链表后半部分逆序。然后从前到中和从后到中一一对比即可。</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node1</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node2</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node3</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node2每次跳两步，node1每次跳一步，当node2-&gt;next或者node2-&gt;next-&gt;next为空时</span></span><br><span class="line">    <span class="comment">//链表个数为奇数，node1就处在中间位置，</span></span><br><span class="line">    <span class="comment">//链表个数为偶数，node1和node1-&gt;next就是中间两个位置。</span></span><br><span class="line">    <span class="keyword">while</span>(node2-&gt;next!=<span class="literal">NULL</span> &amp;&amp; node2-&gt;next-&gt;next !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node2 = node2-&gt;next-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆序后半段链表</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//     转为</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3&lt;-3&lt;-2&lt;-1</span></span><br><span class="line">    node2 = node1-&gt;next;</span><br><span class="line">    node1-&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node3 = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        node1 = node2;</span><br><span class="line">        node2 = node3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node3 = node1;</span><br><span class="line">    node2 = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从前端和后端开始对比数字</span></span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span> &amp;&amp; node1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2-&gt;val != node1-&gt;val)&#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在程序中应该把链表恢复原样，毕竟还有可能要用到这个链表，参照上面，这里就偷懒没写了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没有写算法了，为了链表的逆序在纸上画了半天才理清逻辑。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android模拟屏幕点击</title>
    <link href="http://yoursite.com/2018/11/30/Android%E6%A8%A1%E6%8B%9F%E5%B1%8F%E5%B9%95%E7%82%B9%E5%87%BB/"/>
    <id>http://yoursite.com/2018/11/30/Android模拟屏幕点击/</id>
    <published>2018-11-30T02:28:20.000Z</published>
    <updated>2018-11-30T02:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。</p><p>也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB中的”adb shell tap x y”来点击屏幕，亲测可行，并且代码很简单。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> order = listOf(<span class="string">"input"</span>,</span><br><span class="line">                <span class="string">"tap"</span>,</span><br><span class="line">                <span class="string">""</span> + x,</span><br><span class="line">                <span class="string">""</span> + y)</span><br><span class="line">        ProcessBuilder(order).start()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要传入要点击点的位置坐标，所以要提前计算好坐标，因为我的是专用的Android设备，不用考虑分辨率适配什么的，所以就这样OK了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。&lt;/p&gt;
&lt;p&gt;也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现抽取音频、视频数据</title>
    <link href="http://yoursite.com/2018/11/27/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E3%80%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/11/27/FFmpeg代码实现抽取音频、视频数据/</id>
    <published>2018-11-27T08:40:27.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>应该是第一次在Mac上做C/C++开发，纠结过后选择使用CLion 开发。<a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">CLion</a>是 JetBrains下专门用来开发C/C++的IDE，已经用习惯了Android studio和IntelliJ IDEA ，所以CLion用起来还是很顺手的。</p><p>在新建一个C项目后，需要把FFmpeg的库导入才能正常运行。我们修改项目的CMakeLists.txt文件。</p><p><img src="/2018/11/27/FFmpeg代码实现抽取音频、视频数据/extr_voice.png" alt=""></p><h2 id="抽取音频AAC数据"><a href="#抽取音频AAC数据" class="headerlink" title="抽取音频AAC数据"></a>抽取音频AAC数据</h2><p>其实我们要做的主要就是一个文件的操作，把一个文件打开，从里面拿出它的一部分数据，再把这部分数据放到另一个文件中保存。</p><h5 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持各种各样的输出文件格式，MP4，FLV，3GP等等</span></span><br><span class="line">AVOutputFormat *output_fmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入流</span></span><br><span class="line">AVStream *in_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流</span></span><br><span class="line">AVStream *out_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储压缩数据</span></span><br><span class="line">AVPacket packet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要拷贝的流</span></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-打开输入文件，提取参数"><a href="#1-打开输入文件，提取参数" class="headerlink" title="1.打开输入文件，提取参数"></a>1.打开输入文件，提取参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开输入文件，关于输入文件的所有就保存到fmt_ctx中了</span></span><br><span class="line">err_code = avformat_open_input(&amp;fmt_ctx, src_fileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err_code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"cant open file:%s\n"</span>, av_err2str(err_code));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fmt_ctx-&gt;nb_streams&lt;<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//流数小于2，说明这个文件音频、视频流这两条都不能保证，输入文件有错误 </span></span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"输入文件错误，流不足2条\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//拿到文件中音频流</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"> <span class="comment">//参数信息</span></span><br><span class="line"> AVCodecParameters *in_codecpar = in_stream-&gt;codecpar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的音频流</span></span><br><span class="line">audio_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(audio_stream_index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"寻找最好音频流失败，请检查输入文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备输出文件，输出流"><a href="#2-准备输出文件，输出流" class="headerlink" title="2.准备输出文件，输出流"></a>2.准备输出文件，输出流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出上下文</span></span><br><span class="line">ofmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据目标文件名生成最适合的输出容器</span></span><br><span class="line">output_fmt = av_guess_format(<span class="literal">NULL</span>,dst_fileName,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(!output_fmt)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"根据目标生成输出容器失败！\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt_ctx-&gt;oformat = output_fmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建输出流</span></span><br><span class="line"> out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span>(!out_stream)&#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"创建输出流失败！\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-数据拷贝"><a href="#3-数据拷贝" class="headerlink" title="3. 数据拷贝"></a>3. 数据拷贝</h3><h4 id="3-1-参数信息"><a href="#3-1-参数信息" class="headerlink" title="3.1 参数信息"></a>3.1 参数信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将参数信息拷贝到输出流中，我们只是抽取音频流，并不做音频处理，所以这里只是Copy</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avcodec_parameters_copy(out_stream-&gt;codecpar, in_codecpar)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"拷贝编码参数失败！, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-初始化AVIOContext"><a href="#3-2-初始化AVIOContext" class="headerlink" title="3.2 初始化AVIOContext"></a>3.2 初始化AVIOContext</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化AVIOContext,文件操作由它完成</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, dst_fileName, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Could not open file %s, %d(%s)\n"</span>,</span><br><span class="line">           dst_fileName,</span><br><span class="line">           err_code,</span><br><span class="line">           errors);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-开始拷贝"><a href="#3-3-开始拷贝" class="headerlink" title="3.3 开始拷贝"></a>3.3 开始拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化 AVPacket， 我们从文件中读出的数据会暂存在其中</span></span><br><span class="line">av_init_packet(&amp;packet);</span><br><span class="line">packet.data = <span class="literal">NULL</span>;</span><br><span class="line">packet.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写头部信息</span></span><br><span class="line"><span class="keyword">if</span> (avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Error occurred when opening output file"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//每读出一帧数据</span></span><br><span class="line"><span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;packet) &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>(packet.stream_index == audio_stream_index)&#123;</span><br><span class="line">        <span class="comment">//时间基计算，音频pts和dts一致</span></span><br><span class="line">        packet.pts = av_rescale_q_rnd(packet.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br><span class="line">        packet.dts = packet.pts;</span><br><span class="line">        packet.duration = av_rescale_q(packet.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        packet.pos = <span class="number">-1</span>;</span><br><span class="line">        packet.stream_index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将包写到输出媒体文件</span></span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;packet);</span><br><span class="line">        <span class="comment">//减少引用计数，避免内存泄漏</span></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾部信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后别忘了释放内存</span></span><br><span class="line">avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">avio_close(ofmt_ctx-&gt;pb);</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>./MyC /Users/david/Desktop/1080p.mov /Users/david/Desktop/test.aac</code></p><h2 id="抽取视频数据"><a href="#抽取视频数据" class="headerlink" title="抽取视频数据"></a>抽取视频数据</h2><p>抽取视频信息并保存在文件中的流程甚至代码和上面抽取音频基本一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到文件中音频流 或者 视频流，所有流都在streams数组中</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的视频流</span></span><br><span class="line">video_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">packet.dts = av_rescale_q_rnd(packet.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br></pre></td></tr></table></figure><p>基本上就是一些参数的改变，所有流程和代码保持不变，就可以把一个音视频文件中的视频数据抽取出来了，mp4、H264等格式随便，就是这么简单。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。&lt;/p&gt;
&lt;h2 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h2&gt;&lt;p&gt;应该是第一次在Mac上做C/C++开发，纠
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用结构体、方法简介</title>
    <link href="http://yoursite.com/2018/11/23/FFmpeg%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/11/23/FFmpeg常用结构体、方法简介/</id>
    <published>2018-11-23T11:58:59.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。</p><h2 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><p>AVFormatContext是音视频数据,也就是音视频文件的一种抽象和封装，该结构体中包含了多路流，包括音频流、视频流、字幕流等，是FFmpeg中一个贯穿全局的数据结构，很多函数都要以它为参数。 </p><p>结构体定义如下（主要参数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span> <span class="comment">//输入容器格式,用于分流,通过avformat_open_input()设置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> <span class="comment">//输出容器格式,用于混流,必须在avformat_write_header()调用前设置</span></span><br><span class="line">    AVIOContext *pb;  <span class="comment">// I/O 上下文</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams; <span class="comment">// 流的总数</span></span><br><span class="line">    AVStream **streams; <span class="comment">//所有流的列表,由avformat_new_stream()创建新的流</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration; <span class="comment">//流的时长</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate; <span class="comment">//流的比特率</span></span><br><span class="line">    <span class="keyword">int64_t</span> probesize; <span class="comment">//从指定容器格式的输入中读取最大数据的大小,要足够起播首帧画面</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_analyze_duration; <span class="comment">//从指定容器格式的输入中读取的最大数据时长</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id; <span class="comment">// 视频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id; <span class="comment">// 音频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id; <span class="comment">// 字幕的codec_id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size; <span class="comment">// 每条流的最大内存字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer; <span class="comment">//从设备获取的实时帧缓冲的最大内存大小</span></span><br><span class="line">    AVDictionary *metadata; <span class="comment">// 整个文件的元数据</span></span><br><span class="line">    。。。 实在太多了，以后再慢慢了解吧</span><br><span class="line">&#125;AVFormatContext;</span><br></pre></td></tr></table></figure><h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>FFmpeg的解复用器对象，是类似COM接口的数据结构，表示输入文件容器格式，一个文件容器格式对应一个AVInputFormat结构，在程序运行时有多个实例。</p><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>是存储每一个视频/音频流信息的结构体，位于avoformat.h文件中。使用解复用器从容器中解析出不同的流，在FFmpeg中流的对象就是AVStream，保存在AVFormatContext的streams数组中。</p><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><p>描述编解码器上下文的数据结构，包含众多编解码器需要的参数信息。</p><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p>FFmpeg使用AVPacket来存放编码后的视频帧数据，AVPacket保存了解复用之后、解码之前的数据（仍然是压缩后的数据）和关于这些数据的一些附加信息。AVPacket实际上可用做一个容器，它本身不包含压缩的媒体数据，而是通过data指针引用数据的缓存空间。</p><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>存储编解码器信息的结构体。</p><h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><p>用来描述解码出的音视频数据，必须使用av_frame_alloc分配，av_frame_free释放。</p><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p>文件操作的顶层结构，实现了带缓冲的读写操作。</p><h3 id="URLProtocol"><a href="#URLProtocol" class="headerlink" title="URLProtocol"></a>URLProtocol</h3><p>是FFmpeg操作文件的结构，包括open、close、read、write、seek等操作。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all"></a>av_register_all</h3><p>初始化所有组件，只有调用了该函数，才能使用复用器和编解码器(FFmpeg4.0以上被废弃，不推荐使用，可以不调用)。</p><h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context"></a>avformat_alloc_context</h3><p>AVFormatContext要用avformat_alloc_context()进行初始化，分配内存空间。</p><h3 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input"></a>avformat_open_input</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>主要功能是打开一个文件，读取header，不会涉及打开解码器，与之对应的是avformat_close_input函数关闭文件。如果打开文件成功，AVFormatContext  ps就会在函数中初始化完成。</p><h3 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format"></a>av_guess_format</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVOutputFormat *<span class="title">av_guess_format</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *short_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *mime_type)</span></span>;</span><br></pre></td></tr></table></figure><p>从所编译的ffmpeg库支持的muxer中查找与文件名有关联的容器类型。</p><h3 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream"></a>avformat_new_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure><p>在 AVFormatContext 中创建新的 Stream 流通道。</p><h3 id="avio-open"><a href="#avio-open" class="headerlink" title="avio_open"></a>avio_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>用于打开FFmpeg的输入/输出文件。</p><h3 id="av-find-best-stream"><a href="#av-find-best-stream" class="headerlink" title="av_find_best_stream"></a>av_find_best_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_find_best_stream</span><span class="params">(AVFormatContext *ic,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">enum</span> AVMediaType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> wanted_stream_nb,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> related_stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                        AVCodec **decoder_ret,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>在文件中找到“最好”的用户所期望的流</p><h3 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame"></a>av_read_frame</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>读取码流中的若干音频帧或者1帧视频。</p><h3 id="av-rescale-q"><a href="#av-rescale-q" class="headerlink" title="av_rescale_q"></a>av_rescale_q</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> av_rescale_q(<span class="keyword">int64_t</span> a, AVRational bq, AVRational cq)</span><br></pre></td></tr></table></figure><p>这个函数的作用是计算a * bq / cq，来把时间戳从一个时基调整到另外一个时基。</p><h3 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame"></a>av_write_frame</h3><p>FFmpeg调用<code>avformat_write_header</code>函数写头部信息，<code>av_write_frame</code>函数写1帧数据，调用<code>av_write_trailer</code>写尾部信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。&lt;/p&gt;
&lt;h2 id=&quot;常用结构体&quot;&gt;&lt;a href=&quot;#常用结构体&quot; class=&quot;headerlink&quot; title=&quot;常用结构体&quot;&gt;&lt;/a&gt;常用结构体&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
