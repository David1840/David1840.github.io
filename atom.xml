<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-08-14T02:30:46.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android JNI开发--资源释放问题</title>
    <link href="http://yoursite.com/2019/08/13/Android-JNI%E5%BC%80%E5%8F%91-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/13/Android-JNI开发-资源释放问题/</id>
    <published>2019-08-13T06:19:18.000Z</published>
    <updated>2019-08-14T02:30:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又在开发JNI相关的项目了。本来一切正常，坐等测试完毕发布版本，然而理想是美好的，现实是骨感的。测试跑过来跟我说在测异常流程（开发人员听到估计就头疼）的时候发生了闪退问题。我赶紧拿过来自己测，果然复现了，日志中显示<code>local reference table overflow (max=512)</code> 。嗯？JNI中出现了内存泄漏？可是我已经按照网上的例子把所有该释放的对象都释放了啊，怎么回事啊？</p><p>先简单回顾下网上常见的：</p><ol><li><p>FindClass </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass ref= (env)-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">env-&gt;DeleteLocalRef(ref);</span><br></pre></td></tr></table></figure></li><li><p>NewString/ NewStringUTF/NewObject/NewByteArray</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 jstring 和 char*</span></span><br><span class="line">jstring jstr = (*jniEnv)-&gt;CallObjectMethod(jniEnv, test1, test2);</span><br><span class="line"><span class="keyword">char</span>* cstr = (<span class="keyword">char</span>*) (*jniEnv)-&gt;GetStringUTFChars(jniEnv,jstr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">(*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, jstr, cstr);</span><br><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, jstr);</span><br></pre></td></tr></table></figure></li><li><p>GetObjectField/GetObjectClass/GetObjectArrayElement</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass ref = env-&gt;GetObjectClass(robj);</span><br><span class="line">env-&gt;DeleteLocalRef(ref);</span><br></pre></td></tr></table></figure></li><li><p>GetByteArrayElements</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jbyte* <span class="built_in">array</span>= (*env)-&gt;GetByteArrayElements(env,jarray,&amp;isCopy);</span><br><span class="line">(*env)-&gt;ReleaseByteArrayElements(env,jarray,<span class="built_in">array</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>NewGlobalRef/DeleteGlobalRef</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobject ref= env-&gt;NewGlobalRef(<span class="name">customObj</span>)<span class="comment">;</span></span><br><span class="line">env-&gt;DeleteGlobalRef(<span class="name">customObj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ol><p>开始了苦逼的代码检查之路，检查代码，上面提到的我都已经做了处理，然后考虑各种方式，各种测试，还是会在异常流程中出现闪退，令人绝望。</p><p>最后，忽然看到了这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jbyteArray arr = (jbyteArray) (*env)-&gt;CallObjectMethod(env, local_object, methodID, java_slot,jbyteArray1);</span><br></pre></td></tr></table></figure><p>从JNI中反射调用Java层方法，返回了一个字节数组，这个字节数组会被JVM回收吗？我一直认为这个是会被虚拟机回收的，但到了现在，什么都有可能了，所以我测试了一下，果然，这个数组在异常流程中被不断创建，并且没有得到回收，所以很快就出现了<code>local reference table overflow (max=512)</code>错误。找到问题根源了，赶紧检查代码，所有类似的接口全部进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;DeleteLocalRef(env, arr);</span><br></pre></td></tr></table></figure><p>然后再次送测，终于没有问题了。</p><p>因为这个，要解决只要一行代码的问题，花费了我大半个下午时间，所以在这里记录一下，提醒自己，以后记得释放所有在Native层中创建的本地对象！也希望能帮到遇到类似问题的朋友。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近又在开发JNI相关的项目了。本来一切正常，坐等测试完毕发布版本，然而理想是美好的，现实是骨感的。测试跑过来跟我说在测异常流程（开发人员听到估计就头疼）的时候发生了闪退问题。我赶紧拿过来自己测，果然复现了，日志中显示&lt;code&gt;local reference table 
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0从画圆中了解坐标系统</title>
    <link href="http://yoursite.com/2019/07/25/OpenGL-ES-3-0%E4%BB%8E%E7%94%BB%E5%9C%86%E4%B8%AD%E4%BA%86%E8%A7%A3%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/</id>
    <published>2019-07-25T07:49:08.000Z</published>
    <updated>2019-07-26T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了绘制点、线、三角形，都很完美的展示出来了，所以有点小膨胀，想画一个圆形证明自己OpenGL已经入门了。</p><p>画一个圆形其实和画一个三角形没有太大区别，因为一个圆形也就是由无数个相同顶点的三角形组成的，三角形个数趋向于无限大的时候，整个图案也就越趋向于圆。顶点数据就不能手写了，可以靠代码生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] createPositions() &#123;</span><br><span class="line">    <span class="comment">// 绘制的半径</span></span><br><span class="line">    <span class="keyword">float</span> radius = <span class="number">0.8f</span>;</span><br><span class="line">    ArrayList&lt;Float&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">0.0f</span>); <span class="comment">//设置圆心坐标</span></span><br><span class="line">    data.add(<span class="number">0.0f</span>);</span><br><span class="line">    data.add(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">float</span> angDegSpan = <span class="number">360f</span> / <span class="number">360</span>; <span class="comment">// 分成360份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">float</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span> + angDegSpan; i += angDegSpan) &#123;</span><br><span class="line">        data.add((<span class="keyword">float</span>) (radius * Math.sin(i * Math.PI / <span class="number">180f</span>)));</span><br><span class="line">        data.add((<span class="keyword">float</span>) (radius * Math.cos(i * Math.PI / <span class="number">180f</span>)));</span><br><span class="line">        data.add(<span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[data.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">        f[i] = data.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把圆分成了 360 份。圆形的顶点数据也分为了三部分了，以原心作为我们的中心点，中间的 360 个点用来绘制三角形，最后一个点使得我们的图形闭合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES30.glDrawArrays(GLES30.GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">362</span>);</span><br></pre></td></tr></table></figure><p>当信心满满地运行后，现实却打了脸：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/1.png" alt=""></p><p>圆形变成了一个椭圆。。。 为什么呢？</p><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在<strong>-1.0</strong>到<strong>1.0</strong>之间，超出这个坐标范围的顶点都将不可见。</p><p>而在上面的例子中，假设实际手机分辨率以像素为单位是<code>720x1280</code>，我们默认使用<code>OpenGL</code>占用整个显示屏。<br>设备在竖屏模式下，那么<code>[-1，1]</code>的范围对应的高有<code>1280像素</code>，而宽却只有<code>720像素</code>。正因为标准化设备坐标假定坐标空间是一个正方形，而实际的设备屏幕不是正方形，因为宽高之间的比例，使得绘制结果与预料结果不一致。</p><p>如何解决这个问题？在OpenGL中使用了正交投影的方式解决这个问题。</p><p>在学习正交投影前先学习下OpenGL的坐标系统。</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>OpenGL中我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p><p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li>局部空间(Local Space，或者称为物体空间(Object Space))</li><li>世界空间(World Space)</li><li>观察空间(View Space，或者称为视觉空间(Eye Space))</li><li>裁剪空间(Clip Space)</li><li>屏幕空间(Screen Space)</li></ul><p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是<strong>模型(Model)</strong>、<strong>观察(View)</strong>、<strong>投影(Projection)</strong>三个矩阵。我们的顶点坐标起始于<strong>局部空间(Local Space)</strong>，在这里它称为<strong>局部坐标(Local Coordinate)</strong>，它在之后会变为<strong>世界坐标(World Coordinate)</strong>，<strong>观察坐标(View Coordinate)</strong>，<strong>裁剪坐标(Clip Coordinate)</strong>，并最后以<strong>屏幕坐标(Screen Coordinate)</strong>的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/coordinate_systems.png" alt=""></p><p>首先了解下OpenGL是一个右手坐标系，简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/coordinate_systems_right_handed.png" alt=""></p><h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>局部空间坐标是 OpenGL 绘制坐标的起点，接下来所有的转换操作都是在局部空间坐标基础上进行的。</p><p>局部空间坐标就是我们自己定义的起始坐标点，是相对于原点 <code>(0,0,0)(0,0,0)</code> 的。</p><p>此时所在的空间就是局部空间，也就是说我们在局部空间里面定义物体的起始坐标。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。</p><h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。</p><p>从日常生活的经验中可以很容易地了解到，随着摄像机位置、姿态的不同，就算是对同一 个场景进行拍摄，得到的画面也是迥然不同的。 因此摄像机的位置、姿态在 OpenGL ES 3.0 应用程序的开发中就显得非常重要，所以先介绍一下摄像机的设置方法。 </p><p>摄像机的设置需要给出 3 方面的信息，包括摄像机的位置、观察的方向以及 up 方向，具体情况如图所示。 </p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-Camera.png" alt=""></p><ul><li>摄像机的位置很容易理解，用其在 3D 空间中的坐标来表示。 </li><li>摄像机观察的方向可以理解为摄像机镜头的指向，用一个观察目标点来表示（通过摄像机位置与观察目标点可以确定一个向量，此向量即代表了摄像机观察的方向）。 </li><li>摄像机的 up 方向可以理解为摄像机顶端的指向，用一个向量来表示。 </li></ul><p>通过摄像机拍摄场景与人眼观察现实世界很类似，因此，通过人眼对现实世界观察的切身感受可以帮助读者理解摄像机的各个参数。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-eye.png" alt=""></p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p><p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<strong>正交投影矩阵(Orthographic Projection Matrix)</strong>或一个<strong>透视投影矩阵(Perspective Projection Matrix)</strong>。</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>OpenGL ES 3.0 中，根据应用程序中提供的投影矩阵，管线会确定一个可视空间区域，称为视景体。视景体是由 6 个平面确定的，这 6 个平面分别为：上平面（up）、下平面（down）、左平面（left）、右平面（right）、远平面（far）、近平面（near）。 </p><p>场景中处于视景体内的物体会被投影到近平面上（视景体外面的物体将被裁剪掉），然后再将近平面上投影出的内容映射到屏幕上的视口中。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-001.png" alt=""></p><p>由于正交投影是平行投影的一种，其投影线（物体的顶点与近平面上投影点的连线）是平行的。故其视景体为长方体，投影到近平面上的图形不会产生真实世界中“近大远小”的效果，下图更清楚地说明了这个问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-002.png" alt=""></p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>现实世界中人眼观察物体时会有“近大远小”的效果，我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/perspective.png" alt=""></p><p>由于透视，这两条线在很远的地方看起来会相交。因此，要想开发出更加真实的场景，仅使用正交投影是远远不够的，这时可以采用透视投影。透视投影的投影线是不平行的，他们相交于视点。通过透视投影，可以产生现实世界中“近大远小”的效果，大部分 3D 游戏采用的都是透视投影。</p><p>透视投影中，视景体为锥台形区域，如图所示。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-003.png" alt=""></p><p>从上图中可以看出，透视投影的投影线互不平行，都相交于视点。因此，同样尺寸的物体，近处的投影出来大，远处的投影出来小，从而产生了现实世界中“近大远小”的效果。下图更清楚地说明了这个问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-004.png" alt=""></p><h3 id="把它们都组合到一起"><a href="#把它们都组合到一起" class="headerlink" title="把它们都组合到一起"></a>把它们都组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-005.png" alt=""></p><p>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p><h2 id="实现画圆"><a href="#实现画圆" class="headerlink" title="实现画圆"></a>实现画圆</h2><p>上面大概了解了下OpenGL的坐标系统，里面涉及的知识实在太多，后面慢慢了解。我们先使用正交投影完成一个完美的圆的绘制。为了解决图像拉伸问题，就是要保证近平面的宽高比和视口的宽高比一致，而且是以较短的那一边作为 1 的标准，让图像保持居中。</p><p>OpenGL中通过调用 Matrix 类的 orthoM 方法完成对正交投影的设置，其基本代码如下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">orthoM(<span class="keyword">float</span>[] m,                            <span class="comment">//存储生成矩阵元素的float[]类型数组</span></span><br><span class="line">       <span class="keyword">int</span> mOffset,                          <span class="comment">//填充起始偏移量</span></span><br><span class="line">       <span class="keyword">float</span> left,<span class="keyword">float</span> right,               <span class="comment">//near面的left、right</span></span><br><span class="line">       <span class="keyword">float</span> bottom,<span class="keyword">float</span> top,               <span class="comment">//near面的bottom、top</span></span><br><span class="line">       <span class="keyword">float</span> near,<span class="keyword">float</span> far)                 <span class="comment">//near面、far面与视点的距离</span></span><br></pre></td></tr></table></figure><ul><li>orthoM 方法的功能为根据接收的 6 个正交投影相关参数产生正交投影矩阵，并将矩阵的元素填充到指定的数组中。</li><li>参数 left、right 为近平面左右侧边对应的 x 坐标，top、bottom 为近平面上下侧边对应的 y坐标，分别用来确定左平面、右平面、上平面、下平面的位置。参数 near、far 分别为视景体近平面与远平面距视点的距离。</li></ul><p>近平面的坐标原点位于中心，向右为 X 轴正方向，向上为 Y 轴正方向，所以我们的 left、bottom 要为负数，而 right、top 要为正数。同时，近平面和远平面的距离都是指相对于视点的距离，所以 near、far 要为正数，而且 far&gt;near。</p><p>可以在 GLSurfaceView 的 surfaceChanged 里面来设定正交投影矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> aspectRatio = width &gt; height ? (<span class="keyword">float</span>) width / (<span class="keyword">float</span>) height : (<span class="keyword">float</span>) height / (<span class="keyword">float</span>) width;</span><br><span class="line"><span class="keyword">if</span> (width &gt; height) &#123;</span><br><span class="line">    Matrix.orthoM(mMatrix, <span class="number">0</span>, -aspectRatio, aspectRatio, -<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">10f</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Matrix.orthoM(mMatrix, <span class="number">0</span>, -<span class="number">1f</span>, <span class="number">1f</span>, -aspectRatio, aspectRatio, <span class="number">0f</span>, <span class="number">10f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把近平面和视口的宽高比设置为一致的了，解决了之前图像被拉伸的问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/2.png" alt=""></p><p>完整代码请看Github：<a href="https://github.com/David1840/OpenGLES-Learning/blob/master/app/src/main/java/com/david/opengl/render/CircleRenderer.java" target="_blank" rel="noopener"><strong>OpenGLES-Learning : CircleRenderer</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前学习了绘制点、线、三角形，都很完美的展示出来了，所以有点小膨胀，想画一个圆形证明自己OpenGL已经入门了。&lt;/p&gt;
&lt;p&gt;画一个圆形其实和画一个三角形没有太大区别，因为一个圆形也就是由无数个相同顶点的三角形组成的，三角形个数趋向于无限大的时候，整个图案也就越趋向于圆。
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0着色语言</title>
    <link href="http://yoursite.com/2019/07/24/OpenGL-ES-3-0%E7%9D%80%E8%89%B2%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/07/24/OpenGL-ES-3-0着色语言/</id>
    <published>2019-07-24T02:46:47.000Z</published>
    <updated>2019-07-26T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL ES 着色语言是一种高级的图形编程语言，其源自应用广泛的 C 语言，同时具有 RenderMan 以及其他着色语言的一些优良特性，易于被开发人员掌握。</p><p>与传统通用编程语言有很大不同的是，其提供了更加丰富的原生类型，如向量、矩阵等。这 些特性的加入使得 OpenGL ES 着色语言在处理 3D 图形方面更加高效、易用。简单来说，OpenGL  ES 着色语言主要包括以下特性。</p><p> OpenGL ES 着色语言是一种高级的过程语言（注意，不是面向对象）。 </p><p> 对顶点着色器、片元着色器使用的是同样的语言，不做区分。 </p><p> 基于 C/C++的基本语法及流程控制。 </p><p> 完美支持向量与矩阵的各种操作。 </p><p> 通过类型限定符来管理输入与输出。 </p><p> 拥有大量的内置函数来提供丰富的功能</p><p>总之，OpenGL ES 着色语言是一种易于实现、功能强大、便于使用，并且可以高度并行处理、性能优良的高级图形编程语言。其可以帮助开发人员在不浪费大量时间的情况下，轻松地为用户带来更完美的视觉体验，开发出更加酷炫的 3D 场景与特效。</p><h2 id="着色语言基础"><a href="#着色语言基础" class="headerlink" title="着色语言基础"></a>着色语言基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-标量"><a href="#1-标量" class="headerlink" title="1. 标量"></a>1. 标量</h4><p>标量也被称为“无向量”，其值只具有大小，并不具有方向。</p><ul><li>布尔型 bool</li><li>有符号整型int 和 无符号整型 uint</li><li>浮点型 float</li></ul><h4 id="2-向量"><a href="#2-向量" class="headerlink" title="2. 向量"></a>2. 向量</h4><p>向量可以看做是用同样类型的标量组成的，其基本类型也分为 bool、int、uint 及 float 四种。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL1.png" alt="各向量类型及说明"></p><p>向量在着色器代码的开发中有着十分重要的作用，可以很方便地存储以及操作颜色、位置、纹理坐标等不仅包含一个组成部分的量。开发中，有时也可能需要单独访问向量中的某个分量， 基本的语法为“&lt;向量名&gt;.&lt;分量名&gt;”，根据目的的不同，主要有如下几种用法。</p><ul><li><p>将一个向量看作颜色时，可以使用 r、g、b、a 四个分量名，其分别代表红、绿、蓝、透明度 4 个色彩通道，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aColor.r=<span class="number">0.6</span>; <span class="comment">//给向量 aColor 的红色通道分量赋值 </span></span><br><span class="line"></span><br><span class="line">aColor.g=<span class="number">0.8</span>; <span class="comment">//给向量 aColor 的绿色通道分量赋值</span></span><br></pre></td></tr></table></figure></li><li><p>将一个向量看作位置时，可以使用 x、y、z、w 四个分量名，其分别代表 x 轴、y 轴、z轴分量及 W 值，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aPosition.x=<span class="number">67.2</span>; <span class="comment">//给向量 aPosition 的 X 分量赋值 </span></span><br><span class="line"></span><br><span class="line">aPosition.z=<span class="number">48.3</span>; <span class="comment">//给向量 aPosition 的 Z 分量赋值</span></span><br></pre></td></tr></table></figure></li><li><p>将一个向量看作纹理坐标时，可以使用 s、t、p、q 四个分量名，其分别代表纹理坐标的不同分量，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aTexCoor.s=<span class="number">0.65</span>; <span class="comment">//给向量 aTexCoor 的 s 分量赋值 </span></span><br><span class="line"></span><br><span class="line">aTexCoor.t=<span class="number">0.34</span>; <span class="comment">//给向量 aTexCoor 的 t 分量赋值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h4><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL2.png" alt="矩阵的类型及说明"></p><p>OpenGL ES 着色语言中，矩阵是按列顺序组织的，也就是一个矩阵可以看作由几个列向量组成。对于矩阵的访问，可以将矩阵作为列向量的数组来访问。如 matrix 为一个 mat4，可以使用<code>matrix[2]</code>取到该矩阵的第 3 列，其为一个 vec4；也可以使用 <code>matrix[2][2]</code>取得第 3 列的向量的第 3个分量，其为一个 float；其他的依此类推。</p><h4 id="4-采样器"><a href="#4-采样器" class="headerlink" title="4. 采样器"></a>4. 采样器</h4><p>采样器是着色语言中不同于 C 语言的一种特殊的基本数据类型，其专门用来进行纹理采样的相关操作。一般情况下，一个采样器变量代表一幅或一套纹理贴图。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL3.png" alt="采样器基本类型及说明"></p><h4 id="5-结构体"><a href="#5-结构体" class="headerlink" title="5. 结构体"></a>5. 结构体</h4><p>使用 <strong>struct</strong> 关键字进行声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">   vec3 color;</span><br><span class="line">   vec3 position;</span><br><span class="line">   vec2 textureCoor;</span><br><span class="line">&#125;</span><br><span class="line">info CubeInfo;</span><br></pre></td></tr></table></figure><h4 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h4><p>在着色语言中，开发人员可以声明任何类型的数组。声明数组的方式主要有两种，具体如下所列。</p><ol><li><p>在声明数组的同时，指定数组的大小：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 <span class="attribute">position</span><span class="selector-attr">[20]</span>; <span class="comment">//声明了一个包含 20 个 vec3 的数组，索引从 0 开始</span></span><br></pre></td></tr></table></figure></li><li><p>在声明数组并初始化的同时，可以不指定数组的大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float x[<span class="string"></span>]=float[<span class="string">2</span>](<span class="link">1.0,2.0</span>); //数组的长度为 2 </span><br><span class="line">float y[<span class="string"></span>]=float[](1.0,2.0,3.0); //数组的长度为 3</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>OpenGL ES 3.0 的着色语言只支持一维数组的使用，不支持二维以及更多维数组 </p><p>的使用。对于这一点，请读者稍加注意。</p></blockquote><h4 id="7-空类型"><a href="#7-空类型" class="headerlink" title="7. 空类型"></a>7. 空类型</h4><p>空类型使用 <code>void</code> 表示，仅用来声明不返回任何值的函数，比如着色器中的 main 函数就是一个返回值为 <code>void</code> 类型的函数。</p><h3 id="存储限定符"><a href="#存储限定符" class="headerlink" title="存储限定符"></a>存储限定符</h3><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL4.png" alt="4种存储限定符及说明"></p><p>限定符在使用时应该放在变量类型之前，且使用 in、uniform 以及 out 限定符修饰的变量必须为全局变量。</p><p>着色器语言中没有默认限定符的概念，因此如果有需要，必须为全局变量明确指定需要的限定符。</p><h4 id="1-in-centroid-in限定符"><a href="#1-in-centroid-in限定符" class="headerlink" title="1. in/centroid in限定符"></a>1. in/centroid in限定符</h4><p>in/centroid in 限定符修饰的全局变量又称为输入变量，其形成当前着色器与渲染管线前驱阶段的动态输入接口。输入变量的值是在着色器开始执行时，由渲染管线的前一阶段送入。在着色器程序执行过程中，变量不可以被重新赋值。in/centroid in 限定符的使用分为如下两种情况。</p><ol><li><p>顶点着色器的输入变量</p><p>顶点着色器中只能使用 in 限定符来修饰全局变量，不能使用 centroid in 限定符和interpolation 限定符。</p><p>顶点着色器中用 in 限定符修饰的变量其值实质是由宿主程序（本书中为 Java、C++）批量传入渲染管线的，管线进行基本处理后再传递给顶点着色器。数据中有多少个顶点，管线就调用多少次顶点着色器，每次将一个顶点的各种属性数据传递给顶点着色器中对应的 in 变 量。因此，顶点着色器每次执行将完成对一个顶点各项属性数据的处理。</p><p>在顶点着色器中，in 限定符只能用来修饰浮点数标量、浮点数向量、矩阵变量以及有符号或无符号的整型标量或整型向量，不能用来修饰其他类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in vec3 aPosition; <span class="comment">//顶点位置</span></span><br><span class="line">in vec3 aNormal; <span class="comment">//顶点法向量</span></span><br></pre></td></tr></table></figure></li><li><p>片元着色器的输入变量</p><p>片元着色器中可以使用 in 或 centroid in 限定符来修饰全局变量，其变量用于接收来自顶点着 色器的相关数据，最典型的是接收根据顶点着色器的顶点数据插值产生的片元数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in vec3 vPosition; <span class="comment">//接收从顶点着色器传递过来的顶点位置数据</span></span><br><span class="line">centroid in vec2 vTexCoord; <span class="comment">//接收从顶点着色器传递过来的纹理坐标数据</span></span><br><span class="line">flat in vec3 vColor; <span class="comment">//接收从顶点着色器传递过来的颜色数据</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-uniform-限定符"><a href="#2-uniform-限定符" class="headerlink" title="2. uniform 限定符"></a>2. uniform 限定符</h4><p>uniform 为一致变量限定符，一致变量指的是对于同一组顶点组成的单个 3D 物体中所有顶点都相同的量。uniform 变量可以用在顶点着色器或片元着色器中，其支持用来修饰所有的基本数据类型。与 in 变量类似，一致变量的值也是从宿主程序传入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniform mat4 uMVPMatrix; <span class="comment">//总变换矩阵</span></span><br><span class="line">uniform mat4 uMMatrix; <span class="comment">//基本变换矩阵</span></span><br><span class="line">uniform vec3 uLightLocation; <span class="comment">//光源位置</span></span><br><span class="line">uniform vec3 uCamera; <span class="comment">//摄像机位置</span></span><br></pre></td></tr></table></figure><h4 id="3-out-centroid-out-限定符"><a href="#3-out-centroid-out-限定符" class="headerlink" title="3. out/centroid out 限定符"></a>3. out/centroid out 限定符</h4><p>out/centroid out 限定符修饰的全局变量又称为输出变量，其形成当前着色器与渲染管线后继阶段的动态输出接口。通常在当前着色器程序执行完毕时，输出变量的值才被送入后继阶段进行处理。因此，不能在着色器中声明同时起到输入和输出作用的 inout 全局变量，out/centroid out 限定符的使用分为如下两种情况。</p><ol><li><p>顶点着色器的输出变量</p><p>顶点着色器中可以使用 out 或 centroid out 限定符修饰全局变量，其变量用于向渲染管线后继 阶段传递当前顶点的数据。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL5.png" alt="了默认情况下out变量的工作原理"></p><p>从图中可以看出，在默认情况下，首先顶点着色器在每个顶点中都对 out 变量 vPosition进行了赋值。接着在片元着色器中接收 in 变量 vPosition 的值时得到的并不是某个顶点赋的特定值，而是根据片元所在的位置及图元中各个顶点的位置进行插值计算产生的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out vec4 ambient; <span class="comment">//环境光 out 变量</span></span><br><span class="line">out vec4 diffuse; <span class="comment">//散射光 out 变量</span></span><br><span class="line">centroid out vec2 texCoor; <span class="comment">//纹理坐标 out 变量</span></span><br><span class="line">invariant centroid out vec4 color; <span class="comment">//颜色值 out 变量</span></span><br></pre></td></tr></table></figure></li><li><p>片元着色器的输出变量</p><p>在片元着色器中只能使用 out 限定符来修饰全局变量，而不能使用 centroid out 限定符。片元着色器中的 out 变量一般指的是由片元着色器写入计算完成片元颜色值的变量，一般在片元着色器的最后都需要对其进行赋值，最后将其送入渲染管线的后继阶段进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out vec4 fragColor; <span class="comment">//输出的片元颜色</span></span><br><span class="line">out uint luminosity;</span><br></pre></td></tr></table></figure><blockquote><p>对于顶点着色器而言，一般是既声明 out 变量，又对 out 变量进行赋值用以传递给片元着色器。而片元着色器中声明 in 变量用于接收顶点着色器传过来的值即可，是不可以对 in 变量赋值的。OpenGL ES 3.0 中片元着色器内的内建输出变量gl_FragColor（此内建变量在 OpenGL ES 2.0 中几乎总要用到）不存在了，需要自己声明 out（vec4）变量，用声明的 out 变量替代 gl_FragColor 内建变量。</p></blockquote></li></ol><h4 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4. const限定符"></a>4. const限定符</h4><p>用 const 限定符修饰的变量是只读的，其值是不可以变的，也就是常量，又称为编译时常量。</p><h3 id="插值限定符"><a href="#插值限定符" class="headerlink" title="插值限定符"></a>插值限定符</h3><p>插值（interpolation）限定符，其主要用于控制顶点着色器传递到片元着色器数据的插值方式。插值限定符包含 smooth、flat 两种。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL6.png" alt="两种限定符及说明"></p><ol><li><p>smooth限定符</p><p>如果顶点着色器中 out 变量之前含有 smooth 限定符或者不含有任何限定符，则传递到后继片元着色器对应的 in 变量的值，是在光栅化阶段由管线根据片元所属图元各个顶点对应的顶点着色器对此 out 变量的赋值情况，及片元与各顶点的位置关系插值产生。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL7.png" alt="顶点着色器中smooth限定符修饰out变量的工作原理"></p><p>从图中可以看出，当顶点着色器中的 out 变量被 smooth 限定符修饰时，首先顶点着色器在每个顶点中都对 out 变量 vColor 进行了赋值，接着在片元着色器中接收 in 变量 vColor 的值时得到的并不是某个顶点赋的特定值，而是根据片元的位置及图元中各个顶点的位置与各个顶点赋值的情况进行插值计算产生的值。</p><p>下面的代码片段给出了在顶点着色器中正确使用 smooth 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">smooth</span> <span class="keyword">out</span> <span class="type">vec3</span> normal; <span class="comment">// 顶点着色器 out 变量</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了在片元着色器中正确使用 smooth 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">smooth</span> <span class="keyword">in</span> <span class="type">vec3</span> normal; <span class="comment">//片元着色器 in 变量</span></span><br></pre></td></tr></table></figure></li><li><p>flat 限定符</p><p>如果顶点着色器中 out 变量之前含有 flat 限定符，则传递到后继片元着色器中对应的 in 变量的值不是在光栅化阶段插值产生的，一般是由图元的最后一个顶点对应的顶点着色器对此 out 变量所赋的值决定的。此时，图元中每个片元的此项值均相同。</p><p>下面的代码片段给出了在顶点着色器中正确使用 flat 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flat</span> <span class="keyword">out</span> <span class="type">vec4</span> vColor; <span class="comment">//用于传递给片元着色器的变量</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了在片元着色器中正确使用 flat 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flat</span> <span class="keyword">in</span> <span class="type">vec4</span> vColor; <span class="comment">//用于接收来自顶点着色器的变量</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="一致块"><a href="#一致块" class="headerlink" title="一致块"></a>一致块</h3><p>多个一致变量的声明可以通过类似结构体形式的接口块实现，该形式的接口块又称为一致块（uniform block）。一致块的数据是通过缓冲对象送入渲染管线的，以一致块的形式批量传送数据比单个传送效率高，其基本语法为：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;layout 限定符&gt;]</span> uniform 一致块名称 &#123;&lt;成员变量列表&gt;&#125; <span class="meta">[&lt;实例名&gt;]</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了一致块在顶点着色器中的正确使用。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> Transform&#123;            <span class="comment">//声明一个 uniform 接口块</span></span><br><span class="line">  <span class="type">float</span> radius;               <span class="comment">//半径成员</span></span><br><span class="line">  <span class="type">mat4</span> modelViewMatrix;       <span class="comment">//矩阵成员</span></span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">mat3</span> normalMatrix;  <span class="comment">//矩阵成员</span></span><br><span class="line">&#125; block_Transform;</span><br></pre></td></tr></table></figure><h3 id="layout限定符"><a href="#layout限定符" class="headerlink" title="layout限定符"></a>layout限定符</h3><p>layout 限定符是从 OpenGL ES 3.0 开始出现的，其主要用于设置变量的存储索引（即引用）值，声明有几种不同的形式。 </p><ul><li><p>其可以作为接口块定义的一部分或者接口块的成员。</p></li><li><p>其也可以仅仅修饰 uniform，用于建立其他一致变量声明的参照，语法如下。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">layout</span> 限定符&gt; <span class="keyword">uniform</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>其还可以用于修饰被接口限定符修饰的单独变量，语法如下。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;layout 限定符&gt;</span> <span class="section">&lt;接口限定符&gt;</span> <span class="section">&lt;变量声明&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>接口限定符有 in、out、uniform 三种选择，layout 限定符修饰接口限定符的内容将在下面进行介绍，具体内容如下。</p><ol><li><p>layout 输入限定符</p><p>顶点着色器允许 layout 输入限定符修饰输入变量的声明。下面的代码片段说明了这种形式的声明。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPosition; <span class="comment">// aPosition 输入变量的引用值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> aColor; <span class="comment">// aColor 输入变量的引用值为 1</span></span><br></pre></td></tr></table></figure></li><li><p>layout 输出限定符</p><p>片元着色器中，layout 限定符通过 location 值将输出变量和指定编号的绘制缓冲绑定起来。每一个输出变量的索引（引用）值都会对应到一个相应编号的绘制缓冲，而这个输出变量的值将写入相应缓冲。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> fragColor; <span class="comment">//此输出变量写入到 0 号绘制缓冲</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec4</span> colors[<span class="number">2</span>]; <span class="comment">//此输出变量写入到 1 号绘制缓冲</span></span><br></pre></td></tr></table></figure><p>顶点着色器不允许有 layout 输出限定符。</p></li></ol><h2 id="特殊的内建函数"><a href="#特殊的内建函数" class="headerlink" title="特殊的内建函数"></a>特殊的内建函数</h2><h3 id="顶点着色器中的内建函数"><a href="#顶点着色器中的内建函数" class="headerlink" title="顶点着色器中的内建函数"></a>顶点着色器中的内建函数</h3><ol><li><p>内建输入变量</p><p>顶点着色器中的内建输入变量主要有 <strong>gl_VertexID</strong> 以及<strong>gl_InstanceID</strong>。这两个变量分别为顶点整数索引和实例 ID，都只在顶点着色器中使用，其具体含义如下。</p><ul><li><p>gl_VertexID</p><p>gl_VertexID 是顶点着色器的一个内建输入变量，类型为“highp int”，主要用来记录顶点的整数索引。</p></li><li><p>gl_InstanceID</p><p>gl_InstanceID 是顶点着色器的另一个内建输入变量，类型为“highp int”，其用来记录采用实例绘制时当前图元对应的实例号。如果当前图元不是来自于实例绘制，则 gl_InstanceID 的值为 0。</p></li></ul></li><li><p>内建输出变量</p><p>顶点着色器中的内建输出变量主要有 <strong>gl_Position</strong> 和 <strong>gl_PointSize</strong>。这两个变量分别用来存放处理后顶点的位置和顶点的大小，都只能在顶点着色器中使用</p></li></ol><h3 id="片元着色器中的内建变量"><a href="#片元着色器中的内建变量" class="headerlink" title="片元着色器中的内建变量"></a>片元着色器中的内建变量</h3><p>片元着色器的内建变量分为输入和输出变量，其中输入变量包括 gl_FragCoord、gl_FrontFacing和 gl_PointCoord。输出变量包括 gl_FragDepth，其值为片元深度值.</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>与其他高级语言类似，为了方便开发，OpenGL ES 着色语言中也ᨀ供了很多的内置函数。这些函数大都已经被重载，一般具有 4 种变体，分别用来接收和返回 genType、genIType、genUType和 genBType 类型的值。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL8.png" alt="4种变体及说明"></p><h2 id="用-invariant-修饰符避免值变问题"><a href="#用-invariant-修饰符避免值变问题" class="headerlink" title="用 invariant 修饰符避免值变问题"></a>用 invariant 修饰符避免值变问题</h2><p>值变问题是指在同样的着色器程序多次运行时，同一个表达式在同样输入值的情况下多次运行，结果不精确一致的现象。在大部分情况下，这并不影响最终效果的正确性。 </p><p>如果在某些特定情况下需要避免值变问题，可以用 invariant 修饰符来修饰变量。采用 invariant修饰符修饰变量主要有如下两种方式。</p><p>（1）在声明变量时加上 invariant 修饰符，具体情况参考如下代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">invariant</span> <span class="keyword">out</span> <span class="type">vec3</span> color;</span><br></pre></td></tr></table></figure><p>（2）对已经声明的变量补充使用 invariant 修饰符进行修饰，具体情况参考如下代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> color; </span><br><span class="line"><span class="keyword">invariant</span> color;</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的变量都可以用 invariant 修饰符修饰，只有符合如下几种情况的变量可以用 invariant 修饰符修饰。 </p><p> 顶点着色器中的内建输出变量，如 gl_Position。 </p><p> 顶点着色器中声明的以 out 修饰符修饰的变量。 </p><p> 片元着色器中内建的输出变量。 </p><p> 片元着色器中声明的以 out 修饰符修饰的变量。</p><p>另外一点就是，在使用时要注意，invariant 修饰符要放在其他的修饰符之前。同时，invariant修饰符只能用来修饰全局变量。</p><p>本文摘抄自《OpenGL ES 3.x 游戏开发》上卷</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenGL ES 着色语言是一种高级的图形编程语言，其源自应用广泛的 C 语言，同时具有 RenderMan 以及其他着色语言的一些优良特性，易于被开发人员掌握。&lt;/p&gt;
&lt;p&gt;与传统通用编程语言有很大不同的是，其提供了更加丰富的原生类型，如向量、矩阵等。这 些特性的加入
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0绘制基础图形-点、线、三角</title>
    <link href="http://yoursite.com/2019/06/26/OpenGL-ES-3-0%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2-%E7%82%B9%E3%80%81%E7%BA%BF%E3%80%81%E4%B8%89%E8%A7%92/"/>
    <id>http://yoursite.com/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/</id>
    <published>2019-06-26T01:15:36.000Z</published>
    <updated>2019-06-26T07:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始正式学习OpenGL ES开发！</p><p>本博客是我在学习过程中做的记录，也希望和各位分享我的学习过程，如有错误，欢迎留言指正，共同学习。</p><h3 id="定义输入坐标"><a href="#定义输入坐标" class="headerlink" title="定义输入坐标"></a>定义输入坐标</h3><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] vertexPoints = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度都是一样的，从而使它看上去像是2D的。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/OpenGLES3-2-1.png" alt=""></p><p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p><h3 id="分配本地内存"><a href="#分配本地内存" class="headerlink" title="分配本地内存"></a>分配本地内存</h3><p>因为<code>OpenGL</code>作为本地系统库运行在系统中，虚拟机需要分配本地内存，供其存取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配内存空间,每个浮点型占4字节空间</span></span><br><span class="line">    vertexBuffer = ByteBuffer.allocateDirect(vertexPoints.length * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer();</span><br><span class="line">    <span class="comment">//传入指定的坐标数据</span></span><br><span class="line">    vertexBuffer.put(vertexPoints);</span><br><span class="line">    vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String vertextShader =</span><br><span class="line">        <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">        <span class="string">"layout (location = 0) in vec4 vPosition;\n"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">        <span class="string">"     gl_Position  = vPosition;\n"</span> + <span class="comment">//</span></span><br><span class="line">        <span class="string">"     gl_PointSize = 10.0;\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p><code>输入属性的数组</code>(一个名为<code>vPosition</code>的4分量向量)，<code>layout (location = 0)</code>表示这个变量的位置是顶点属性0。</p><p>将<code>vPosition</code>输入属性拷贝到名为<code>gl_Position</code>的特殊输出变量。</p><p>将浮点数据<code>10.0</code>拷贝到<code>gl_PointSize</code>的变量中。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 片段着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String fragmentShader =</span><br><span class="line">        <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">        <span class="string">"precision mediump float;\n"</span> +</span><br><span class="line">        <span class="string">"out vec4 fragColor;\n"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">        <span class="string">"     fragColor = vec4(1.0,1.0,1.0,1.0);\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p>声明着色器中浮点变量的默认精度。</p><p>着色器声明一个<code>输出变量fragColor</code>，这个是一个4分量的向量。</p><p>表示将颜色值<code>(1.0,1.0,1.0,1.0)</code>，输出到颜色缓冲区。</p><h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type       顶点着色器:GLES30.GL_VERTEX_SHADER</span></span><br><span class="line"><span class="comment"> *                   片段着色器:GLES30.GL_FRAGMENT_SHADER</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileShader</span><span class="params">(<span class="keyword">int</span> type, String shaderCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> shaderId = GLES30.glCreateShader(type);</span><br><span class="line">    <span class="keyword">if</span> (shaderId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//加载到着色器</span></span><br><span class="line">        GLES30.glShaderSource(shaderId, shaderCode);</span><br><span class="line">        <span class="comment">//编译着色器</span></span><br><span class="line">        GLES30.glCompileShader(shaderId);</span><br><span class="line">        <span class="comment">//检测状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            String logInfo = GLES30.glGetShaderInfoLog(shaderId);</span><br><span class="line">            System.err.println(logInfo);</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            GLES30.glDeleteShader(shaderId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shaderId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-OpenGL-程序和着色器链接"><a href="#创建-OpenGL-程序和着色器链接" class="headerlink" title="创建 OpenGL 程序和着色器链接"></a>创建 OpenGL 程序和着色器链接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vertexShaderId   顶点着色器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fragmentShaderId 片段着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linkProgram</span><span class="params">(<span class="keyword">int</span> vertexShaderId, <span class="keyword">int</span> fragmentShaderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> programId = GLES30.glCreateProgram();</span><br><span class="line">    <span class="keyword">if</span> (programId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//将顶点着色器加入到程序</span></span><br><span class="line">        GLES30.glAttachShader(programId, vertexShaderId);</span><br><span class="line">        <span class="comment">//将片元着色器加入到程序中</span></span><br><span class="line">        GLES30.glAttachShader(programId, fragmentShaderId);</span><br><span class="line">        <span class="comment">//链接着色器程序</span></span><br><span class="line">        GLES30.glLinkProgram(programId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//验证OpenGL程序是否可用</span></span><br><span class="line">        GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            String logInfo = GLES30.glGetProgramInfoLog(programId);</span><br><span class="line">            System.err.println(logInfo);</span><br><span class="line">            GLES30.glDeleteProgram(programId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> programId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>准备工作结束，下来就开始绘制图形了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRenderer</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span></span></span><br></pre></td></tr></table></figure><p>实现<code>GLSurfaceView.Renderer</code>接口</p><h4 id="onSurfaceCreated"><a href="#onSurfaceCreated" class="headerlink" title="onSurfaceCreated"></a>onSurfaceCreated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl10, EGLConfig eglConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置背景颜色</span></span><br><span class="line">    GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = compileShader(GLES30.GL_VERTEX_SHADER, vertextShader);</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = compileShader(GLES30.GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    <span class="comment">//在OpenGLES环境中使用程序</span></span><br><span class="line">    GLES30.glUseProgram(linkProgram(vertexShaderId, fragmentShaderId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onSurfaceChanged"><a href="#onSurfaceChanged" class="headerlink" title="onSurfaceChanged"></a>onSurfaceChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl10, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//设置视图窗口</span></span><br><span class="line">    GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onDrawFrame"><a href="#onDrawFrame" class="headerlink" title="onDrawFrame"></a>onDrawFrame</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl10)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把颜色缓冲区设置为我们预设的颜色</span></span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">//启用顶点的句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绘制三个点</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_POINTS, 0, 3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制直线</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_LINE_STRIP, 0, 2);</span></span><br><span class="line"><span class="comment">//        GLES30.glLineWidth(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="点-GLES30-GL-POINTS"><a href="#点-GLES30-GL-POINTS" class="headerlink" title="点 GLES30.GL_POINTS"></a>点 GLES30.GL_POINTS</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/point.jpg" alt=""></p><h5 id="线-GLES30-GL-LINE-STRIP"><a href="#线-GLES30-GL-LINE-STRIP" class="headerlink" title="线 GLES30.GL_LINE_STRIP"></a>线 GLES30.GL_LINE_STRIP</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/line.jpg" alt=""></p><h5 id="三角形-GLES30-GL-TRIANGLES"><a href="#三角形-GLES30-GL-TRIANGLES" class="headerlink" title="三角形 GLES30.GL_TRIANGLES"></a>三角形 GLES30.GL_TRIANGLES</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/triangles.jpg" alt=""></p><p>通过<code>glDrawArrays</code>方法来执行最后的绘制，<code>GL_POINTS</code>代表绘制的类型（图元类型），而参数<code>0，1</code>则代表绘制的点的范围，它是一个左闭右开的区间。</p><h4 id="常用图元类型"><a href="#常用图元类型" class="headerlink" title="常用图元类型"></a>常用图元类型</h4><table><thead><tr><th style="text-align:left">图元类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_POINTS</td><td style="text-align:left">点精灵图元，对指定的每个顶点进行绘制。</td></tr><tr><td style="text-align:left">GL_LINES</td><td style="text-align:left">绘制一系列不相连的线段。</td></tr><tr><td style="text-align:left">GL_LINE_STRIP</td><td style="text-align:left">绘制一系列相连的线段。</td></tr><tr><td style="text-align:left">GL_LINE_LOOP</td><td style="text-align:left">绘制一系列相连的线段，首尾相连。</td></tr><tr><td style="text-align:left">GL_TRIANGLES</td><td style="text-align:left">绘制一系列单独的三角形。</td></tr><tr><td style="text-align:left">GL_TRIANGLE_STRIP</td><td style="text-align:left">绘制一系列相互连接的三角形。</td></tr><tr><td style="text-align:left">GL_TRIANGLE_FAN</td><td style="text-align:left">绘制一系列相互连接的三角形</td></tr></tbody></table><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRenderer</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] vertexPoints = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer vertexBuffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String vertextShader =</span><br><span class="line">            <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                    <span class="string">"layout (location = 0) in vec4 vPosition;\n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"     gl_Position  = vPosition;\n"</span> +</span><br><span class="line">                    <span class="string">"     gl_PointSize = 10.0;\n"</span> +</span><br><span class="line">                    <span class="string">"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 片段着色器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fragmentShader =</span><br><span class="line">            <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                    <span class="string">"precision mediump float;\n"</span> +</span><br><span class="line">                    <span class="string">"out vec4 fragColor;\n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"     fragColor = vec4(1.0,1.0,1.0,1.0);\n"</span> +</span><br><span class="line">                    <span class="string">"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分配内存空间,每个浮点型占4字节空间</span></span><br><span class="line">        vertexBuffer = ByteBuffer.allocateDirect(vertexPoints.length * <span class="number">4</span>)</span><br><span class="line">                .order(ByteOrder.nativeOrder())</span><br><span class="line">                .asFloatBuffer();</span><br><span class="line">        <span class="comment">//传入指定的坐标数据</span></span><br><span class="line">        vertexBuffer.put(vertexPoints);</span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl10, EGLConfig eglConfig)</span> </span>&#123;</span><br><span class="line">        GLES30.glClearColor(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = compileShader(GLES30.GL_VERTEX_SHADER, vertextShader);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = compileShader(GLES30.GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">        GLES30.glUseProgram(linkProgram(vertexShaderId, fragmentShaderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl10, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl10)</span> </span>&#123;</span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//准备坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">//启用顶点的句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制三个点</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_LINE_LOOP, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制直线</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_LINE_STRIP, 0, 2);</span></span><br><span class="line"><span class="comment">//        GLES30.glLineWidth(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, 0, 3);</span></span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileShader</span><span class="params">(<span class="keyword">int</span> type, String shaderCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个着色器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> shaderId = GLES30.glCreateShader(type);</span><br><span class="line">        <span class="keyword">if</span> (shaderId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//加载到着色器</span></span><br><span class="line">            GLES30.glShaderSource(shaderId, shaderCode);</span><br><span class="line">            <span class="comment">//编译着色器</span></span><br><span class="line">            GLES30.glCompileShader(shaderId);</span><br><span class="line">            <span class="comment">//检测状态</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                String logInfo = GLES30.glGetShaderInfoLog(shaderId);</span><br><span class="line">                System.err.println(logInfo);</span><br><span class="line">                <span class="comment">//创建失败</span></span><br><span class="line">                GLES30.glDeleteShader(shaderId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shaderId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linkProgram</span><span class="params">(<span class="keyword">int</span> vertexShaderId, <span class="keyword">int</span> fragmentShaderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> programId = GLES30.glCreateProgram();</span><br><span class="line">        <span class="keyword">if</span> (programId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将顶点着色器加入到程序</span></span><br><span class="line">            GLES30.glAttachShader(programId, vertexShaderId);</span><br><span class="line">            <span class="comment">//将片元着色器加入到程序中</span></span><br><span class="line">            GLES30.glAttachShader(programId, fragmentShaderId);</span><br><span class="line">            <span class="comment">//链接着色器程序</span></span><br><span class="line">            GLES30.glLinkProgram(programId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                String logInfo = GLES30.glGetProgramInfoLog(programId);</span><br><span class="line">                System.err.println(logInfo);</span><br><span class="line">                GLES30.glDeleteProgram(programId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> programId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GLSurfaceView mGLSurfaceView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setupViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mGLSurfaceView = <span class="keyword">new</span> GLSurfaceView(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mGLSurfaceView);</span><br><span class="line">        mGLSurfaceView.setEGLContextClientVersion(<span class="number">3</span>);</span><br><span class="line">        GLSurfaceView.Renderer renderer = <span class="keyword">new</span> SimpleRenderer();</span><br><span class="line">        mGLSurfaceView.setRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<br>《OpenGL ES 3.0 编程指南第2版》<br>《OpenGL ES应用开发实践指南Android卷》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始正式学习OpenGL ES开发！&lt;/p&gt;
&lt;p&gt;本博客是我在学习过程中做的记录，也希望和各位分享我的学习过程，如有错误，欢迎留言指正，共同学习。&lt;/p&gt;
&lt;h3 id=&quot;定义输入坐标&quot;&gt;&lt;a href=&quot;#定义输入坐标&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0基础概念笔记</title>
    <link href="http://yoursite.com/2019/06/24/OpenGL-ES-3-0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/06/24/OpenGL-ES-3-0基础概念/</id>
    <published>2019-06-24T02:37:06.000Z</published>
    <updated>2019-06-26T07:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。</p></blockquote><h3 id="OpenGL-渲染流程"><a href="#OpenGL-渲染流程" class="headerlink" title="OpenGL 渲染流程"></a>OpenGL 渲染流程</h3><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p><p>一个用来渲染图像的OpenGL程序需要执行的主要操作如下所示：</p><ul><li>从OpenGL的几何图元中设置数据 ，用于构建图形。</li><li>使用不同的着色器(shader)对输入的图元数据执行计算操作，判断它们的位置、颜色，以及其他渲染属性。</li><li>将输入图原点额数学描述转换为与屏幕位置相对应的像素片元(fragment)。这一步也被称为光栅化(rasterization)。</li><li>最后，针对光栅化过程产生的每个片元，执行片元着色器(fragment shader)，从而决定这个片元的最终颜色和位置。</li><li>如果有必要，还需要对每个片元执行一些额外的操作，例如判断片元对应的对象是否可见，或者将片元的颜色与当前屏幕位置的颜色进行融合。</li></ul><p>OpenGL是使用客户端 - 服务端的形式实现的，我们编写的应用程序可以看做客户端，而计算机图形硬件厂商所提供的OpenGL实现可以看做服务端。</p><h3 id="OpenGL-ES对Android平台的支持情况"><a href="#OpenGL-ES对Android平台的支持情况" class="headerlink" title="OpenGL ES对Android平台的支持情况"></a>OpenGL ES对Android平台的支持情况</h3><p>OpenGL ES当前主要版本有1.0/1.1/2.0/3.0/3.1。</p><table><thead><tr><th>OpenGL ES版本</th><th>Android版本</th><th>描述</th></tr></thead><tbody><tr><td>OpenGL ES1.0</td><td>Ａndroid 1.0+</td><td>OpenGL ES 1.x是针对固定硬件管线的，Ａndroid 1.0和更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES2.0</td><td>Android 2.2(API 8)+</td><td>OpenGL ES 2.x是针对可编程硬件管线的，不兼容OpenGL ES 1.x，Android 2.2(API 8)和更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES3.0</td><td>Android 4.3(API 18)+</td><td>向下兼容OpenGL ES 2.x，Android 4.3(API 18)及更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES3.1</td><td>Android 5.0 (API 21)+</td><td>向下兼容OpenGL ES3.0/2.0，Android 5.0（API 21）和更高的版本支持这个API规范</td></tr></tbody></table><h3 id="OpenGL-ES-3-0主要新功能有："><a href="#OpenGL-ES-3-0主要新功能有：" class="headerlink" title="OpenGL ES 3.0主要新功能有："></a>OpenGL ES 3.0主要新功能有：</h3><ul><li>1、渲染管线多重增强，实现先进视觉效果的加速，包括遮挡查询(Occlusion Query)、变缓反馈(Transform Feedback)、实例渲染(Instanced Rendering)、四个或更多渲染目标支持。</li><li>2、高质量ETC2/EAC纹理压缩格式成为一项标准功能，不同平台上不再需要需要不同的纹理集。</li><li>3、新版GLSL ES 3.0着色语言，全面支持整数和32位浮点操作。</li><li>4、纹理功能大幅增强，支持浮点纹理、3D纹理、深度纹理、顶点纹理、NPOT纹理、R/RG单双通道纹理、不可变纹理、2D阵列纹理、无二次幂限制纹理、阴影对比、调配(swizzle)、LOD与mip level clamps、无缝立方体贴图、采样对象、纹理MSAA抗锯齿渲染器。</li><li>5、一系列广泛的精确尺寸纹理和渲染缓冲格式，便携移动应用更简单。</li></ul><h3 id="OpenGL-ES-3-0图形管线图"><a href="#OpenGL-ES-3-0图形管线图" class="headerlink" title="OpenGL ES 3.0图形管线图"></a>OpenGL ES 3.0图形管线图</h3><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-1.png" alt=""></p><p>OpenGL ES 3.0实现了具有可编程着色功能的图形管线，由两个规范组成：<code>OpenGL ES 3.0 API 规范</code>和<code>OpenGL ES着色语言3.0规范(OpenGL ES SL)</code>。</p><p>图中蓝色方框代表OpenGL ES 3.0中管线的可编程阶段。</p><p>下图是一个图形渲染管线的每个阶段的抽象展示：</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-6.png" alt=""></p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器实现了顶点操作的通用可编程方法。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-2.png" alt=""></p><p>顶点着色器的输入包括：</p><ul><li><strong>着色器程序</strong>一一描述顶点上执行操作的顶点着色器程序源代码或者可执行文件。</li><li><strong>顶点着色器输入(或者属性)</strong>一一用顶点数组提供的每个顶点的数据。</li><li><strong>统一变量(uniform)</strong>一一顶点(或者片段)着色器使用的不变数据。</li><li><strong>采样器</strong>一一代表顶点着色器使用纹理的特殊统一变量类型。</li></ul><p>顶点着色器的输出在OpenGL ES 2.0中称为可变（varying）变量，但在OpenGL ES 3.0中改名为顶点着色器输出变量。</p><p>顶点着色器可以用于通过矩阵变换位置、计算照明公式来生成逐顶点颜色以及生成或者变换纹理坐标等基于顶点的传统操作。</p><p>顶点着色器取得一个位置及相关的颜色数据作为输入属性，用一个 4x4矩阵变换位置，并输出变换后的位置和颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es   <span class="comment">// OpenGL ES版本信息</span></span></span><br><span class="line">uniform mat4 u_mvpMatrix;  <span class="comment">// 同一变量u_mvpMatrix，它存储组合的模型视图和投影矩阵。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述顶点着色器的输入</span></span><br><span class="line">in vec4 a_postion; <span class="comment">// 输入顶点位置属性</span></span><br><span class="line">in vec4 a_color; <span class="comment">// 输入顶点颜色属性</span></span><br><span class="line"></span><br><span class="line">out vec4 v_color; <span class="comment">// 存储描述每个顶点颜色的顶点着色器输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">// 主函数</span></span><br><span class="line">v_color = a_color; <span class="comment">// 读入顶点属性输入a_color，并将其写入顶点输出颜色v_color</span></span><br><span class="line">gl_Position = u_mvpMatrix * a_postion <span class="comment">// gl_Position是自动生成的，将变换后的顶点位置写入gl_Position输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>图元（Primitive）是三角形、直线或者点精灵等几何对象。图元的每个顶点被发送到顶点着色器的不同拷贝。在图元装配期间，这些顶点被组合为图元。</p><p>对于每个图元，必须确定图元是否位于视椎体（屏幕上可见的3D空间区域）内。如果没有完全在视锥体内，则可能需要进行裁剪。如果图元完全处于该区域之外，它就会被抛弃。裁剪之后，顶点位置被转换为屏幕坐标。裁剪和淘汰后，将数据传给下一阶段 - 光栅化阶段。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>在此阶段绘制对应的图元（点精灵、直线或者三角形）。光栅化是将图元转化为一组二维片段的过程，然后，这些片段由<strong>片段着色器</strong>处理。这些二维片段代表着可在屏幕上绘制的像素。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-3.png" alt=""></p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器片段着色器为片段上的操作实现了通用的可编程方法。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-4.png" alt=""></p><p>对光栅化阶段生成的每个片段执行这个着色器，采用如下输入：</p><ul><li>着色器程序——描述片段上所执行操作的片段着色器程序源代码或者可执行文件。</li><li>输入变量——光姗化单元用插值为每个片段生成的顶点着色器钧出。</li><li>统一变量——片段(或者顶点)着色器使用的不变数据。</li><li>采样器——代表片段着色器所用纹理的特殊统一变量类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es <span class="comment">// OpenGL ES版本信息</span></span></span><br><span class="line">precision mediump <span class="keyword">float</span>; <span class="comment">// 设置默认的精度限定符</span></span><br><span class="line"></span><br><span class="line">in vec4 v_color; <span class="comment">// 描述片段着色器的输入</span></span><br><span class="line"></span><br><span class="line">out vec4 fragColor; <span class="comment">// 片段着色器输出变量的声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fragColor = v_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐片段操作"><a href="#逐片段操作" class="headerlink" title="逐片段操作"></a>逐片段操作</h3><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-5.png" alt=""></p><p>在这个阶段中会对一个片段进行各种测试，来决定它是否可见。如果一个片段成功通过了所有测试，那么它就会被直接绘制到帧缓存中了， 它对应的像素的颜色值会被更新，如果开启了融合模式，那么片段的颜色会与该像素当前的颜色相叠加，形成一个新的颜色值并写入帧缓存中。</p><p>参考：<br>《OpenGL编程指南第8版》<br>《OpenGL ES 3.0编程指南》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg+SDL2实现简易音视频同步播放器</title>
    <link href="http://yoursite.com/2019/05/05/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/05/FFmpeg-SDL2实现简易音视频同步播放器/</id>
    <published>2019-05-05T13:58:20.000Z</published>
    <updated>2019-05-13T15:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p><a href="https://david1840.github.io/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现音频流播放</a></p><p><a href="https://david1840.github.io/2019/05/01/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/" target="_blank" rel="noopener">FFmpeg音视频同步</a></p><p><a href="">SDL2线程操作</a></p><p>经过前面一系列的SDL2学习，终于到最后实现一个完整的简易播放器了。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p><img src="/2019/05/05/FFmpeg-SDL2实现简易音视频同步播放器/SimplePlayer.png" alt=""></p><p>这是实现的简易播放器的线程模型，通过这张图再结合我们之前博客中学习的内容，基本可以了解播放器的一个整体运行流程。具体代码也是根据这张图来实现。</p><h2 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h2><h3 id="VideoState"><a href="#VideoState" class="headerlink" title="VideoState"></a>VideoState</h3><p>整个播放器中最重要的结构体，解复用、解码、音视频同步、渲染相关参数都在该结构体中，它贯穿了整个播放流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1024</span>]; <span class="comment">// 文件名称</span></span><br><span class="line">    AVFormatContext *pFormatCtx; <span class="comment">// 上下文</span></span><br><span class="line">    <span class="keyword">int</span> videoStream, audioStream; <span class="comment">//音视频流index</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 同步相关</span></span><br><span class="line">    <span class="keyword">double</span> audio_clock;</span><br><span class="line">    <span class="keyword">double</span> frame_timer;</span><br><span class="line">    <span class="keyword">double</span> frame_last_pts;</span><br><span class="line">    <span class="keyword">double</span> frame_last_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> video_clock; </span><br><span class="line">    <span class="keyword">double</span> video_current_pts; </span><br><span class="line">    <span class="keyword">int64_t</span> video_current_pts_time;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//音频相关</span></span><br><span class="line">    AVStream *audio_st; <span class="comment">// 音频流</span></span><br><span class="line">    AVCodecContext *audio_ctx; <span class="comment">// 音频解码上下文</span></span><br><span class="line">    PacketQueue audioq; <span class="comment">// 音频队列</span></span><br><span class="line">    <span class="keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>]; <span class="comment">// 音频缓存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf_index;</span><br><span class="line">    AVFrame audio_frame; <span class="comment">// 音频帧</span></span><br><span class="line">    AVPacket audio_pkt; <span class="comment">// 音频包</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *audio_pkt_data;</span><br><span class="line">    <span class="keyword">int</span> audio_pkt_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_swr_ctx</span>;</span> <span class="comment">// 音频重采样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVStream *video_st; <span class="comment">// 视频流</span></span><br><span class="line">    AVCodecContext *video_ctx; <span class="comment">// 视频流解码上下文</span></span><br><span class="line">    PacketQueue videoq; <span class="comment">// 视频流队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE]; <span class="comment">// 解码后视频帧数组</span></span><br><span class="line">    <span class="keyword">int</span> pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex *pictq_mutex;</span><br><span class="line">    SDL_cond *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread *parse_tid; <span class="comment">// 解复用线程</span></span><br><span class="line">    SDL_Thread *video_tid;<span class="comment">// 视频解码线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> quit; <span class="comment">// 退出标记位</span></span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><h3 id="PacketQueue"><a href="#PacketQueue" class="headerlink" title="PacketQueue"></a>PacketQueue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 解复用后音视频packet保存队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">    AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span> nb_packets;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><h3 id="VideoPicture"><a href="#VideoPicture" class="headerlink" title="VideoPicture"></a>VideoPicture</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 解码后视频帧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoPicture</span> &#123;</span></span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="keyword">double</span> pts; <span class="comment">// 音视频同步后视频帧应该播放的时间</span></span><br><span class="line">&#125; VideoPicture;</span><br></pre></td></tr></table></figure><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><ol><li>初始化</li><li>创建定时器，定时视频帧的刷新</li><li>创建解复用线程</li><li>等待事件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"C:\\Users\\lenovo\\Desktop\\IMG_5950.mp4"</span>;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    VideoState *is;</span><br><span class="line">    is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SDL Window</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           <span class="number">100</span>,</span><br><span class="line">                           <span class="number">100</span>,</span><br><span class="line">                           <span class="number">640</span>, <span class="number">480</span>,</span><br><span class="line">                           SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span> (!win) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL_CreateWindow error，exit！"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    text_mutex = SDL_CreateMutex();</span><br><span class="line">    </span><br><span class="line">    strlcpy(is-&gt;filename, file, <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时刷新器，主要用来控制视频的刷新</span></span><br><span class="line">    schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建解复用线程</span></span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class="string">"demux_thread"</span>, is);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;parse_tid) &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 等待SDL事件，否则阻塞</span></span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT: <span class="comment">// 退出</span></span><br><span class="line">                is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">goto</span> Destroy;</span><br><span class="line">            <span class="keyword">case</span> SDL_KEYDOWN:<span class="comment">// ESC退出</span></span><br><span class="line">                <span class="keyword">if</span> (event.key.keysym.sym == SDLK_ESCAPE) &#123;</span><br><span class="line">                    is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">goto</span> Destroy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_REFRESH_EVENT: <span class="comment">// 定时器刷新事件</span></span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    Destroy:</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解复用"><a href="#解复用" class="headerlink" title="解复用"></a>解复用</h3><ol><li>打开文件</li><li>找到音视频流</li><li>打开音频、视频流，创建视频解码线程，准备解码</li><li>读取packet，将音视频packet分别放入队列中，等待解码线程取出</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demux_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((err_code = avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first video stream</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">            video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            video_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">            audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            audio_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开音频流，创建解码器，配置参数</span></span><br><span class="line">    <span class="keyword">if</span> (audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开视频流，创建解码器，创建解码线程</span></span><br><span class="line">    <span class="keyword">if</span> (video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, video_index);</span><br><span class="line">        <span class="comment">// video_tid = SDL_CreateThread(decode_video_thread, "decode_video_thread", is);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将packet存入队列中</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_packet_unref(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h3><ol><li>从队列中取出视频packet</li><li>解码，同步</li><li>加码后Frame存入数组，等待视频渲染</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 视频解码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *) arg;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从视频队列中取出packet</span></span><br><span class="line">        <span class="keyword">if</span> (packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        avcodec_send_packet(is-&gt;video_ctx, packet);</span><br><span class="line">        <span class="keyword">while</span> (avcodec_receive_frame(is-&gt;video_ctx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pts = pFrame-&gt;best_effort_timestamp) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pts = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            <span class="keyword">if</span> (queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            av_packet_unref(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频解码"><a href="#音频解码" class="headerlink" title="音频解码"></a>音频解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 音频设备回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audio_callback</span><span class="params">(<span class="keyword">void</span> *userdata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    <span class="keyword">int</span> len1, audio_size;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            <span class="comment">// 音频解码</span></span><br><span class="line">            audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">            <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 音频解码错误，播放静音</span></span><br><span class="line">                is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        <span class="comment">// 混音播放</span></span><br><span class="line">        SDL_MixAudio(stream, (<span class="keyword">uint8_t</span> *) is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频刷新播放"><a href="#视频刷新播放" class="headerlink" title="视频刷新播放"></a>视频刷新播放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 视频刷新播放，并预测下一帧的播放时间，设置新的定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">            schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从数组中取出一帧视频帧</span></span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line">            <span class="comment">// 当前Frame时间减去上一帧的时间，获取两帧间的时差</span></span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="comment">// 延时小于0或大于1秒（太长）都是错误的，将延时时间设置为上一次的延时时间</span></span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存延时和PTS，等待下次使用</span></span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取音频Audio_Clock</span></span><br><span class="line">            ref_clock = get_audio_clock(is);</span><br><span class="line">            <span class="comment">// 得到当前PTS和Audio_Clock的差值</span></span><br><span class="line">            diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AV_SYNC_THRESHOLD 最小刷新时间</span></span><br><span class="line">            sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">            <span class="comment">// diff小于非同步阈值，可以进行同步</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123;</span><br><span class="line">                    <span class="comment">// 视频时间在音频时间之前，应该让视频尽快播放</span></span><br><span class="line">                    delay = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123;</span><br><span class="line">                     <span class="comment">// 视频时间在音频时间之后，应该让视频延迟播放</span></span><br><span class="line">                    delay = <span class="number">2</span> * delay;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="comment">// 最终真正要延时的时间</span></span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">            <span class="keyword">if</span> (actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">                <span class="comment">// 延时时间过小就设置最小值</span></span><br><span class="line">                actual_delay = <span class="number">0.010</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据延时时间重新设置定时器，刷新视频</span></span><br><span class="line">            schedule_refresh(is, (<span class="keyword">int</span>) (actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视频帧显示</span></span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新视频帧数组下标</span></span><br><span class="line">            <span class="keyword">if</span> (++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">                is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            <span class="comment">// 视频帧数组减一</span></span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体的流程就是这样了，相比之前的Demo复杂度会高不少，但是所有的知识在前面的博客中都有涉及，在博客中也讲不了什么东西，还是直接自己运行，再去看代码会更好，理清流程，整个播放器的代码也不会很难看懂，这里附上<a href="https://github.com/David1840/SimplePlayer/blob/master/SimplePlayer.c" target="_blank" rel="noopener">源码 Github-SimplePlay</a></p><p>学习音视频推荐：</p><p>第一个当然推荐雷神雷霄骅，中国FFmpeg第一人，系统地整理了FFmpeg相关的知识点，入门必看，可惜早逝，缅怀雷神。<a href="https://me.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅的博客</a></p><p>第二个推荐大神李超的<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">慕课网视频</a>，讲得非常实用，音视频小白入门值得一看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2线程操作</title>
    <link href="http://yoursite.com/2019/05/03/SDL2%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/03/SDL2线程操作/</id>
    <published>2019-05-03T01:19:14.000Z</published>
    <updated>2019-05-13T15:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p><a href="https://david1840.github.io/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现音频流播放</a></p><p><a href="https://david1840.github.io/2019/05/01/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/" target="_blank" rel="noopener">FFmpeg音视频同步</a></p><p>今天一起了解下在SDL2中多线程的使用。</p><p>下面是SDL2中多线程相关的API。可以发现实际上SDL2中的多线程操作也只是提供了统一的接口，没有做其他操作。</p><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Thread* <span class="title">SDL_CreateThread</span><span class="params">(SDL_ThreadFunction fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> <span class="comment">// fn: 线程要运行的函数。</span></span></span><br><span class="line"><span class="function"> <span class="comment">// name: 线程名。</span></span></span><br><span class="line"><span class="function"> <span class="comment">// data: 函数参数。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 回调函数    </span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(SDLCALL * SDL_ThreadFunction)</span> <span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a>等待线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_WaitThread</span><span class="params">(SDL_Thread* thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span>* status)</span></span></span><br><span class="line"><span class="function"><span class="comment">//等待线程结束</span></span></span><br></pre></td></tr></table></figure><h5 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_mutex* <span class="title">SDL_CreateMutex</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><h5 id="销毁互斥量"><a href="#销毁互斥量" class="headerlink" title="销毁互斥量"></a>销毁互斥量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_LockMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UnlockMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="信号量创建-销毁"><a href="#信号量创建-销毁" class="headerlink" title="信号量创建/销毁"></a>信号量创建/销毁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_cond * <span class="title">SDL_CreateCond</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyCond</span><span class="params">(SDL_cond * cond)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="信号量等待-通知"><a href="#信号量等待-通知" class="headerlink" title="信号量等待 / 通知"></a>信号量等待 / 通知</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_CondWait</span><span class="params">(SDL_cond * cond, SDL_mutex * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_CondSignal</span><span class="params">(SDL_cond * cond)</span></span>;</span><br></pre></td></tr></table></figure><p>SDL2中的多线程其实并没有什么可以讲的，和我们用其他语言做多线程处理没有区别，在这里熟悉下API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg音视频同步</title>
    <link href="http://yoursite.com/2019/05/01/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/"/>
    <id>http://yoursite.com/2019/05/01/FFmpeg音视频同步/</id>
    <published>2019-05-01T07:44:16.000Z</published>
    <updated>2019-05-07T10:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p><a href="https://david1840.github.io/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现音频流播放</a></p><p>前两篇文章分别做了音频和视频的播放，要实现一个完整的简易播放器就必须要做到音视频同步播放了，而音视频同步在音视频开发中又是非常重要的知识点，所以在这里记录下音视频同步相关知识的理解。</p><h3 id="音视频同步简介"><a href="#音视频同步简介" class="headerlink" title="音视频同步简介"></a>音视频同步简介</h3><p>从前面的学习可以知道，在一个视频文件中，音频和视频都是单独以一条流的形式存在，互不干扰。那么在播放时根据视频的帧率（Frame Rate）和音频的采样率（Sample Rate）通过简单的计算得到其在某一Frame（Sample）的播放时间分别播放，<strong><u>理论</u></strong>上应该是同步的。但是由于机器运行速度，解码效率等等因素影响，很有可能出现音频和视频不同步，例如出现视频中人在说话，却只能看到人物嘴动却没有声音，非常影响用户观看体验。</p><p>如何做到音视频同步？要知道音视频同步是一个动态的过程，同步是暂时的，不同步才是常态，需要一种随着时间会线性增长的量，视频和音频的播放速度都以该量为标准，播放快了就减慢播放速度；播放慢了就加快播放的速度，在你追我赶中达到同步的状态。目前主要有三种方式实现同步：</p><ul><li><strong>将视频和音频同步外部的时钟上</strong>，选择一个外部时钟为基准，视频和音频的播放速度都以该时钟为标准。</li><li><strong>将音频同步到视频上</strong>，就是以视频的播放速度为基准来同步音频。</li><li><strong>将视频同步到音频上</strong>，就是以音频的播放速度为基准来同步视频。</li></ul><p>比较主流的是第三种，将视频同步到音频上。至于为什么不使用前两种，因为一般来说，人对于声音的敏感度更高，如果频繁地去调整音频会产生杂音让人感觉到刺耳不舒服，而人对图像的敏感度就低很多了，所以一般都会采用第三种方式。</p><h3 id="复习DTS、PTS和时间基"><a href="#复习DTS、PTS和时间基" class="headerlink" title="复习DTS、PTS和时间基"></a>复习DTS、PTS和时间基</h3><ul><li>PTS: Presentation  Time Stamp，显示渲染用的时间戳，告诉我们什么时候需要显示</li><li>DTS: Decode Time Stamp，视频解码时的时间戳，告诉我们什么时候需要解码</li></ul><p>在音频中PTS和DTS一般相同。但是在视频中，由于B帧的存在，PTS和DTS可能会不同。</p><blockquote><p>实际帧顺序：I B B P</p><p>存放帧顺序：I P B B</p><p>解码时间戳：1 4 2 3</p><p>展示时间戳：1 2 3 4</p></blockquote><ul><li>时间基</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment"> * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment"> * 这是表示帧时间戳的基本时间单位(以秒为单位)。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>时间基是一个分数，以秒为单位，比如1/50秒，那它到底表示的是什么意思呢？以帧率为例，如果它的时间基是1/50秒，那么就表示每隔1/50秒显示一帧数据，也就是每1秒显示50帧，帧率为50FPS。</p><p>每一帧数据都有对应的PTS，在播放视频或音频的时候我们需要将PTS时间戳转化为以秒为单位的时间，用来最后的展示。那如何计算一桢在整个视频中的时间位置？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算一桢在整个视频中的时间位置</span></span><br><span class="line">timestamp(秒) = pts * av_q2d(st-&gt;time_base);</span><br></pre></td></tr></table></figure><h3 id="Audio-Clock"><a href="#Audio-Clock" class="headerlink" title="Audio_Clock"></a>Audio_Clock</h3><p>Audio_Clock，也就是Audio的播放时长，从开始到当前的时间。获取Audio_Clock：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (pkt-&gt;pts != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    state-&gt;audio_clock = av_q2d(state-&gt;audio_st-&gt;time_base) * pkt-&gt;pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还没有结束，由于一个packet中可以包含多个Frame帧，packet中的PTS比真正的播放的PTS可能会早很多，可以根据Sample Rate 和 Sample Format来计算出该packet中的数据可以播放的时长，再次更新Audio_Clock。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 每秒钟音频播放的字节数 采样率 * 通道数 * 采样位数 (一个sample占用的字节数)</span></span><br><span class="line">n = <span class="number">2</span> * state-&gt;audio_ctx-&gt;channels;</span><br><span class="line">state-&gt;audio_clock += (<span class="keyword">double</span>) data_size /</span><br><span class="line">                   (<span class="keyword">double</span>) (n * state-&gt;audio_ctx-&gt;sample_rate);</span><br></pre></td></tr></table></figure><p> 最后还有一步，在我们获取这个Audio_Clock时，很有可能音频缓冲区还有没有播放结束的数据，也就是有一部分数据实际还没有播放，所以就要在Audio_Clock上减去这部分数据的播放时间，才是真正的Audio_Clock。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">get_audio_clock</span><span class="params">(VideoState *state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line">    <span class="keyword">int</span> buf_size, bytes_per_sec;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//上一步获取的PTS</span></span><br><span class="line">    pts = state-&gt;audio_clock;</span><br><span class="line">    <span class="comment">// 音频缓冲区还没有播放的数据</span></span><br><span class="line">    buf_size = state-&gt;audio_buf_size - state-&gt;audio_buf_index; </span><br><span class="line">    <span class="comment">// 每秒钟音频播放的字节数</span></span><br><span class="line">    bytes_per_sec = state-&gt;audio_ctx-&gt;sample_rate * state-&gt;audio_ctx-&gt;channels * <span class="number">2</span>;</span><br><span class="line">    pts -= (<span class="keyword">double</span>) buf_size / bytes_per_sec;</span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>get_audio_clock</code>中返回的才是我们最终需要的Audio_Clock，当前的音频的播放时长。</p><h3 id="Video-Clock"><a href="#Video-Clock" class="headerlink" title="Video_Clock"></a>Video_Clock</h3><p>Video_Clock，视频播放到当前帧时的已播放的时间长度。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">avcodec_send_packet(state-&gt;video_ctx, packet);</span><br><span class="line"><span class="keyword">while</span> (avcodec_receive_frame(state-&gt;video_ctx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((pts = pFrame-&gt;best_effort_timestamp) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pts = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    pts *= av_q2d(state-&gt;video_st-&gt;time_base); <span class="comment">// 时间基换算，单位为秒</span></span><br><span class="line"></span><br><span class="line">    pts = synchronize_video(state, pFrame, pts);</span><br><span class="line">    </span><br><span class="line">    av_packet_unref(packet);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>旧版的FFmpeg使用<code>av_frame_get_best_effort_timestamp</code>函数获取视频的最合适PTS，新版本的则在解码时生成了<code>best_effort_timestamp</code>。但是依然可能会获取不到正确的PTS，所以在<code>synchronize_video</code>中进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">synchronize_video</span><span class="params">(VideoState *state, AVFrame *src_frame, <span class="keyword">double</span> pts)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> frame_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pts != <span class="number">0</span>) &#123;</span><br><span class="line">        state-&gt;video_clock = pts;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        pts = state-&gt;video_clock;<span class="comment">// PTS错误，使用上一次的PTS值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据时间基，计算每一帧的间隔时间</span></span><br><span class="line">    frame_delay = av_q2d(state-&gt;video_ctx-&gt;time_base);</span><br><span class="line">    <span class="comment">//解码后的帧要延时的时间</span></span><br><span class="line">    frame_delay += src_frame-&gt;repeat_pict * (frame_delay * <span class="number">0.5</span>);</span><br><span class="line">    state-&gt;video_clock += frame_delay;<span class="comment">//得到video_clock,实际上也是预测的下一帧视频的时间</span></span><br><span class="line">    <span class="keyword">return</span> pts;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>上面两步获得了Audio_Clock和Video_Clock，这样我们就有了视频流中Frame的显示时间，并且得到了作为基准时间的音频播放时长Audio clock ，可以将视频同步到音频了。</p><ol><li>用当前帧的PTS - 上一播放帧的PTS得到一个延迟时间</li><li>用当前帧的PTS和Audio_Clock进行比较，来判断视频的播放速度是快了还是慢了</li><li>根据2的结果，设置播放下一帧的延迟时间</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_SYNC_THRESHOLD 0.01 <span class="comment">// 同步最小阈值</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AV_NOSYNC_THRESHOLD 10.0 <span class="comment">//  不同步阈值</span></span></span><br><span class="line"><span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前Frame时间减去上一帧的时间，获取两帧间的延时</span></span><br><span class="line">delay = vp-&gt;pts - is-&gt;frame_last_pts;</span><br><span class="line"><span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123; </span><br><span class="line">    <span class="comment">// 延时小于0或大于1秒（太长）都是错误的，将延时时间设置为上一次的延时时间</span></span><br><span class="line">    delay = is-&gt;frame_last_delay;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取音频Audio_Clock</span></span><br><span class="line">ref_clock = get_audio_clock(is);</span><br><span class="line"><span class="comment">// 得到当前PTS和Audio_Clock的差值</span></span><br><span class="line">diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调整播放下一帧的延迟时间，以实现同步</span></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">    <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123; <span class="comment">// 慢了，delay设为0</span></span><br><span class="line">        delay = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123; <span class="comment">// 快了，加倍delay</span></span><br><span class="line">        delay = <span class="number">2</span> * delay;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line">is-&gt;frame_timer += delay;</span><br><span class="line"><span class="comment">// 最终真正要延时的时间</span></span><br><span class="line">actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line"><span class="keyword">if</span> (actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">    <span class="comment">// 延时时间过小就设置个最小值</span></span><br><span class="line">    actual_delay = <span class="number">0.010</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据延时时间刷新视频</span></span><br><span class="line">schedule_refresh(is, (<span class="keyword">int</span>) (actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br></pre></td></tr></table></figure><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>将视频同步到音频上实现音视频同步基本完成，总体就是动态的过程快了就等待，慢了就加速，在一个你追我赶的状态下实现同步播放。</p><p>后面的博客会真正实现一个音视频同步的播放器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg+SDL2实现音频流播放</title>
    <link href="http://yoursite.com/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2019/04/26/FFmpeg-SDL2实现音频流播放/</id>
    <published>2019-04-26T06:54:38.000Z</published>
    <updated>2019-04-26T07:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2 PCM音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p>之前完成了PCM音频的播放，这次实现的是FFmpeg+SDL2播放任意视频中的音频流。</p><p>整体的流程和视频流播放类似，需要了解下的就是 <strong>SwrContext 重采样结构体</strong></p><p>重采样结构体,就是改变音频的采样率、sample format、声道数等参数，使之按照我们期望的参数输出,当然是原有的音频参数不满足我们的需求，比如在FFMPEG解码音频的时候，不同的音源有不同的格式，采样率等，在解码后的数据中的这些参数也会不一致，如果我们接下来需要使用解码后的音频数据做其他操作，而这些参数的不一致导致会有很多额外工作，此时直接对其进行重采样，获取我们制定的音频参数，这样就会方便很多。</p><p>通过重采样，我们可以对 sample rate(采样率)、sample format(采样格式)、channel layout(通道布局，可以通过此参数获取声道数)进行调节。</p><h3 id="SwrContext常用函数"><a href="#SwrContext常用函数" class="headerlink" title="SwrContext常用函数"></a>SwrContext常用函数</h3><h4 id="swr-alloc"><a href="#swr-alloc" class="headerlink" title="swr_alloc"></a>swr_alloc</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 用于申请一个SwrContext结构体</span></span><br><span class="line"><span class="function">struct SwrContext *<span class="title">swr_alloc</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="swr-init"><a href="#swr-init" class="headerlink" title="swr_init"></a>swr_init</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当设置好相关的参数后，使用此函数来初始化SwrContext结构体</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_init</span><span class="params">(struct SwrContext *s)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="swr-alloc-set-opts"><a href="#swr-alloc-set-opts" class="headerlink" title="swr_alloc_set_opts"></a>swr_alloc_set_opts</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配SwrContext并设置/重置常用的参数。参数包含了输入输出参数中sample rate(采样率)、sample format(采样格式)、channel layout等参数</span></span><br><span class="line">函数原型：<span class="function">struct SwrContext *<span class="title">swr_alloc_set_opts</span><span class="params">(struct SwrContext *s,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span> out_ch_layout,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">enum</span> AVSampleFormat out_sample_fmt, </span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> out_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int64_t</span>  in_ch_layout, </span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">enum</span> AVSampleFormat  in_sample_fmt, </span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span>  in_sample_rate,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">int</span> log_offset, </span></span></span><br><span class="line"><span class="function"><span class="params">                                      <span class="keyword">void</span> *log_ctx)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="swr-convert"><a href="#swr-convert" class="headerlink" title="swr_convert"></a>swr_convert</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将输入的音频按照定义的参数进行转换，并输出</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">swr_convert</span><span class="params">(struct SwrContext *s, <span class="keyword">uint8_t</span> **out, <span class="keyword">int</span> out_count,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">uint8_t</span> **in , <span class="keyword">int</span> in_count)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="swr-free"><a href="#swr-free" class="headerlink" title="swr_free"></a>swr_free</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放掉SwrContext结构体并将此结构体置为NULL;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swr_free</span><span class="params">(struct SwrContext **s)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Created by 刘伟 on 2019/4/26.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"libswresample/swresample.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_chunk;</span><br><span class="line"><span class="keyword">static</span> Uint32 audio_len;</span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_pos;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_AUDIO_FRAME_SIZE 19200</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//音频设备需要更多数据的时候会调用该回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_audio_data</span><span class="params">(<span class="keyword">void</span> *udata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//首先使用SDL_memset()将stream中的数据设置为0</span></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (audio_len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    len = (len &gt; audio_len ? audio_len : len);</span><br><span class="line"></span><br><span class="line">    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line">    audio_pos += len;</span><br><span class="line">    audio_len -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"C:\\Users\\lenovo\\Desktop\\1080p.mov"</span>;</span><br><span class="line"></span><br><span class="line">    AVFormatContext *pFormatCtx = <span class="literal">NULL</span>; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, audioStream = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    AVCodecParameters *pCodecParameters = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodecContext *pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVCodec *pCodec = <span class="literal">NULL</span>; </span><br><span class="line">    AVFrame *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket *packet;</span><br><span class="line">    <span class="keyword">uint8_t</span> *out_buffer;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int64_t</span> in_channel_layout;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">au_convert_ctx</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, file, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to open video file!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Couldn't open file</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    audioStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (audioStream == <span class="number">-1</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Din't find a video stream!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// Didn't find a video stream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 音频流参数</span></span><br><span class="line">    pCodecParameters = pFormatCtx-&gt;streams[audioStream]-&gt;codecpar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取解码器</span></span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecParameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Codec not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Copy context</span></span><br><span class="line">    pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_to_context(pCodecCtx, pCodecParameters) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Couldn't copy codec context"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">// Error copying codec context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Open codec</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to open decoder!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// Could not open codec</span></span><br><span class="line">    &#125;</span><br><span class="line">    packet = (AVPacket *) av_malloc(<span class="keyword">sizeof</span>(AVPacket));</span><br><span class="line">    av_init_packet(packet);</span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">uint64_t</span> out_channel_layout = AV_CH_LAYOUT_STEREO;<span class="comment">//输出声道</span></span><br><span class="line">    <span class="keyword">int</span> out_nb_samples = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">enum</span> AVSampleFormat out_sample_fmt = AV_SAMPLE_FMT_S16;<span class="comment">//输出格式S16</span></span><br><span class="line">    <span class="keyword">int</span> out_sample_rate = <span class="number">44100</span>;</span><br><span class="line">    <span class="keyword">int</span> out_channels = av_get_channel_layout_nb_channels(out_channel_layout);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> out_buffer_size = av_samples_get_buffer_size(<span class="literal">NULL</span>, out_channels, out_nb_samples, out_sample_fmt, <span class="number">1</span>);</span><br><span class="line">    out_buffer = (<span class="keyword">uint8_t</span> *) av_malloc(MAX_AUDIO_FRAME_SIZE * <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//Init</span></span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line">    spec.freq = out_sample_rate;</span><br><span class="line">    spec.format = AUDIO_S16SYS;</span><br><span class="line">    spec.channels = out_channels;</span><br><span class="line">    spec.silence = <span class="number">0</span>;</span><br><span class="line">    spec.samples = out_nb_samples;</span><br><span class="line">    spec.callback = read_audio_data;</span><br><span class="line">    spec.userdata = pCodecCtx;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDL_OpenAudio(&amp;spec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open audio.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    in_channel_layout = av_get_default_channel_layout(pCodecCtx-&gt;channels);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"in_channel_layout ---&gt;%d\n"</span>, in_channel_layout);</span><br><span class="line">    au_convert_ctx = swr_alloc();</span><br><span class="line">    au_convert_ctx = swr_alloc_set_opts(au_convert_ctx, out_channel_layout, out_sample_fmt, out_sample_rate,in_channel_layout, pCodecCtx-&gt;sample_fmt, pCodecCtx-&gt;sample_rate, <span class="number">0</span>, <span class="literal">NULL</span>);</span><br><span class="line">    swr_init(au_convert_ctx);</span><br><span class="line"></span><br><span class="line">    SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == audioStream) &#123;</span><br><span class="line">            avcodec_send_packet(pCodecCtx, packet);</span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(pCodecCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">                swr_convert(au_convert_ctx, &amp;out_buffer, MAX_AUDIO_FRAME_SIZE, (<span class="keyword">const</span> <span class="keyword">uint8_t</span> **) pFrame-&gt;data,pFrame-&gt;nb_samples); <span class="comment">// 转换音频</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            audio_chunk = (Uint8 *) out_buffer;</span><br><span class="line">            audio_len = out_buffer_size;</span><br><span class="line">            audio_pos = audio_chunk;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (audio_len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">1</span>);<span class="comment">//延迟播放</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(packet);</span><br><span class="line">    &#125;</span><br><span class="line">    swr_free(&amp;au_convert_ctx);</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码请查看<a href="https://github.com/David1840/SimplePlayer/blob/master/audio_player.c" target="_blank" rel="noopener">源码 GitHub-SimplePlayer-audio_player</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg+SDL2实现视频流播放</title>
    <link href="http://yoursite.com/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2019/04/22/FFmpeg-SDL2实现视频流播放/</id>
    <published>2019-04-22T07:47:51.000Z</published>
    <updated>2019-04-26T07:29:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p>本篇博客使用FFmpeg+SDL2完成播放视频流Demo（仅播放视频），所有相关知识在之前的博客中都有提到，稍作整理完成。</p><h3 id="流程图："><a href="#流程图：" class="headerlink" title="流程图："></a>流程图：</h3><p>FFmpeg解码视频流：</p><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/FFmpeg.png" alt=""></p><p>SDL2显示YUV数据：</p><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/SDL2.png" alt=""></p><p>### </p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavcodec/avcodec.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libswscale/swscale.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"C:\\Users\\lenovo\\Desktop\\fengjing.mp4"</span>;</span><br><span class="line">    </span><br><span class="line">    AVFormatContext *pFormatCtx = <span class="literal">NULL</span>; </span><br><span class="line">    <span class="keyword">int</span> i, videoStream;</span><br><span class="line">    AVCodecParameters *pCodecParameters = <span class="literal">NULL</span>; </span><br><span class="line">    AVCodecContext *pCodecCtx = <span class="literal">NULL</span>;</span><br><span class="line">    AVCodec *pCodec = <span class="literal">NULL</span>;</span><br><span class="line">    AVFrame *pFrame = <span class="literal">NULL</span>;</span><br><span class="line">    AVPacket packet;</span><br><span class="line"></span><br><span class="line">    SDL_Rect rect;</span><br><span class="line">    Uint32 pixformat;</span><br><span class="line">    SDL_Window *win = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture *texture = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//默认窗口大小</span></span><br><span class="line">    <span class="keyword">int</span> w_width = <span class="number">640</span>;</span><br><span class="line">    <span class="keyword">int</span> w_height = <span class="number">480</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//SDL初始化</span></span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开输入文件</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;pFormatCtx, file, <span class="literal">NULL</span>, <span class="literal">NULL</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Couldn't open  video file!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//找到视频流</span></span><br><span class="line">    videoStream = av_find_best_stream(pFormatCtx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (videoStream == <span class="number">-1</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Din't find a video stream!"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;<span class="comment">// Didn't find a video stream</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 流参数</span></span><br><span class="line">    pCodecParameters = pFormatCtx-&gt;streams[videoStream]-&gt;codecpar;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取解码器</span></span><br><span class="line">    pCodec = avcodec_find_decoder(pCodecParameters-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (pCodec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Unsupported codec!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; <span class="comment">// Codec not found</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化一个编解码上下文</span></span><br><span class="line">    pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (avcodec_parameters_to_context(pCodecCtx, pCodecParameters) != <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Couldn't copy codec context"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;<span class="comment">// Error copying codec context</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开解码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to open decoder!\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL; <span class="comment">// Could not open codec</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Allocate video frame</span></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    w_width = pCodecCtx-&gt;width;</span><br><span class="line">    w_height = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建窗口</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                           w_width, w_height,</span><br><span class="line">                           SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span> (!win) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to create window by SDL"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建渲染器</span></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        SDL_LogError(SDL_LOG_CATEGORY_APPLICATION, <span class="string">"Failed to create Renderer by SDL"</span>);</span><br><span class="line">        <span class="keyword">goto</span> __FAIL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pixformat = SDL_PIXELFORMAT_IYUV;<span class="comment">//YUV格式</span></span><br><span class="line">    <span class="comment">// 创建纹理</span></span><br><span class="line">    texture = SDL_CreateTexture(renderer,</span><br><span class="line">                                pixformat,</span><br><span class="line">                                SDL_TEXTUREACCESS_STREAMING,</span><br><span class="line">                                w_width,</span><br><span class="line">                                w_height);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(pFormatCtx, &amp;packet) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class="line">            <span class="comment">//解码</span></span><br><span class="line">            avcodec_send_packet(pCodecCtx, &amp;packet);</span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(pCodecCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>,</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">0</span>], pFrame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">1</span>], pFrame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">2</span>], pFrame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set Size of Window</span></span><br><span class="line">                rect.x = <span class="number">0</span>;</span><br><span class="line">                rect.y = <span class="number">0</span>;</span><br><span class="line">                rect.w = pCodecCtx-&gt;width;</span><br><span class="line">                rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//展示</span></span><br><span class="line">                SDL_RenderClear(renderer);</span><br><span class="line">                SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">                SDL_RenderPresent(renderer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 事件处理</span></span><br><span class="line">        SDL_Event event;</span><br><span class="line">        SDL_PollEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                <span class="keyword">goto</span> __QUIT;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    __QUIT:</span><br><span class="line">    ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    __FAIL:</span><br><span class="line">    <span class="comment">// Free the YUV frame</span></span><br><span class="line">    <span class="keyword">if</span> (pFrame) &#123;</span><br><span class="line">        av_frame_free(&amp;pFrame);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the codec</span></span><br><span class="line">    <span class="keyword">if</span> (pCodecCtx) &#123;</span><br><span class="line">        avcodec_close(pCodecCtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pCodecParameters) &#123;</span><br><span class="line">        avcodec_parameters_free(&amp;pCodecParameters);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Close the video file</span></span><br><span class="line">    <span class="keyword">if</span> (pFormatCtx) &#123;</span><br><span class="line">        avformat_close_input(&amp;pFormatCtx);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (win) &#123;</span><br><span class="line">        SDL_DestroyWindow(win);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (renderer) &#123;</span><br><span class="line">        SDL_DestroyRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (texture) &#123;</span><br><span class="line">        SDL_DestroyTexture(texture);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/22/FFmpeg-SDL2实现视频流播放/1.png" alt=""></p><p>这个Demo目前只是通过一个while循环将视频播放出来，所以可以播放视频但是速度不正常，并且没有声音，这些问题会在后面一一解决，最后完成一个简易的播放器。</p><p><a href="https://github.com/David1840/SimplePlayer" target="_blank" rel="noopener">源码 GitHub-SimplePlayer</a></p><p>====== 更新 2019-04-25，线程操作，使画面显示40ms一帧 ======</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> REFRESH_EVENT  (SDL_USEREVENT + 1) <span class="comment">//刷新事件</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BREAK_EVENT  (SDL_USEREVENT + 2) <span class="comment">// 退出事件</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> thread_exit = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> thread_pause = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程每40ms刷新一次</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">video_refresh_thread</span><span class="params">(<span class="keyword">void</span> *data)</span> </span>&#123;</span><br><span class="line">    thread_exit = <span class="number">0</span>;</span><br><span class="line">    thread_pause = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!thread_exit) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!thread_pause) &#123;</span><br><span class="line">            SDL_Event event;</span><br><span class="line">            event.type = REFRESH_EVENT;</span><br><span class="line">            SDL_PushEvent(&amp;event);<span class="comment">// 发送刷新事件</span></span><br><span class="line">        &#125;</span><br><span class="line">        SDL_Delay(<span class="number">40</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    thread_exit = <span class="number">0</span>;</span><br><span class="line">    thread_pause = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//Break</span></span><br><span class="line">    SDL_Event event;</span><br><span class="line">    event.type = BREAK_EVENT;</span><br><span class="line">    SDL_PushEvent(&amp;event);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建线程</span></span><br><span class="line">SDL_CreateThread(video_refresh_thread, <span class="string">"Video Thread"</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    SDL_WaitEvent(&amp;event);<span class="comment">//使用时间驱动，每40ms执行一次</span></span><br><span class="line">    <span class="keyword">if</span> (event.type == REFRESH_EVENT) &#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (av_read_frame(pFormatCtx, &amp;packet) &lt; <span class="number">0</span>) </span><br><span class="line">                thread_exit = <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">            <span class="keyword">if</span> (packet.stream_index == videoStream)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (packet.stream_index == videoStream) &#123;</span><br><span class="line">            avcodec_send_packet(pCodecCtx, &amp;packet);</span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(pCodecCtx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">                SDL_UpdateYUVTexture(texture, <span class="literal">NULL</span>,</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">0</span>], pFrame-&gt;linesize[<span class="number">0</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">1</span>], pFrame-&gt;linesize[<span class="number">1</span>],</span><br><span class="line">                                     pFrame-&gt;data[<span class="number">2</span>], pFrame-&gt;linesize[<span class="number">2</span>]);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Set Size of Window</span></span><br><span class="line">                rect.x = <span class="number">0</span>;</span><br><span class="line">                rect.y = <span class="number">0</span>;</span><br><span class="line">                rect.w = pCodecCtx-&gt;width;</span><br><span class="line">                rect.h = pCodecCtx-&gt;height;</span><br><span class="line"></span><br><span class="line">                SDL_RenderClear(renderer);</span><br><span class="line">                SDL_RenderCopy(renderer, texture, <span class="literal">NULL</span>, &amp;rect);</span><br><span class="line">                SDL_RenderPresent(renderer);</span><br><span class="line">            &#125;</span><br><span class="line">            av_packet_unref(&amp;packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_KEYDOWN) &#123;</span><br><span class="line">        <span class="keyword">if</span> (event.key.keysym.sym == SDLK_SPACE) &#123; <span class="comment">//空格键暂停</span></span><br><span class="line">            thread_pause = !thread_pause;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (event.key.keysym.sym== SDLK_ESCAPE)&#123; <span class="comment">// ESC键退出</span></span><br><span class="line">            thread_exit = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == SDL_QUIT) &#123;</span><br><span class="line">        thread_exit = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (event.type == BREAK_EVENT) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2 PCM音频播放</title>
    <link href="http://yoursite.com/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/"/>
    <id>http://yoursite.com/2019/04/19/SDL2音频播放/</id>
    <published>2019-04-19T01:47:03.000Z</published>
    <updated>2019-04-26T07:28:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p>本来计划写FFmpeg+SDL2视频播放，但是发现要说的内容有点多，所以还是先从简单的音频数据播放开始，一步一步来。</p><h3 id="打开音频设备"><a href="#打开音频设备" class="headerlink" title="打开音频设备"></a>打开音频设备</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> SDLCALL <span class="title">SDL_OpenAudio</span><span class="params">(SDL_AudioSpec * desired,</span></span></span><br><span class="line"><span class="function"><span class="params">                          SDL_AudioSpec * obtained)</span></span>;</span><br><span class="line"><span class="comment">// desired：期望的参数。</span></span><br><span class="line"><span class="comment">// obtained：实际音频设备的参数，一般情况下设置为NULL即可。</span></span><br></pre></td></tr></table></figure><h4 id="SDL-AudioSpec"><a href="#SDL-AudioSpec" class="headerlink" title="SDL_AudioSpec"></a>SDL_AudioSpec</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这个结构体中包含了音频的各种参数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SDL_AudioSpec</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> freq;                   <span class="comment">/**&lt; 音频采样率*/</span></span><br><span class="line">    SDL_AudioFormat format;     <span class="comment">/**&lt; 音频数据格式 */</span></span><br><span class="line">    Uint8 channels;             <span class="comment">/**&lt; 声道数: 1 单声道, 2 立体声 */</span></span><br><span class="line">    Uint8 silence;              <span class="comment">/**&lt; 设置静音的值*/</span></span><br><span class="line">    Uint16 samples;             <span class="comment">/**&lt; 音频缓冲区中的采样个数，要求必须是2的n次*/</span></span><br><span class="line">    Uint16 padding;             <span class="comment">/**&lt; 考虑到兼容性的一个参数*/</span></span><br><span class="line">    Uint32 size;                <span class="comment">/**&lt; 音频缓冲区的大小，以字节为单位*/</span></span><br><span class="line">    SDL_AudioCallback callback; <span class="comment">/**&lt; 填充音频缓冲区的回调函数 */</span></span><br><span class="line">    <span class="keyword">void</span> *userdata;             <span class="comment">/**&lt; 用户自定义的数据 */</span></span><br><span class="line">&#125; SDL_AudioSpec;</span><br></pre></td></tr></table></figure><h4 id="SDL-AudioCallback"><a href="#SDL-AudioCallback" class="headerlink" title="SDL_AudioCallback"></a>SDL_AudioCallback</h4><p>当音频设备需要更多数据的时候会调用该回调函数。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// userdata：SDL_AudioSpec结构中的用户自定义数据，一般情况下可以不用。</span></span><br><span class="line"><span class="comment">// stream：该指针指向需要填充的音频缓冲区。</span></span><br><span class="line"><span class="comment">// len：音频缓冲区的大小（以字节为单位）。</span></span><br><span class="line"><span class="type">void</span> (SDLCALL * SDL_AudioCallback) (<span class="type">void</span> *userdata,</span><br><span class="line">                                    Uint8 *<span class="keyword">stream</span>,</span><br><span class="line">                                    <span class="type">int</span> len);</span><br></pre></td></tr></table></figure><h3 id="播放音频数据"><a href="#播放音频数据" class="headerlink" title="播放音频数据"></a>播放音频数据</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 当pause_on设置为0的时候即可开始播放音频数据。设置为1的时候，将会播放静音的值。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> SDLCALL <span class="title">SDL_PauseAudio</span><span class="params">(<span class="keyword">int</span> pause_on)</span></span></span><br></pre></td></tr></table></figure><h3 id="播放PCM音频Demo"><a href="#播放PCM音频Demo" class="headerlink" title="播放PCM音频Demo"></a>播放PCM音频Demo</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tchar.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL_types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"SDL.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_chunk;</span><br><span class="line"><span class="keyword">static</span> Uint32 audio_len;</span><br><span class="line"><span class="keyword">static</span> Uint8 *audio_pos;</span><br><span class="line"><span class="keyword">int</span> pcm_buffer_size = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回调函数，音频设备需要更多数据的时候会调用该回调函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_audio_data</span><span class="params">(<span class="keyword">void</span> *udata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line">    <span class="keyword">if</span> (audio_len == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    len = (len &gt; audio_len ? audio_len : len);</span><br><span class="line"></span><br><span class="line">    SDL_MixAudio(stream, audio_pos, len, SDL_MIX_MAXVOLUME);</span><br><span class="line">    audio_pos += len;</span><br><span class="line">    audio_len -= len;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    SDL_AudioSpec spec;</span><br><span class="line">    spec.freq = <span class="number">44100</span>;<span class="comment">//根据你录制的PCM采样率决定</span></span><br><span class="line">    spec.format = AUDIO_S16SYS;</span><br><span class="line">    spec.channels = <span class="number">1</span>; <span class="comment">//单声道</span></span><br><span class="line">    spec.silence = <span class="number">0</span>;</span><br><span class="line">    spec.samples = <span class="number">1024</span>;</span><br><span class="line">    spec.callback = read_audio_data;</span><br><span class="line">    spec.userdata = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDL_OpenAudio(&amp;spec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"can't open audio.\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    FILE *fp = fopen(<span class="string">"C:\\Users\\lenovo\\Desktop\\1111111.pcm"</span>, <span class="string">"rb+"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fp == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"cannot open this file\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> *pcm_buffer = (<span class="keyword">char</span> *) <span class="built_in">malloc</span>(pcm_buffer_size);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//播放</span></span><br><span class="line">    SDL_PauseAudio(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fread(pcm_buffer, <span class="number">1</span>, pcm_buffer_size, fp) != pcm_buffer_size) &#123; <span class="comment">//从文件中读取数据，剩下的就交给音频设备去完成了，它播放完一段数据后会执行回调函数，获取等多的数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        audio_chunk = (Uint8 *) pcm_buffer;</span><br><span class="line">        audio_len = pcm_buffer_size; <span class="comment">//长度为读出数据长度，在read_audio_data中做减法</span></span><br><span class="line">        audio_pos = audio_chunk;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (audio_len &gt; <span class="number">0</span>) <span class="comment">//判断是否播放完毕</span></span><br><span class="line">            SDL_Delay(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(pcm_buffer);</span><br><span class="line">    SDL_Quit();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>OK！第一步完成，能正常播放出声音了。</p><p>想要录制PCM自己试一下？可以试试用这个<a href="https://david1840.github.io/2019/02/11/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%94-OpenSL-ES%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/" target="_blank" rel="noopener">Android音视频(五) OpenSL ES录制、播放音频(带源码)</a>录制一段。</p><p><a href="https://github.com/David1840/SimplePlayer/blob/master/pcm_player.c" target="_blank" rel="noopener">源码 GitHub-SimplePlayer-pcm_player</a></p><p>====== 更新 完成了FFmpeg+SDL2播放音频流的开发，代码请看<a href="https://github.com/David1840/SimplePlayer/blob/master/audio_player.c" target="_blank" rel="noopener">源码 GitHub-SimplePlayer-audio_player</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2纹理渲染</title>
    <link href="http://yoursite.com/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/"/>
    <id>http://yoursite.com/2019/04/16/SDL2纹理渲染/</id>
    <published>2019-04-16T02:43:16.000Z</published>
    <updated>2019-04-20T08:34:56.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2第三篇。</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p>接下来就看下如何使用SDL如何通过SDL_Texture在窗口绘制图像。</p><p>先了解几个纹理渲染相关API：</p><h4 id="创建纹理"><a href="#创建纹理" class="headerlink" title="创建纹理"></a>创建纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Texture* <span class="title">SDL_CreateTexture</span><span class="params">(SDL_Renderer * renderer, </span></span></span><br><span class="line"><span class="function"><span class="params">Uint32 format, </span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> w, <span class="keyword">int</span> h)</span></span>;</span><br></pre></td></tr></table></figure><p>format: 像素格式，YUV或RGB</p><p>access: 指明Texture的类型。可以是 Stream(视频)，也可以是Target一般的类型。</p><h4 id="销毁纹理"><a href="#销毁纹理" class="headerlink" title="销毁纹理"></a>销毁纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyTexture</span><span class="params">(SDL_Texture* texture)</span></span></span><br></pre></td></tr></table></figure><h4 id="渲染目标"><a href="#渲染目标" class="headerlink" title="渲染目标"></a>渲染目标</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将渲染目标定为纹理</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_SetRenderTarget</span><span class="params">(SDL_Renderer *renderer,</span></span></span><br><span class="line"><span class="function"><span class="params">                        SDL_Texture *texture)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="纹理拷贝"><a href="#纹理拷贝" class="headerlink" title="纹理拷贝"></a>纹理拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//会将纹理拷贝到显卡上去，显卡会计算出最终图形并渲染到窗口中</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_RenderCopy</span><span class="params">(SDL_Renderer*   renderer,</span></span></span><br><span class="line"><span class="function"><span class="params">                   SDL_Texture*    texture,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> SDL_Rect* srcrect,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">const</span> SDL_Rect* dstrect)</span></span></span><br></pre></td></tr></table></figure><p>srcrect: 指定 Texture 中要渲染的一部分。如果将 Texture全部输出，可以设置它为 NULL。</p><p>dstrect: 指定输出的空间大小。</p><h3 id="简单示例"><a href="#简单示例" class="headerlink" title="简单示例"></a>简单示例</h3><p>在前面Demo的基础上做了一定修改，简单实现一个正方形在界面中随机显示。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> quit = <span class="number">1</span>;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Texture *sdlTexture = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    SDL_Rect rect; <span class="comment">// 长方形，原点在左上角</span></span><br><span class="line">    rect.w = <span class="number">50</span>;</span><br><span class="line">    rect.h = <span class="number">50</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);<span class="comment">//初始化函数,可以确定希望激活的子系统</span></span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">"My First Window"</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<span class="comment">// 创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//基于窗口创建渲染器</span></span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    SDL_SetRenderDrawColor(renderer, 255, 0, 0, 255); //设置渲染器颜色</span></span><br><span class="line"><span class="comment">//    SDL_RenderClear(renderer); //用指定的颜色清空缓冲区</span></span><br><span class="line"><span class="comment">//    SDL_RenderPresent(renderer); //将缓冲区中的内容输出到目标窗口上</span></span><br><span class="line"></span><br><span class="line">    sdlTexture = SDL_CreateTexture(renderer,</span><br><span class="line">                                   SDL_PIXELFORMAT_RGBA8888,</span><br><span class="line">                                   SDL_TEXTUREACCESS_TARGET,</span><br><span class="line">                                   <span class="number">640</span>,</span><br><span class="line">                                   <span class="number">480</span>); <span class="comment">//创建纹理</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!sdlTexture) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (quit) &#123;</span><br><span class="line">        SDL_PollEvent(&amp;event); <span class="comment">// SDL_WaitEvent在这里就不太适合，只有在事件发生时才会触发，其余时间都是阻塞状态</span></span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT:</span><br><span class="line">                SDL_Log(<span class="string">"quit"</span>);</span><br><span class="line">                quit = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                SDL_Log(<span class="string">"event type:%d"</span>, event.type);</span><br><span class="line">        &#125;</span><br><span class="line">        rect.x = rand() % <span class="number">600</span>;</span><br><span class="line">        rect.y = rand() % <span class="number">400</span>;</span><br><span class="line"></span><br><span class="line">        SDL_SetRenderTarget(renderer, sdlTexture); <span class="comment">// 设置渲染目标为纹理</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">// 纹理背景为黑色</span></span><br><span class="line">        SDL_RenderClear(renderer); <span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">        SDL_RenderDrawRect(renderer, &amp;rect); <span class="comment">//绘制一个长方形</span></span><br><span class="line">        SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>, <span class="number">255</span>); <span class="comment">//长方形为白色</span></span><br><span class="line">        SDL_RenderFillRect(renderer, &amp;rect);</span><br><span class="line"></span><br><span class="line">        SDL_SetRenderTarget(renderer, <span class="literal">NULL</span>); <span class="comment">//恢复默认，渲染目标为窗口</span></span><br><span class="line">        SDL_RenderCopy(renderer, sdlTexture, <span class="literal">NULL</span>, <span class="literal">NULL</span>); <span class="comment">//拷贝纹理到CPU</span></span><br><span class="line"></span><br><span class="line">        SDL_RenderPresent(renderer); <span class="comment">//输出到目标窗口上</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    SDL_DestroyTexture(sdlTexture);</span><br><span class="line">    SDL_DestroyRenderer(renderer);</span><br><span class="line">    SDL_DestroyWindow(window); <span class="comment">//销毁窗口</span></span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这个Demo就是最简单的纹理渲染流程。</p><p>接下来再认识两个API：</p><h4 id="更新纹理"><a href="#更新纹理" class="headerlink" title="更新纹理"></a>更新纹理</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//两个API功能相同，但是SDL_UpdateYUVTexture直接将Y、U、V分量传入，可以减少CPU计算量，更快一些</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UpdateTexture</span><span class="params">(SDL_Texture * texture, <span class="comment">//想要更新的纹理</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> SDL_Rect * rect, <span class="comment">//更新的像素矩形，传NULL则表示为整个纹理</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">void</span> *pixels, <span class="comment">//像素数据</span></span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">int</span> pitch)</span></span>;<span class="comment">//一行像素数据的字节数</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UpdateYUVTexture</span><span class="params">(SDL_Texture * texture,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> SDL_Rect * rect,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Yplane, <span class="keyword">int</span> Ypitch,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Uplane, <span class="keyword">int</span> Upitch,</span></span></span><br><span class="line"><span class="function"><span class="params">                         <span class="keyword">const</span> Uint8 *Vplane, <span class="keyword">int</span> Vpitch)</span></span>;</span><br></pre></td></tr></table></figure><p>这两个API将会在视频播放中发挥重要作用，下一篇博客将会结合FFmpeg实现一个视频播放器。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2第三篇。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2事件处理</title>
    <link href="http://yoursite.com/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/04/15/SDL2事件处理/</id>
    <published>2019-04-15T07:51:06.000Z</published>
    <updated>2019-04-20T08:31:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>在上一篇<a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2音视频渲染入门</a>中，我们只是展示了一个窗口，3秒钟后自动消失。如何让这个窗口像其他正常应用的窗口一样可以进行拖动、最小化、关闭等操作，这个时候就需要SDL的事件处理了。这里所指的事件处理就是我们通常所说的，键盘事件，鼠标事件，窗口事件等，SDL对这些事件都做了封装，提供了统一的API。</p><h3 id="SDL事件处理"><a href="#SDL事件处理" class="headerlink" title="SDL事件处理"></a>SDL事件处理</h3><p>在SDL中，将所有的事件都存放在一个队列中，然后通过一个循环从队列中取出数据，进行处理，所有对事件的操作，其实就是对队列的操作。</p><p>将上一篇中的代码<code>SDL_Delay(3000); // 延时3秒</code>改为：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (quit) &#123;</span><br><span class="line">    SDL_WaitEvent(&amp;event);</span><br><span class="line">    <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDL_QUIT:<span class="comment">//退出事件</span></span><br><span class="line">            SDL_Log(<span class="string">"quit"</span>);</span><br><span class="line">            quit = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            SDL_Log(<span class="string">"event type:%d"</span>, event.type);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现一个点击窗口“x”号关闭窗口的功能。</p><h4 id="事件轮训方式"><a href="#事件轮训方式" class="headerlink" title="事件轮训方式"></a>事件轮训方式</h4><p>SDL_WaitEvent: 事件驱动方式，当列表中有事件存在才会触发处理流程，否则处于阻塞状态，释放 CPU</p><p>SDL_PollEvent: 轮训方式，定时不断从列表中取出数据处理（可能会导致CPU 100%） </p><p>SDL_WaitEventTimeout: 与SDL_WaitEvent的区别时，当到达超时时间后，退出阻塞状态。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">即然有 SDL_WaitEvent了，为什么还要有SDL_PollEvent呢？这主要是由于使用的场景不同。对于游戏来说，它要求事件的实时处理，就使用SDL_PollEvent； 而对于一些其它实时性不高的情况来说，则可以使用 SDL_WaitEvent了。</span><br></pre></td></tr></table></figure><h4 id="SDL事件类型"><a href="#SDL事件类型" class="headerlink" title="SDL事件类型"></a>SDL事件类型</h4><p>SDL_WindowEvent : Window窗口相关的事件。</p><p>SDL_KeyboardEvent : 键盘相关的事件。</p><p>SDL_MouseMotionEvent : 鼠标移动相关的事件。</p><p>SDL_QuitEvent : 退出事件。</p><p>SDL_UserEvent : 用户自定义事件。</p><p>具体信息可以查看<a href="https://wiki.libsdl.org/SDL_Event" target="_blank" rel="noopener">SDL Wiki</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在上一篇&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2音视频渲染入门</title>
    <link href="http://yoursite.com/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2019/04/11/SDL2音视频渲染入门/</id>
    <published>2019-04-11T06:23:25.000Z</published>
    <updated>2019-05-07T10:34:06.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL， “Simple DirectMedia Layer”，它是一套开放源代码的跨平台多媒体开发库，使用C语言写成。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API库。如在 Linux 系统下，它会使用 opengl 做渲染，而在 Window 下它会调用 D3D API进行渲染。</p><h2 id="SDL2安装"><a href="#SDL2安装" class="headerlink" title="SDL2安装"></a>SDL2安装</h2><p>SDL官网下载：<a href="https://www.libsdl.org/download-2.0.php" target="_blank" rel="noopener">https://www.libsdl.org/download-2.0.php</a></p><p>下载Source Code（以后去看源代码也比较方便），然后进行编译安装：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">configure --<span class="built_in">prefix</span>=/usr/<span class="built_in">local</span></span><br></pre></td></tr></table></figure><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="built_in">make</span> &amp;&amp; <span class="built_in">make</span> install</span><br></pre></td></tr></table></figure><p>在/usr/local下就可以找到编译后的SDL2相关文件</p><h2 id="SDL2使用"><a href="#SDL2使用" class="headerlink" title="SDL2使用"></a>SDL2使用</h2><p>运行环境Windows + CLion，代码通用，不同平台只需要更改依赖的SDL库即可</p><h3 id="CMakeList"><a href="#CMakeList" class="headerlink" title="CMakeList"></a>CMakeList</h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">3.12</span>)</span><br><span class="line"><span class="keyword">project</span>(SimplePlayer C)</span><br><span class="line"></span><br><span class="line"><span class="keyword">set</span>(CMAKE_C_STANDARD <span class="number">99</span>)</span><br><span class="line"><span class="keyword">set</span>(SOURCE_FILES main.c)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里我使用的是自己机器上安装的SDL库，根据自己的安装路径替换</span></span><br><span class="line"><span class="keyword">set</span>(INC_DIR_SDL C:/cygwin64/usr/local/<span class="keyword">include</span>/SDL2/)</span><br><span class="line"><span class="keyword">set</span>(LINK_DIR_SDL C:/cygwin64/usr/local/lib/)</span><br><span class="line"></span><br><span class="line"><span class="keyword">include_directories</span>(<span class="variable">$&#123;INC_DIR_SDL&#125;</span>)</span><br><span class="line"><span class="keyword">link_directories</span>(<span class="variable">$&#123;LINK_DIR_SDL&#125;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(SimplePlayer <span class="variable">$&#123;SOURCE_FILES&#125;</span>)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(</span><br><span class="line">        SimplePlayer</span><br><span class="line">        SDL2</span><br><span class="line">        SDL2main)</span><br></pre></td></tr></table></figure><h3 id="SDL的基本流程"><a href="#SDL的基本流程" class="headerlink" title="SDL的基本流程"></a>SDL的基本流程</h3><p>1、初始化SDL<br>2、创建窗口<br>3、创建渲染器<br>4、清空缓冲区<br>5、绘制要显示的内容<br>6、最终将缓冲区内容渲染到window窗口上。<br>7、销毁渲染器<br>8、销毁窗口<br>9、退出SDL</p><p>下面是一个最简单的SDL程序，会显示一个640*480的窗口，窗口内部为红色，显示3秒后消失</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;SDL2/SDL.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    SDL_Window *window = <span class="literal">NULL</span>;</span><br><span class="line">    SDL_Renderer *renderer = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    SDL_Init(SDL_INIT_VIDEO);<span class="comment">// 初始化函数,可以确定希望激活的子系统</span></span><br><span class="line"></span><br><span class="line">    window = SDL_CreateWindow(<span class="string">"My First Window"</span>,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              SDL_WINDOWPOS_UNDEFINED,</span><br><span class="line">                              <span class="number">640</span>,</span><br><span class="line">                              <span class="number">480</span>,</span><br><span class="line">                              SDL_WINDOW_OPENGL | SDL_WINDOW_RESIZABLE);<span class="comment">//  创建窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!window) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    renderer = SDL_CreateRenderer(window, <span class="number">-1</span>, <span class="number">0</span>);<span class="comment">//基于窗口创建渲染器</span></span><br><span class="line">    <span class="keyword">if</span> (!renderer) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    SDL_SetRenderDrawColor(renderer, <span class="number">255</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>); <span class="comment">//设置渲染器颜色 r、g、b、a</span></span><br><span class="line">    SDL_RenderClear(renderer);<span class="comment">//用指定的颜色清空缓冲区</span></span><br><span class="line">    SDL_RenderPresent(renderer); <span class="comment">//将缓冲区中的内容输出到目标窗口上。</span></span><br><span class="line">    SDL_Delay(<span class="number">3000</span>); <span class="comment">// 延时3秒</span></span><br><span class="line">    SDL_DestroyRenderer(renderer); <span class="comment">//销毁渲染器</span></span><br><span class="line">    SDL_DestroyWindow(window); <span class="comment">// 销毁窗口</span></span><br><span class="line">    SDL_Quit(); <span class="comment">//退出SDL</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/2019/04/11/SDL2音视频渲染入门/SDL2-1.png" alt=""></p><h3 id="SDL-API简介"><a href="#SDL-API简介" class="headerlink" title="SDL API简介"></a>SDL API简介</h3><ol><li><p>SDL_Init 初始化</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_Init</span><span class="params">(Uint32 flags)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">flages：</span><br><span class="line">SDL_INIT_TIMER 定时器子系统</span><br><span class="line">SDL_INIT_AUDIO 音频子系统</span><br><span class="line">SDL_INIT_VIDEO 视频子系统，同时会初始化事件子系统</span><br><span class="line">SDL_INIT_EVENTS 事件子系统</span><br><span class="line">SDL_INIT_EVERYTHING 初始化所有子系统=</span><br></pre></td></tr></table></figure></li><li><p>SDL_CreateWindow 创建窗口</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Window* <span class="title">SDL_CreateWindow</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *title,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> w,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">int</span> h, Uint32 flags)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">title：窗口标题</span><br><span class="line">x,y,w,h：窗口坐标</span><br><span class="line"><span class="symbol">flags:</span></span><br><span class="line"> ::SDL_WINDOW_FULLSCREEN,<span class="regexp">//</span>全屏         ::SDL_WINDOW_OPENGL,<span class="regexp">//</span>使用OpenGL上下文</span><br><span class="line"> ::SDL_WINDOW_HIDDEN, <span class="regexp">//</span>窗口不可见       ::SDL_WINDOW_BORDERLESS, <span class="regexp">//</span>无边框</span><br><span class="line"> ::SDL_WINDOW_RESIZABLE,<span class="regexp">//</span>窗口大小可变    ::SDL_WINDOW_MAXIMIZED, <span class="regexp">//</span>窗口最大化</span><br><span class="line"> ::SDL_WINDOW_MINIMIZED,<span class="regexp">//</span>窗口最小化      ::SDL_WINDOW_INPUT_GRABBED,<span class="regexp">//</span>输入捕获</span><br></pre></td></tr></table></figure></li></ol><ol start="3"><li><p>SDL_CreateRenderer 创建渲染器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Renderer* <span class="title">SDL_CreateRenderer</span><span class="params">(SDL_Window* window,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 <span class="keyword">int</span> index,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Uint32 flags)</span></span></span><br></pre></td></tr></table></figure><figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window: 指明在哪个窗口里进行渲染</span><br><span class="line">index: 指定渲染驱动的索引号。一般指定为 -<span class="number">1</span>.</span><br><span class="line">flags：</span><br><span class="line"> SDL_RENDERER_SOFTWARE <span class="comment">//The renderer is a software fallback 软件备份</span></span><br><span class="line"> SDL_RENDERER_ACCELERATED <span class="comment">//The renderer uses hardware acceleration 硬件加速</span></span><br><span class="line"> SDL_RENDERER_PRESENTVSYNC <span class="comment">//Present is synchronized with the refresh rate 刷新率同步</span></span><br><span class="line"> SDL_RENDERER_TARGETTEXTURE <span class="comment">//The renderer supports rendering to texture 支持渲染纹理</span></span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL， “Simple DirectMedia Layer”，它是一套开放源代码的跨平台多媒体开发库，使用C语言写成。其主要用于游戏开发中的多媒体处理，如视频渲染，音频播放，鼠标/键盘控制等操作。它对外接供了一套统一的接口，但在内部，它会根据不同平台调用不同的底层 API
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-异常处理</title>
    <link href="http://yoursite.com/2019/02/14/Android-JNI%E5%AD%A6%E4%B9%A0-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2019/02/14/Android-JNI学习-异常处理/</id>
    <published>2019-02-14T13:25:55.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>异常我们已经很熟悉了，空指针、数组越界等等，在Java中，当抛出一个异常，虚拟机会停止执行代码块并进入调用栈反向检查能处理特定异常的异常处理程序代码块，虚拟机清除异常并将控制权交给异常处理程序。而JNI不同，JNI没有像Java一样有try…catch…final这样的异常处理机制，面且在本地代码中调用某个JNI接口时如果发生了异常，后续的本地代码不会立即停止执行，而会继续往下执行后面的代码，这就要求开发人员在异常发生后显式地实现异常处理。</p><h3 id="1-捕获异常"><a href="#1-捕获异常" class="headerlink" title="1 捕获异常"></a>1 捕获异常</h3><p>在一个方法执行之后，可以调用<code>(*env)-&gt;ExceptionCheck</code>或者 <code>(*env)-&gt;ExceptionOccurred</code>（两者的区别在于返回值不一样）</p><p><code>ExceptionCheck</code>：检查是否发生了异常，若有异常返回JNI_TRUE，否则返回JNI_FALSE  <code>ExceptionOccurred</code>：检查是否发生了异常，若用异常返回该异常的引用，否则返回NULL </p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> jchar *<span class="function"><span class="title">cstr</span> = <span class="params">(*env)</span>-&gt;</span>GetStringChars(env, jstr);</span><br><span class="line"><span class="keyword">if</span> (c_str == NULL) &#123;</span><br><span class="line">    <span class="keyword">return</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> <span class="function"><span class="params">((*env)-&gt;ExceptionCheck(env))</span> &#123; /* 异常检查 */</span></span><br><span class="line"><span class="function">    <span class="params">(*env)</span>-&gt;</span>ReleaseStringChars(env, jstr, cstr); <span class="regexp">// 发生异常后释放分配内存</span></span><br><span class="line"><span class="regexp">    return; </span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure><h3 id="2-抛出异常"><a href="#2-抛出异常" class="headerlink" title="2 抛出异常"></a>2 抛出异常</h3><p>ThrowNew：在当前线程触发一个异常，并自定义输出异常信息<br><code>jint (JNICALL *ThrowNew) (JNIEnv *env, jclass clazz, const char *msg);</code> </p><p>Throw：丢弃一个现有的异常对象，在当前线程触发一个新的异常<br><code>jint (JNICALL *Throw) (JNIEnv *env, jthrowable obj);</code> </p><p>FatalError：致命异常，用于输出一个异常信息，并终止当前VM实例（即退出程序） </p><p><code>void (JNICALL *FatalError) (JNIEnv *env, const char *msg);</code></p><h3 id="3-示例"><a href="#3-示例" class="headerlink" title="3 示例"></a>3 示例</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jclass jclass1 = (*env)-&gt;FindClass(env, <span class="string">"com/test/JNIController"</span>);</span><br><span class="line">    <span class="keyword">if</span> (jclass1 == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    jmethodID methodID = (*env)-&gt;GetMethodID(env, jclass1, <span class="string">"exitProcessCallBack"</span>, <span class="string">"(III)V"</span>);</span><br><span class="line">    <span class="keyword">if</span> (methodID == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, local_object, methodID, code, uploaded, all);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((*env)-&gt;ExceptionCheck)&#123;</span><br><span class="line">        (*env)-&gt;ExceptionDescribe(env);     <span class="comment">// 打印异常的堆栈信息 </span></span><br><span class="line">        (*env)-&gt;ExceptionClear(env);        <span class="comment">// 清除异常堆栈信息 </span></span><br><span class="line">        (*env)-&gt;ThrowNew(env,(*env)-&gt;FindClass(env,<span class="string">"java/lang/Exception"</span>),<span class="string">"JNI出现异常！"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h3><ol><li>当调用一个JNI函数后，必须先检查、处理、清除异常后再做其它 JNI 函数调用，否则会产生不可预知的结果。 </li><li>一旦发生异常，立即返回，让调用者处理这个异常。或 调用 ExceptionClear 清除异常，然后执行自己的异常处理代码。 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;异常我们已经很熟悉了，空指针、数组越界等等，在Java中，当抛出一个异常，虚拟机会停止执行代码块并进入调用栈反向检查能处理特定异常的异常处理程序代码块，虚拟机清除异常并将控制权交给异常处理程序。而JNI不同，JNI没有像Java一样有try…catch…final这样的异常
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-线程操作</title>
    <link href="http://yoursite.com/2019/02/14/Android-JNI%E5%AD%A6%E4%B9%A0-%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://yoursite.com/2019/02/14/Android-JNI学习-多线程/</id>
    <published>2019-02-14T12:30:18.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android Native中支持的线程标准是 POSIX 线程。POSIX 线程也被简称为Pthreads，是一个线程的POSIX 标准，它为创建和处理线程定义了一个通用的API。</p><p>POSIX Thread 的Android实现是Bionic标准库的一部分，在编译的时候不需要链接任何其他的库，只需要包含一个头文件。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br></pre></td></tr></table></figure><h3 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h3><p>线程创建函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_create</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_t</span>* thread, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">pthread_attr_t</span> <span class="keyword">const</span>* attr, </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* (*start_routine)(<span class="keyword">void</span>*), </span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">void</span>* arg)</span></span>;</span><br></pre></td></tr></table></figure><ul><li><p>thread：指向 pthread_t 类型变量的指针，用它代表返回线程的句柄</p></li><li><p>attr：指向 pthread_attr_t 结构的指针形式存在的新线程属性，可以通过该结构来指定新线程的一些属性，比如栈大小、调度优先级等，具体看 pthread_attr_t 结构的内容。如果没有特殊要求，可使用默认值，把该变量取值为 NULL 。</p></li><li><p>第三个参数是指向启动函数的函数指针，它的函数签名格式如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">start_routine</span><span class="params">(<span class="keyword">void</span>* args)</span></span></span><br></pre></td></tr></table></figure><p>启动程序将线程参数看成 void 指针，返回 void 指针类型结果。</p></li><li><p>线程启动程序的参数，也就是函数的参数，如果不需要传递参数，它可以为 NULL 。</p></li></ul><p><code>pthread_create</code> 函数如果执行成功了则返回 0 ，如果返回其他错误代码。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">void</span> *)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"say %s"</span>,<span class="string">"hello"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">JNIEXPORT jint JNICALL Java_com_david_JNIController_sayhello</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance) &#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> handles; <span class="comment">// 线程句柄</span></span><br><span class="line">    <span class="keyword">int</span> ret = pthread_create(&amp;handles, <span class="literal">NULL</span>, sayHello, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"create thread failed"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGD(<span class="string">"create thread success"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用函数就可以在线程执行打印say hello了。</p><h3 id="附着在Java虚拟机上"><a href="#附着在Java虚拟机上" class="headerlink" title="附着在Java虚拟机上"></a>附着在Java虚拟机上</h3><p>创建了线程后，只能做一些简单的Native操作，如果想要对Java层做一些操作就不行了，因为它没有Java虚拟机环境，这个时候为了和Java空间进行交互，就要把POSIX 线程附着在Java虚拟机上，然后就可以获得当前线程的 JNIEnv 指针了。</p><p>通过 <code>AttachCurrentThread</code> 方法可以将当前线程附着到 Java 虚拟机上，并且可以获得 JNIEnv 指针。而<code>AttachCurrentThread</code> 方法是由 JavaVM 指针调用的，可以在<code>JNI_OnLoad</code>函数中将JavaVM 保存为全局变量。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> JavaVM *jVm = <span class="literal">NULL</span>;</span><br><span class="line"><span class="function">JNIEXPORT <span class="keyword">int</span> JNICALL <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    jVm = vm;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上一个例子，我们想要在sayHello函数中调用一个Java层的函数<code>javaSayHello()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">javaSayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Log.e(TAG,<span class="string">"java say hello"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sayHello</span><span class="params">(<span class="keyword">void</span> *)</span></span>&#123;</span><br><span class="line">    LOGE(<span class="string">"say %s"</span>,<span class="string">"hello"</span>);</span><br><span class="line">     JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将当前线程添加到 Java 虚拟机上</span></span><br><span class="line">    <span class="keyword">if</span> (jVm-&gt;AttachCurrentThread(&amp;env, <span class="literal">NULL</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        ......</span><br><span class="line">        env-&gt;CallVoidMethod(Obj, javaSayHello);</span><br><span class="line">        <span class="comment">// 从 Java 虚拟机上分离当前线程</span></span><br><span class="line">        jVm-&gt;DetachCurrentThread();  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就在 Native 线程中调用 Java 相关的函数了。</p><h3 id="等待线程返回结果"><a href="#等待线程返回结果" class="headerlink" title="等待线程返回结果"></a>等待线程返回结果</h3><p>前面提到的方法是新线程运行后，该方法也就立即返回退出，执行完了。我们也可以通过另一个函数可以在等待线程执行完毕后，拿到线程执行完的结果之后再退出。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_join</span><span class="params">(<span class="keyword">pthread_t</span> pthread, <span class="keyword">void</span>** ret_value)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>pthread 代表创建线程的句柄</li><li>ret_value代表线程运行函数返回的结果</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">pthread_t</span>* handles = <span class="keyword">new</span> <span class="keyword">pthread_t</span>[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">       <span class="keyword">pthread_t</span> pthread;</span><br><span class="line">       <span class="comment">// 创建线程，</span></span><br><span class="line">       <span class="keyword">int</span> result = pthread_create(&amp;handles[i], <span class="literal">NULL</span>, run, <span class="literal">NULL</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">       <span class="keyword">void</span> *result = <span class="literal">NULL</span>; <span class="comment">// 线程执行返回结果</span></span><br><span class="line">       <span class="comment">// 等待线程执行结束</span></span><br><span class="line">       <span class="keyword">if</span> (pthread_join(handles[i], &amp;result) != <span class="number">0</span>) &#123;</span><br><span class="line">           env-&gt;ThrowNew(env, runtimeException, <span class="string">"Unable to join thread"</span>);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGD(<span class="string">"return value is %d"</span>,result);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p> pthread_join 返回为 0 代表执行成功，非 0 则执行失败。</p><h3 id="同步代码块"><a href="#同步代码块" class="headerlink" title="同步代码块"></a>同步代码块</h3><p>在Java中，JDK为我们提供了synchronized来处理多线程同步代码块。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object.class) &#123;</span><br><span class="line">       <span class="comment">// 业务处理</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>本地代码中，JNI提供了两个函数来完成上面的同步：</p><p>（1）MonitorEnter：进入同步代码块</p><p>（2）MonitorExit：退出同步代码块</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(env-&gt;MonitorEnter(obj)!= JNI_OK)&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 同步代码块</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 出现错误释放代码块</span></span><br><span class="line"><span class="keyword">if</span>(env-&gt;ExceptionCheck())&#123;</span><br><span class="line">    <span class="keyword">if</span>(env-&gt;MonitorExit(obj)!= JNI_OK);</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(env-&gt;MonitorExit(obj)!= JNI_OK)&#123;</span><br><span class="line">    <span class="comment">// 错误处理</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以发现在本地代码中处理同步代码块要比Java中复杂的多，所以，尽量用Java来做同步吧，把与同步相关的代码都移到Java中去。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android Native中支持的线程标准是 POSIX 线程。POSIX 线程也被简称为Pthreads，是一个线程的POSIX 标准，它为创建和处理线程定义了一个通用的API。&lt;/p&gt;
&lt;p&gt;POSIX Thread 的Android实现是Bionic标准库的一部分，
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android native层动态加载so库</title>
    <link href="http://yoursite.com/2019/02/13/Android-native%E5%B1%82%E5%8A%A8%E6%80%81%E5%8A%A0%E8%BD%BDso%E5%BA%93/"/>
    <id>http://yoursite.com/2019/02/13/Android-native层动态加载so库/</id>
    <published>2019-02-13T13:40:33.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p>随着App功能的不断增多，Native层的代码规模也在迅速膨胀，为了Native层的代码结构清晰，会按照模块分别构建成独立的so库，使用一个JNI层so库引用其他实现具体功能的功能实现so库，Java层只加载这个JNI层so库，来间接调用功能实现so库。</p><p><img src="/2019/02/13/Android-native层动态加载so库/native-so1.png" alt=""></p><p>so库之间通过引用头文件和运行时指定共享库依赖的方式形成了依赖关系。但是这样也会有一些问题。</p><ol><li>我们常常会用到第三方的 so 库，如果单个库可能没问题，如果多个第三方 so 库文件，同时加载可能会出现冲突，比如说腾讯的YSDK和BUGLY。</li><li>加载JNI层so库的时候，即使这次JNI调用有些功能实现so库里面的数据结构或函数没有被调用到，只要这个so库被JNI层so库声明为运行时需要依赖的共享库，也需要跟JNI层so库一起被加载，这无形中增大了Native层的常驻内存。</li></ol><p>这个时候就需要在Native层直接动态加载so库，由JNI层so库动态加载功能实现so库。如下图所示，会有一个统一接口so库，在这个库中定义好不可轻易修改的接口函数，调用方只需要知道这些接口即可，不需要依赖头文件就能调用这些函数，这样调用方和so库之间就不存在直接的依赖，具体的工作就可以交给统一接口so库完成，它通过动态调用再去执行功能so库中的函数。</p><p><img src="/2019/02/13/Android-native层动态加载so库/native-so2.png" alt=""></p><h3 id="so库动态加载的实现"><a href="#so库动态加载的实现" class="headerlink" title="so库动态加载的实现"></a>so库动态加载的实现</h3><p>在Native层的C/C++代码环境，so库动态加载是使用<code>dlopen()</code>、<code>dlsym()</code>和<code>dlclose()</code>这三个函数实现的。它们的作用分别是：<code>dlopen()</code>打开一个动态链接库，返回一个动态链接库的句柄；<code>dlsym()</code>根据动态链接库句柄和符号名，返回动态链接库内的符号地址，这个地址既可以是变量指针，也可以是函数指针；<code>dlclose()</code>关闭动态链接库句柄，并对动态链接库的引用计数减1，当这个库的引用计数为0，这个库将会被系统卸载。</p><p>一般使用C/C++实现so库动态加载的流程如下：</p><ol><li>首先调用<code>dlopen()</code>函数，这个函数所需的参数，一个是so库的路径，一个是加载模式。一般使用的加载模式有两个：<code>RTLD_NOW</code>在返回前解析出所有未定义符号，如果解析不出来，<code>dlopen()</code>返回<code>NULL</code>；<code>RTLD_LAZY</code>则只解析当前需要的符号（只对函数生效，变量定义仍然是全部解析）。显然对于动态加载，加载方只需知道当前被加载的so库里面自己需要用的函数和变量定义，所以这里选择的是后者。如果这个调用成功将返回一个so库的句柄；</li><li>在上一步得到so库句柄之后，这时就可以调用<code>dlsym()</code>函数，传入so库句柄和所需的函数或变量名称，返回相应的函数指针或变量指针；加载方这时就可以使用返回的指针调用被加载so库之中定义的函数和数据结构；</li><li>当so库的调用结束，调用<code>dlclose()</code>函数关闭卸载so库；</li><li>如果在打开关闭so库，或者获取so库里操作对象的指针出现错误的时候，可以调用<code>dlerror()</code>函数获取具体的错误原因。</li></ol><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>比如，在硬件功能so库中有一个<code>int test_open(int port)</code>的函数，该如何最终调用到这个方法呢？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、声明函数接口</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*Func_test_open)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">    <span class="comment">//2、获取so句柄</span></span><br><span class="line">    <span class="keyword">void</span> *handle = dlopen(<span class="string">"libtest.so"</span>,RTLD_LAZY);</span><br><span class="line">    <span class="keyword">if</span>(!handle )&#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>,dlerror());</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3、获取函数指针</span></span><br><span class="line">    Func_test_open func_test_open = (Func_test_open) dlsym (handle,<span class="string">"test_open"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!func_test_open)&#123;</span><br><span class="line">        LOGE(<span class="string">"%s"</span>,dlerror());</span><br><span class="line">        dlclose(handle);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">//4、调用函数</span></span><br><span class="line">     <span class="keyword">int</span> ret = func_test_open(<span class="number">8080</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">//5、关闭so</span></span><br><span class="line">     dlclose(handle); </span><br><span class="line">     </span><br><span class="line">     <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样JNI层只需要去调用<code>open(int port)</code>方法就可以调用到硬件功能so库中的<code>test_open(int port)</code>函数</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>刚开始使用动态加载so库的方案时，会比较担心性能问题，但在实测时跟直接依赖对比，对性能并没有明显的影响，功能实现的so库与JNI层完全解耦，有高度的独立内聚性。同时支持动态加载卸载so库，也一定程度上减少了Native层的常驻内存。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;随着App功能的不断增多，Native层的代码规模也在迅速膨胀，为了Native层的代码结构清晰，会按照模块分别构建成独立的so库，使用一个JNI层so库引用其他实现具体功能的功能实现so库，Java层只加载这个JNI层so库，来间接调用功能实现so库。&lt;/p&gt;
&lt;p&gt;&lt;i
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(五) OpenSL ES录制、播放音频</title>
    <link href="http://yoursite.com/2019/02/11/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%94-OpenSL-ES%E6%92%AD%E6%94%BE%E9%9F%B3%E9%A2%91/"/>
    <id>http://yoursite.com/2019/02/11/Android音视频-五-OpenSL-ES播放音频/</id>
    <published>2019-02-11T14:36:31.000Z</published>
    <updated>2019-02-16T06:01:22.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p><a href="https://david1840.github.io/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/" target="_blank" rel="noopener">Android音视频(三)FFmpeg Camera2推流直播</a></p><p><a href="https://david1840.github.io/2019/01/08/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%89-MediaCodec%E7%A1%AC%E7%BC%96%E7%A1%AC%E8%A7%A3/" target="_blank" rel="noopener">Android音视频(四)MediaCodec编解码AAC</a></p><p>OpenSL ES (Open Sound Library for Embedded Systems)是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速API。它为嵌入式移动多媒体设备上的本地应用程序开发者提供标准化, 高性能,低响应时间的音频功能实现方法，并实现软/硬件音频性能的直接跨平台部署，降低执行难度，促进高级音频市场的发展。简单来说OpenSL ES是一个嵌入式跨平台免费的音频处理库。 </p><p>在Android中一般使用AudioRecord、MediaRecorder对音频进行采集,使用MediaPlayer、AudioTrack、SoundPool进行音频播放。但这些都是在Java层上的接口，如果使用FFmpeg在C/C++层做音视频处理，那么调用这几个方法就比较麻烦了，所以Android NDK也提供了一个叫做OpenSL的C语言引擎用于声音的处理，这篇博客就是简单使用OpenSL去录制、播放音频。</p><h2 id="开发流程"><a href="#开发流程" class="headerlink" title="开发流程"></a>开发流程</h2><p>OpenSL ES 的开发流程主要有如下6个步骤：</p><p><strong>1、创建接口对象</strong></p><p><strong>2、设置混音器</strong></p><p><strong>3、创建播放器（录音器）</strong></p><p><strong>4、设置缓冲队列和回调函数</strong></p><p><strong>5、设置播放状态</strong></p><p><strong>6、启动回调函数</strong></p><p>其中第4步和第6步是OpenSL ES 播放PCM等数据格式的音频是需要用到的。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h3 id="定义Native方法"><a href="#定义Native方法" class="headerlink" title="定义Native方法"></a>定义Native方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//播放音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">play</span><span class="params">(String filePath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止播放音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">playStop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//录制音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">record</span><span class="params">(String filePath)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//停止录制音频</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">stopRecod</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="录音"><a href="#录音" class="headerlink" title="录音"></a>录音</h3><h4 id="参数配置"><a href="#参数配置" class="headerlink" title="参数配置"></a>参数配置</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置IO设备（麦克风）</span></span><br><span class="line">SLDataLocator_IODevice io_device = &#123;</span><br><span class="line">        SL_DATALOCATOR_IODEVICE,         <span class="comment">//类型 这里只能是SL_DATALOCATOR_IODEVICE</span></span><br><span class="line">        SL_IODEVICE_AUDIOINPUT,          <span class="comment">//device类型  选择了音频输入类型</span></span><br><span class="line">        SL_DEFAULTDEVICEID_AUDIOINPUT,   <span class="comment">//deviceID 对应的是SL_DEFAULTDEVICEID_AUDIOINPUT</span></span><br><span class="line">        <span class="literal">NULL</span>                             <span class="comment">//device实例</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSource data_src = &#123;</span><br><span class="line">        &amp;io_device,                      <span class="comment">//SLDataLocator_IODevice配置输入</span></span><br><span class="line">        <span class="literal">NULL</span>                             <span class="comment">//输入格式，采集的并不需要</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置输出buffer队列</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue buffer_queue = &#123;</span><br><span class="line">        SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE,    <span class="comment">//类型 这里只能是SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE</span></span><br><span class="line">        <span class="number">2</span>                                           <span class="comment">//buffer的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//设置输出数据的格式</span></span><br><span class="line">SLDataFormat_PCM format_pcm = &#123;</span><br><span class="line">        SL_DATAFORMAT_PCM,                             <span class="comment">//输出PCM格式的数据</span></span><br><span class="line">        <span class="number">1</span>,                                             <span class="comment">//输出的声道数量</span></span><br><span class="line">        SL_SAMPLINGRATE_44_1,                          <span class="comment">//输出的采样频率，这里是44100Hz</span></span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,                   <span class="comment">//输出的采样格式，这里是16bit</span></span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,                   <span class="comment">//一般来说，跟随上一个参数</span></span><br><span class="line">        SL_SPEAKER_FRONT_LEFT,  <span class="comment">//双声道配置，如果单声道可以用 SL_SPEAKER_FRONT_CENTER</span></span><br><span class="line">        SL_BYTEORDER_LITTLEENDIAN                      <span class="comment">//PCM数据的大小端排列</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSink audioSink = &#123;</span><br><span class="line">        &amp;buffer_queue,                   <span class="comment">//SLDataFormat_PCM配置输出</span></span><br><span class="line">        &amp;format_pcm                      <span class="comment">//输出数据格式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="录音流程"><a href="#录音流程" class="headerlink" title="录音流程"></a>录音流程</h4><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 创建引擎</span></span><br><span class="line">SLEngineItf eng = CreateRecordSL();</span><br><span class="line"><span class="keyword">if</span> (eng) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL success！ "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL failed！ "</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建录制的对象，并且指定开放SL_IID_ANDROIDSIMPLEBUFFERQUEUE这个接口</span></span><br><span class="line">const SLInterfaceID id[<span class="number">1</span>] = &#123;SL_IID_ANDROIDSIMPLEBUFFERQUEUE&#125;;</span><br><span class="line">const SLboolean req[<span class="number">1</span>] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line"><span class="function"><span class="title">re</span> = (*eng)-&gt;</span>CreateAudioRecorder(eng,        <span class="comment">//引擎接口</span></span><br><span class="line">                                 &amp;recorder_object,   <span class="comment">//录制对象地址，用于传出对象</span></span><br><span class="line">                                 &amp;data_src,          <span class="comment">//输入配置</span></span><br><span class="line">                                 &amp;audioSink,         <span class="comment">//输出配置</span></span><br><span class="line">                                 <span class="number">1</span>,                  <span class="comment">//支持的接口数量</span></span><br><span class="line">                                 id,                 <span class="comment">//具体的要支持的接口</span></span><br><span class="line">                                 req                 <span class="comment">//具体的要支持的接口是开放的还是关闭的</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioRecorder failed!"</span>);</span><br><span class="line">    return -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//实例化这个录制对象</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>Realize(recorder_object, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"Realize failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取录制接口</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>GetInterface(recorder_object, SL_IID_RECORD, &amp;recordItf);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface1 failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//获取Buffer接口</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_object)-&gt;</span>GetInterface(recorder_object, SL_IID_ANDROIDSIMPLEBUFFERQUEUE,</span><br><span class="line">                                      &amp;recorder_buffer_queue);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface2 failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//申请一块内存，注意RECORDER_FRAMES是自定义的一个宏，指的是采集的frame数量，具体还要根据你的采集格式(例如16bit)计算</span></span><br><span class="line">pcm_data = malloc(BUFFER_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置数据回调接口bqRecorderCallback，最后一个参数是可以传输自定义的上下文引用</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_buffer_queue)-&gt;</span>RegisterCallback(recorder_buffer_queue, bqRecorderCallback, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"RegisterCallback failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//设置录制器为录制状态 SL_RECORDSTATE_RECORDING</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recordItf)-&gt;</span>SetRecordState(recordItf, SL_RECORDSTATE_RECORDING);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"SetRecordState failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在设置完录制状态后一定需要先Enqueue一次，这样的话才会开始采集回调</span></span><br><span class="line"><span class="function"><span class="title">re</span> = (*recorder_buffer_queue)-&gt;</span>Enqueue(recorder_buffer_queue, pcm_data, <span class="number">8192</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"Enqueue failed!"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数据回调函数</span></span><br><span class="line"><span class="selector-tag">void</span> <span class="selector-tag">bqRecorderCallback</span>(SLAndroidSimpleBufferQueueItf bq, void *context) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">fwrite</span>(pcm_data, BUFFER_SIZE_IN_BYTES, <span class="number">1</span>, gFile);</span><br><span class="line">    <span class="comment">//取完数据，需要调用Enqueue触发下一次数据回调</span></span><br><span class="line">    (*bq)<span class="selector-tag">-</span>&gt;<span class="selector-tag">Enqueue</span>(bq, pcm_data, BUFFER_SIZE_IN_BYTES);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="播放"><a href="#播放" class="headerlink" title="播放"></a>播放</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1 创建引擎</span></span><br><span class="line">SLEngineItf eng = CreateSL();</span><br><span class="line"><span class="keyword">if</span> (eng) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL success！ "</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateSL failed！ "</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2 创建混音器</span></span><br><span class="line">SLObjectItf mix = <span class="keyword">NULL</span>;</span><br><span class="line">SLresult re = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">re = (*eng)-&gt;CreateOutputMix(eng, &amp;mix, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"SL_RESULT_SUCCESS failed!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">re = (*mix)-&gt;Realize(mix, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"(*mix)-&gt;Realize failed!"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">SLDataLocator_OutputMix outmix = &#123;SL_DATALOCATOR_OUTPUTMIX, mix&#125;;</span><br><span class="line">SLDataSink audioSink = &#123;&amp;outmix, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3 配置音频信息</span></span><br><span class="line"><span class="comment">//数据定位器 就是定位要播放声音数据的存放位置，分为4种：内存位置，输入/输出设备位置，缓冲区队列位置，和midi缓冲区队列位置。</span></span><br><span class="line">SLDataLocator_AndroidSimpleBufferQueue que = &#123;SL_DATALOCATOR_ANDROIDSIMPLEBUFFERQUEUE, <span class="number">10</span>&#125;;</span><br><span class="line"><span class="comment">//音频格式</span></span><br><span class="line">SLDataFormat_PCM pcm = &#123;</span><br><span class="line">        SL_DATAFORMAT_PCM,</span><br><span class="line">        <span class="number">1</span>,<span class="comment">//    声道数</span></span><br><span class="line">        SL_SAMPLINGRATE_44_1,</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">        SL_PCMSAMPLEFORMAT_FIXED_16,</span><br><span class="line">        SL_SPEAKER_FRONT_LEFT,</span><br><span class="line">        SL_BYTEORDER_LITTLEENDIAN <span class="comment">//字节序，小端</span></span><br><span class="line">&#125;;</span><br><span class="line">SLDataSource ds = &#123;&amp;que, &amp;pcm&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//4 创建播放器</span></span><br><span class="line">SLObjectItf player = <span class="keyword">NULL</span>;</span><br><span class="line">SLPlayItf iplayer = <span class="keyword">NULL</span>;</span><br><span class="line">SLAndroidSimpleBufferQueueItf pcmQue = <span class="keyword">NULL</span>;</span><br><span class="line"><span class="keyword">const</span> SLInterfaceID ids[] = &#123;SL_IID_BUFFERQUEUE&#125;;</span><br><span class="line"><span class="keyword">const</span> SLboolean req[] = &#123;SL_BOOLEAN_TRUE&#125;;</span><br><span class="line">re = (*eng)-&gt;CreateAudioPlayer(eng, &amp;player, &amp;ds, &amp;audioSink,</span><br><span class="line">                               sizeof(ids) / sizeof(SLInterfaceID), ids, req);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioPlayer failed!"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    LOGE(<span class="string">"CreateAudioPlayer success!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">(*player)-&gt;Realize(player, SL_BOOLEAN_FALSE);</span><br><span class="line"><span class="comment">//获取player接口</span></span><br><span class="line">re = (*player)-&gt;GetInterface(player, SL_IID_PLAY, &amp;iplayer);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface SL_IID_PLAY failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line">re = (*player)-&gt;GetInterface(player, SL_IID_BUFFERQUEUE, &amp;pcmQue);</span><br><span class="line"><span class="keyword">if</span> (re != SL_RESULT_SUCCESS) &#123;</span><br><span class="line">    LOGE(<span class="string">"GetInterface SL_IID_BUFFERQUEUE failed!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置回调函数，播放队列空调用</span></span><br><span class="line">(*pcmQue)-&gt;RegisterCallback(pcmQue, pcmCallBack, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//5 设置为播放状态</span></span><br><span class="line">(*iplayer)-&gt;SetPlayState(iplayer, SL_PLAYSTATE_PLAYING);</span><br><span class="line"></span><br><span class="line"><span class="comment">//6 启动队列回调</span></span><br><span class="line">(*pcmQue)-&gt;Enqueue(pcmQue, <span class="string">""</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="回调保存数据"><a href="#回调保存数据" class="headerlink" title="回调保存数据"></a>回调保存数据</h4><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//回调函数</span></span><br><span class="line"><span class="keyword">void</span> pcmCallBack(SLAndroidSimpleBufferQueueItf bf, <span class="keyword">void</span> *contex) &#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> buf[<span class="number">1024</span> * <span class="number">1024</span>] = <span class="string">""</span>;</span><br><span class="line">    <span class="built_in">if</span> (feof(<span class="built_in">File</span>) == <span class="number">0</span>) &#123; <span class="comment">//没到结尾</span></span><br><span class="line">        <span class="keyword">int</span> len = (<span class="keyword">int</span>) fread(&amp;buf, <span class="number">1</span>, <span class="number">1024</span>, <span class="built_in">File</span>);</span><br><span class="line">        <span class="built_in">if</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 加入队列</span></span><br><span class="line">            (*bf)-&gt;Enqueue(bf, &amp;buf, len);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如有问题欢迎留言，<a href="https://github.com/David1840/AudioDemo" target="_blank" rel="noopener">Github源码-AudioDemo-openSLActivity</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音频" scheme="http://yoursite.com/tags/%E9%9F%B3%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(四)MediaCodec编解码AAC</title>
    <link href="http://yoursite.com/2019/01/08/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%89-MediaCodec%E7%A1%AC%E7%BC%96%E7%A1%AC%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/01/08/Android音视频-三-MediaCodec硬编硬解/</id>
    <published>2019-01-08T10:54:34.000Z</published>
    <updated>2019-01-12T06:43:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p><a href="https://david1840.github.io/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/" target="_blank" rel="noopener">Android音视频(三)FFmpeg Camera2推流直播</a></p><p>MediaCodec类可以访问底层媒体编解码框架（StageFright 或 OpenMAX），即编解码组件，它是Android基本的多媒体支持基础架构的一部分，通常和MediaExtractor、MediaSync、MediaMuxer、MediaCrypto、MediaDrm、Image、Surface和AudioTrack一起使用。它本身并不是Codec，它通过调用底层编解码组件获得了Codec的能力。</p><h2 id="MediaCodec的工作方式"><a href="#MediaCodec的工作方式" class="headerlink" title="MediaCodec的工作方式"></a>MediaCodec的工作方式</h2><p>MediaCodec处理输入数据产生输出数据。当异步处理数据时，使用一组输入和输出Buffer队列。通常，在逻辑上，客户端请求（或接收）数据后填入预先设定的空输入缓冲区，输入Buffer填满后将其传递到MediaCodec并进行编解码处理。之后MediaCodec编解码后的数据填充到一个输出Buffer中。最后，客户端请求（或接收）输出Buffer，消耗输出Buffer中的内容，用完后释放，给回MediaCodec重新填充输出数据。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/1.png" alt="图片来自网络"></p><p>必须保证输入和输出队列同时非空，即至少有一个输入Buffer和输出Buffer才能工作。</p><h2 id="MediaCodec状态周期图"><a href="#MediaCodec状态周期图" class="headerlink" title="MediaCodec状态周期图"></a>MediaCodec状态周期图</h2><p>在MediaCodec的生命周期中存在三种状态 ：Stopped、Executing、Released。</p><p>Stopped状态实际上还可以处在三种状态：Uninitialized、Configured、Error。</p><p>Executing状态也分为三种子状态：Flushed, Running、End-of-Stream。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/2.png" alt="图片来自网络"></p><p>从上图可以看出：</p><ol><li><p>当创建编解码器的时候处于未初始化状态。首先你需要调用configure(…)方法让它处于Configured状态，然后调用start()方法让其处于Executing状态。在Executing状态下，你就可以使用上面提到的缓冲区来处理数据。</p></li><li><p>Executing的状态下也分为三种子状态：Flushed, Running、End-of-Stream。在start() 调用后，编解码器处于Flushed状态，这个状态下它保存着所有的缓冲区。一旦第一个输入buffer出现了，编解码器就会自动运行到Running的状态。当带有end-of-stream标志的buffer进去后，编解码器会进入End-of-Stream状态，这种状态下编解码器不在接受输入buffer，但是仍然在产生输出的buffer。此时你可以调用flush()方法，将编解码器重置于Flushed状态。</p></li><li><p>调用stop()将编解码器返回到未初始化状态，然后可以重新配置。 完成使用编解码器后，您必须通过调用release()来释放它。</p></li><li>在极少数情况下，编解码器可能会遇到错误并转到错误状态。 这是使用来自排队操作的无效返回值或有时通过异常来传达的。 调用reset()使编解码器再次可用。 您可以从任何状态调用它来将编解码器移回未初始化状态。 否则，调用 release()动到终端释放状态。</li></ol><h2 id="MediaCodec的优缺点"><a href="#MediaCodec的优缺点" class="headerlink" title="MediaCodec的优缺点"></a>MediaCodec的优缺点</h2><p>优点：<strong>功耗低，速度快</strong></p><p>缺点：<strong>扩展性不强，不同芯片厂商提供的支持方案不同，导致程序移植性差</strong></p><p>适用场景：适合有固定的硬件方案的项目，如智能家居类；需要长时间摄像。</p><h2 id="MediaCodec-编解码实现"><a href="#MediaCodec-编解码实现" class="headerlink" title="MediaCodec 编解码实现"></a>MediaCodec 编解码实现</h2><p>做了一个Demo，使用AudioRecord录音，使用MediaCodec 编码为AAC并保存文件，然后可以从AAC解码为PCM数据，再用AudioTrack播放。</p><p><img src="/2019/01/08/Android音视频-三-MediaCodec硬编硬解/demo.png" alt="Demo截图"></p><h3 id="1、编码PCM数据，保存为AAC文件"><a href="#1、编码PCM数据，保存为AAC文件" class="headerlink" title="1、编码PCM数据，保存为AAC文件"></a>1、编码PCM数据，保存为AAC文件</h3><h4 id="初始化AudioRecord和编码器"><a href="#初始化AudioRecord和编码器" class="headerlink" title="初始化AudioRecord和编码器"></a>初始化AudioRecord和编码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioRecord</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> audioSource = MediaRecorder.AudioSource.MIC;</span><br><span class="line">    <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_IN_MONO;</span><br><span class="line">    <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    <span class="keyword">int</span> minBufferSize = AudioRecord.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line">    mAudioRecorder = <span class="keyword">new</span> AudioRecord(audioSource, sampleRate, channelConfig, audioFormat, Math.max(minBufferSize, <span class="number">2048</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化编码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioEncoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mAudioEncoder = MediaCodec.createEncoderByType(MediaFormat.MIMETYPE_AUDIO_AAC);</span><br><span class="line">        MediaFormat format = MediaFormat.createAudioFormat(MediaFormat.MIMETYPE_AUDIO_AAC, <span class="number">44100</span>, <span class="number">1</span>);</span><br><span class="line">        format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>);<span class="comment">//比特率</span></span><br><span class="line">        format.setInteger(MediaFormat.KEY_MAX_INPUT_SIZE, MAX_BUFFER_SIZE);</span><br><span class="line">        mAudioEncoder.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, MediaCodec.CONFIGURE_FLAG_ENCODE);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioEncoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"create mediaEncode failed"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mAudioEncoder.start(); <span class="comment">// 启动MediaCodec,等待传入数据</span></span><br><span class="line">    encodeInputBuffers = mAudioEncoder.getInputBuffers(); <span class="comment">//上面介绍的输入和输出Buffer队列</span></span><br><span class="line">    encodeOutputBuffers = mAudioEncoder.getOutputBuffers();</span><br><span class="line">    mAudioEncodeBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="开始录音、编码"><a href="#开始录音、编码" class="headerlink" title="开始录音、编码"></a>开始录音、编码</h4><p>使用线程池，两条线程，一个线程去录音，另一个线程做编码操作。录音线程会将PCM数据存入一个队列中，编码线程从队列中取出数据编码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 开启录音线程</span></span><br><span class="line">mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        startRecorder();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 开启编码线程</span></span><br><span class="line">mExecutorService.submit(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        encodePCM();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 将PCM数据存入队列</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putPCMData</span><span class="params">(<span class="keyword">byte</span>[] pcmChunk)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"putPCMData"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            queue.put(pcmChunk);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 从队列取出PCM数据</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] getPCMData() &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> queue.take();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 添加ADTS头，如果要与视频流合并就不用添加，单独AAC文件就需要添加，否则无法正常播放</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addADTStoPacket</span><span class="params">(<span class="keyword">int</span> sampleRateType, <span class="keyword">byte</span>[] packet, <span class="keyword">int</span> packetLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> profile = <span class="number">2</span>; <span class="comment">// AAC LC</span></span><br><span class="line">        <span class="keyword">int</span> chanCfg = <span class="number">2</span>; <span class="comment">// CPE</span></span><br><span class="line"></span><br><span class="line">        packet[<span class="number">0</span>] = (<span class="keyword">byte</span>) <span class="number">0xFF</span>;</span><br><span class="line">        packet[<span class="number">1</span>] = (<span class="keyword">byte</span>) <span class="number">0xF9</span>;</span><br><span class="line">        packet[<span class="number">2</span>] = (<span class="keyword">byte</span>) (((profile - <span class="number">1</span>) &lt;&lt; <span class="number">6</span>) + (sampleRateType &lt;&lt; <span class="number">2</span>) + (chanCfg &gt;&gt; <span class="number">2</span>));</span><br><span class="line">        packet[<span class="number">3</span>] = (<span class="keyword">byte</span>) (((chanCfg &amp; <span class="number">3</span>) &lt;&lt; <span class="number">6</span>) + (packetLen &gt;&gt; <span class="number">11</span>));</span><br><span class="line">        packet[<span class="number">4</span>] = (<span class="keyword">byte</span>) ((packetLen &amp; <span class="number">0x7FF</span>) &gt;&gt; <span class="number">3</span>);</span><br><span class="line">        packet[<span class="number">5</span>] = (<span class="keyword">byte</span>) (((packetLen &amp; <span class="number">7</span>) &lt;&lt; <span class="number">5</span>) + <span class="number">0x1F</span>);</span><br><span class="line">        packet[<span class="number">6</span>] = (<span class="keyword">byte</span>) <span class="number">0xFC</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="音频数据"><a href="#音频数据" class="headerlink" title="音频数据"></a>音频数据</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取音频数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecorder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mFilePath = Environment.getExternalStorageDirectory().getAbsolutePath() + <span class="string">"/RecorderTest/"</span> + System.currentTimeMillis() + <span class="string">".aac"</span>;</span><br><span class="line">        mAudioFile = <span class="keyword">new</span> File(mFilePath);</span><br><span class="line">        <span class="keyword">if</span> (!mAudioFile.getParentFile().exists()) &#123;</span><br><span class="line">            mAudioFile.getParentFile().mkdirs();</span><br><span class="line">        &#125;</span><br><span class="line">        mAudioFile.createNewFile();</span><br><span class="line">        mFileOutputStream = <span class="keyword">new</span> FileOutputStream(mAudioFile);</span><br><span class="line">        mAudioBos = <span class="keyword">new</span> BufferedOutputStream(mFileOutputStream, <span class="number">200</span> * <span class="number">1024</span>);</span><br><span class="line">        mAudioRecorder.startRecording();</span><br><span class="line"></span><br><span class="line">        start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (mIsRecording) &#123;</span><br><span class="line">            <span class="keyword">int</span> read = mAudioRecorder.read(mBuffer, <span class="number">0</span>, <span class="number">2048</span>);</span><br><span class="line">            <span class="keyword">if</span> (read &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">byte</span>[] audio = <span class="keyword">new</span> <span class="keyword">byte</span>[read];</span><br><span class="line">                System.arraycopy(mBuffer, <span class="number">0</span>, audio, <span class="number">0</span>, read);</span><br><span class="line">                putPCMData(audio); <span class="comment">// PCM数据放入队列，等待编码</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (mAudioRecorder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAudioRecorder.release();</span><br><span class="line">            mAudioRecorder = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h5><p>从队列中循环取出数据，MediaCodec 编码，将编码后的数据写入文件中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编码PCM</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">encodePCM</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inputIndex;</span><br><span class="line">    ByteBuffer inputBuffer;</span><br><span class="line">    <span class="keyword">int</span> outputIndex;</span><br><span class="line">    ByteBuffer outputBuffer;</span><br><span class="line">    <span class="keyword">byte</span>[] chunkAudio;</span><br><span class="line">    <span class="keyword">int</span> outBitSize;</span><br><span class="line">    <span class="keyword">int</span> outPacketSize;</span><br><span class="line">    <span class="keyword">byte</span>[] chunkPCM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (mIsRecording || !queue.isEmpty()) &#123;</span><br><span class="line">        chunkPCM = getPCMData();<span class="comment">//获取解码器所在线程输出的数据 代码后边会贴上</span></span><br><span class="line">        <span class="keyword">if</span> (chunkPCM == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        inputIndex = mAudioEncoder.dequeueInputBuffer(-<span class="number">1</span>);<span class="comment">//同解码器</span></span><br><span class="line">        <span class="keyword">if</span> (inputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            inputBuffer = encodeInputBuffers[inputIndex];<span class="comment">//同解码器</span></span><br><span class="line">            inputBuffer.clear();<span class="comment">//同解码器</span></span><br><span class="line">            inputBuffer.limit(chunkPCM.length);</span><br><span class="line">            inputBuffer.put(chunkPCM);<span class="comment">//PCM数据填充给inputBuffer</span></span><br><span class="line">            mAudioEncoder.queueInputBuffer(inputIndex, <span class="number">0</span>, chunkPCM.length, <span class="number">0</span>, <span class="number">0</span>);<span class="comment">//通知编码器 编码</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        outputIndex = mAudioEncoder.dequeueOutputBuffer(mAudioEncodeBufferInfo, <span class="number">10000</span>);</span><br><span class="line">        <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            outBitSize = mAudioEncodeBufferInfo.size;</span><br><span class="line">            outPacketSize = outBitSize + <span class="number">7</span>;<span class="comment">//7为ADTS头部的大小</span></span><br><span class="line">            outputBuffer = encodeOutputBuffers[outputIndex];<span class="comment">//拿到输出Buffer</span></span><br><span class="line">            outputBuffer.position(mAudioEncodeBufferInfo.offset);</span><br><span class="line">            outputBuffer.limit(mAudioEncodeBufferInfo.offset + outBitSize);</span><br><span class="line">            chunkAudio = <span class="keyword">new</span> <span class="keyword">byte</span>[outPacketSize];</span><br><span class="line">            addADTStoPacket(<span class="number">44100</span>, chunkAudio, outPacketSize);<span class="comment">//添加ADTS</span></span><br><span class="line">            outputBuffer.get(chunkAudio, <span class="number">7</span>, outBitSize);<span class="comment">//将编码得到的AAC数据 取出到byte[]中 偏移量offset=7</span></span><br><span class="line">            outputBuffer.position(mAudioEncodeBufferInfo.offset);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                mAudioBos.write(chunkAudio, <span class="number">0</span>, chunkAudio.length);<span class="comment">//BufferOutputStream 将文件保存到内存卡中 *.aac</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            mAudioEncoder.releaseOutputBuffer(outputIndex, <span class="keyword">false</span>);</span><br><span class="line">            outputIndex = mAudioEncoder.dequeueOutputBuffer(mAudioEncodeBufferInfo, <span class="number">10000</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopRecorder();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2、解码AAC-AudioTrack播放"><a href="#2、解码AAC-AudioTrack播放" class="headerlink" title="2、解码AAC AudioTrack播放"></a>2、解码AAC AudioTrack播放</h3><h4 id="初始化AudioTrack和解码器"><a href="#初始化AudioTrack和解码器" class="headerlink" title="初始化AudioTrack和解码器"></a>初始化AudioTrack和解码器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化AudioTrack，等待播放数据</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioTrack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> streamType = AudioManager.STREAM_MUSIC;</span><br><span class="line">    <span class="keyword">int</span> sampleRate = <span class="number">44100</span>;</span><br><span class="line">    <span class="keyword">int</span> channelConfig = AudioFormat.CHANNEL_OUT_MONO;</span><br><span class="line">    <span class="keyword">int</span> audioFormat = AudioFormat.ENCODING_PCM_16BIT;</span><br><span class="line">    <span class="keyword">int</span> mode = AudioTrack.MODE_STREAM;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> minBufferSize = AudioTrack.getMinBufferSize(sampleRate, channelConfig, audioFormat);</span><br><span class="line"></span><br><span class="line">    audioTrack = <span class="keyword">new</span> AudioTrack(streamType, sampleRate, channelConfig, audioFormat,</span><br><span class="line">            Math.max(minBufferSize, <span class="number">2048</span>), mode);</span><br><span class="line">    audioTrack.play();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 初始化解码器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAudioDecoder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mMediaExtractor = <span class="keyword">new</span> MediaExtractor();</span><br><span class="line">        mMediaExtractor.setDataSource(mFilePath);</span><br><span class="line"></span><br><span class="line">        MediaFormat format = mMediaExtractor.getTrackFormat(<span class="number">0</span>);</span><br><span class="line">        String mime = format.getString(MediaFormat.KEY_MIME);</span><br><span class="line">        <span class="keyword">if</span> (mime.startsWith(<span class="string">"audio"</span>)) &#123;<span class="comment">//获取音频轨道</span></span><br><span class="line">            mMediaExtractor.selectTrack(<span class="number">0</span>);<span class="comment">//选择此音频轨道</span></span><br><span class="line">            format.setString(MediaFormat.KEY_MIME, <span class="string">"audio/mp4a-latm"</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_CHANNEL_COUNT, <span class="number">1</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_SAMPLE_RATE, <span class="number">0</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_BIT_RATE, <span class="number">96000</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_IS_ADTS, <span class="number">1</span>);</span><br><span class="line">            format.setInteger(MediaFormat.KEY_AAC_PROFILE, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">            mAudioDecoder = MediaCodec.createDecoderByType(mime);<span class="comment">//创建Decode解码器</span></span><br><span class="line">            mAudioDecoder.configure(format, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAudioDecoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"mAudioDecoder is null"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mAudioDecoder.start();<span class="comment">//启动MediaCodec ，等待传入数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="解码并播放"><a href="#解码并播放" class="headerlink" title="解码并播放"></a>解码并播放</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeAndPlay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> isFinish = <span class="keyword">false</span>;</span><br><span class="line">    MediaCodec.BufferInfo decodeBufferInfo = <span class="keyword">new</span> MediaCodec.BufferInfo();</span><br><span class="line">    <span class="keyword">while</span> (!isFinish &amp;&amp; mIsPalying) &#123;</span><br><span class="line">        <span class="keyword">int</span> inputIdex = mAudioDecoder.dequeueInputBuffer(<span class="number">10000</span>);<span class="comment">//获取可用的inputBuffer -1代表一直等待，0表示不等待 10000表示10秒超时</span></span><br><span class="line">        <span class="keyword">if</span> (inputIdex &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            isFinish = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ByteBuffer inputBuffer = mAudioDecoder.getInputBuffer(inputIdex);</span><br><span class="line">        inputBuffer.clear();<span class="comment">//清空之前传入inputBuffer内的数据</span></span><br><span class="line">        <span class="keyword">int</span> samplesize = mMediaExtractor.readSampleData(inputBuffer, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (samplesize &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            mAudioDecoder.queueInputBuffer(inputIdex, <span class="number">0</span>, samplesize, <span class="number">0</span>, <span class="number">0</span>); <span class="comment">//通知解码器 解码</span></span><br><span class="line">            mMediaExtractor.advance(); <span class="comment">//MediaExtractor移动到下一取样处</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            isFinish = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> outputIndex = mAudioDecoder.dequeueOutputBuffer(decodeBufferInfo, <span class="number">10000</span>);<span class="comment">//获取解码得到的byte[]数据</span></span><br><span class="line"></span><br><span class="line">        ByteBuffer outputBuffer;</span><br><span class="line">        <span class="keyword">byte</span>[] chunkPCM;</span><br><span class="line">        <span class="comment">//每次解码完成的数据不一定能一次吐出 所以用while循环，保证解码器吐出所有数据</span></span><br><span class="line">        <span class="keyword">while</span> (outputIndex &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            outputBuffer = mAudioDecoder.getOutputBuffer(outputIndex);</span><br><span class="line">            chunkPCM = <span class="keyword">new</span> <span class="keyword">byte</span>[decodeBufferInfo.size];</span><br><span class="line">            outputBuffer.get(chunkPCM);</span><br><span class="line">            outputBuffer.clear();<span class="comment">//数据取出后一定记得清空此Buffer MediaCodec是循环使用这些Buffer的，不清空下次会得到同样的数</span></span><br><span class="line">            <span class="comment">// 播放解码后的PCM数据</span></span><br><span class="line">            audioTrack.write(chunkPCM, <span class="number">0</span>, decodeBufferInfo.size);</span><br><span class="line">            mAudioDecoder.releaseOutputBuffer(outputIndex, <span class="keyword">false</span>);</span><br><span class="line">            outputIndex = mAudioDecoder.dequeueOutputBuffer(decodeBufferInfo, <span class="number">10000</span>);<span class="comment">//再次获取数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    stopPlay();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Demo完成，手机测试效果不错。MediaCodec的使用要比我预想的复杂，网上查了好久才完成这个Demo，希望能帮到需要的人。</p><p>如有问题欢迎留言，<a href="https://github.com/David1840/AudioDemo" target="_blank" rel="noopener">Github源码 - MediaCodecActivity</a>  </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="MediaCodec" scheme="http://yoursite.com/tags/MediaCodec/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(三)FFmpeg Camera2推流直播</title>
    <link href="http://yoursite.com/2019/01/07/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%9B%9B-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/07/Android音视频-四-FFmpeg-Camera2推流直播/</id>
    <published>2019-01-07T03:07:25.000Z</published>
    <updated>2019-01-10T04:02:13.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p><a href="https://david1840.github.io/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E9%9F%B3%E9%A2%91AudioRecord%E5%92%8CAudioTrack/" target="_blank" rel="noopener">Android音视频(二)音频AudioRecord和AudioTrack</a></p><p>自己花了点时间实现了一个使用FFmpeg将Camera2视频数据推送到RTMP服务的简单Demo，在这里分享下，里面用到知识很多都是之前博客中用到的，难度不大。</p><h2 id="1、-定义方法"><a href="#1、-定义方法" class="headerlink" title="1、 定义方法"></a>1、 定义方法</h2><p>定义了三个JNI方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FFmpegHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FFmpegHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonInstance</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> FFmpegHandler INSTANCE = <span class="keyword">new</span> FFmpegHandler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> FFmpegHandler <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonInstance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"ffmpeg-handler"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化参数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">init</span><span class="params">(String outUrl)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//推流，将Y、U、V数据分开传递</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">pushCameraData</span><span class="params">(<span class="keyword">byte</span>[] buffer,<span class="keyword">int</span> ylen,<span class="keyword">byte</span>[] ubuffer,<span class="keyword">int</span> ulen,<span class="keyword">byte</span>[] vbuffer,<span class="keyword">int</span> vlen)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//结束</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">int</span> <span class="title">close</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2、Camera2实时数据"><a href="#2、Camera2实时数据" class="headerlink" title="2、Camera2实时数据"></a>2、Camera2实时数据</h2><p>具体使用可查看<a href="https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D%AE/" target="_blank" rel="noopener">Android音视频(一) Camera2 API采集数据</a></p><p>将ImageReader作为预览请求的Target之一，这样我们就可以将预览的数据拿到在onImageAvailable中进行处理推送。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mImageReader = ImageReader.newInstance(<span class="number">640</span>, <span class="number">480</span>,ImageFormat.YUV_420_888, <span class="number">1</span>); </span><br><span class="line">mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Surface imageSurface = mImageReader.getSurface();</span><br><span class="line"></span><br><span class="line">mPreviewRequestBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line"></span><br><span class="line">mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line">mPreviewRequestBuilder.addTarget(imageSurface);</span><br></pre></td></tr></table></figure><p>将获取的Image数据解析为YUV数据，Y、U、V数据分别存储。具体请看<a href="https://david1840.github.io/2018/12/20/YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8EYUV_420_888/" target="_blank" rel="noopener">YUV数据格式与YUV_420_888</a>。</p><p>目前这块暂时这样写着，网上的博客都比较旧了，有点不太合适，我想应该还会有更好的方法，后面再做优化。（或者这块你有什么好的处理方法，欢迎留言）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.OnImageAvailableListener mOnImageAvailableListener</span><br><span class="line">            = <span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">            Image image = reader.acquireLatestImage();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (image == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Image.Plane[] planes = image.getPlanes();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> width = image.getWidth();</span><br><span class="line">            <span class="keyword">int</span> height = image.getHeight();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// Y、U、V数据</span></span><br><span class="line">            <span class="keyword">byte</span>[] yBytes = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height];</span><br><span class="line">            <span class="keyword">byte</span> uBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height / <span class="number">4</span>];</span><br><span class="line">            <span class="keyword">byte</span> vBytes[] = <span class="keyword">new</span> <span class="keyword">byte</span>[width * height / <span class="number">4</span>];</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//目标数组的装填到的位置</span></span><br><span class="line">            <span class="keyword">int</span> dstIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> uIndex = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> vIndex = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> pixelsStride, rowStride;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; planes.length; i++) &#123;</span><br><span class="line">                pixelsStride = planes[i].getPixelStride();</span><br><span class="line">                rowStride = planes[i].getRowStride();</span><br><span class="line"></span><br><span class="line">                ByteBuffer buffer = planes[i].getBuffer();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//如果pixelsStride==2，一般的Y的buffer长度=640*480，UV的长度=640*480/2-1</span></span><br><span class="line">                <span class="comment">//源数据的索引，y的数据是byte中连续的，u的数据是v向左移以为生成的，两者都是偶数位为有效数据</span></span><br><span class="line">                <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.capacity()];</span><br><span class="line">                buffer.get(bytes);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> srcIndex = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//直接取出来所有Y的有效区域，也可以存储成一个临时的bytes，到下一步再copy</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height; j++) &#123;</span><br><span class="line">                        System.arraycopy(bytes, srcIndex, yBytes, dstIndex, width);</span><br><span class="line">                        srcIndex += rowStride;</span><br><span class="line">                        dstIndex += width;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="comment">//根据pixelsStride取相应的数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; width / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            uBytes[uIndex++] = bytes[srcIndex];</span><br><span class="line">                            srcIndex += pixelsStride;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (pixelsStride == <span class="number">2</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pixelsStride == <span class="number">1</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width / <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (i == <span class="number">2</span>) &#123;</span><br><span class="line">                    <span class="comment">//根据pixelsStride取相应的数据</span></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; height / <span class="number">2</span>; j++) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; width / <span class="number">2</span>; k++) &#123;</span><br><span class="line">                            vBytes[vIndex++] = bytes[srcIndex];</span><br><span class="line">                            srcIndex += pixelsStride;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (pixelsStride == <span class="number">2</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width;</span><br><span class="line">                        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pixelsStride == <span class="number">1</span>) &#123;</span><br><span class="line">                            srcIndex += rowStride - width / <span class="number">2</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将YUV数据交给C层去处理。</span></span><br><span class="line">            FFmpegHandler.getInstance().pushCameraData(yBytes, yBytes.length, uBytes, uBytes.length, vBytes, vBytes.length);</span><br><span class="line">            image.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h2 id="3、初始化FFmpeg"><a href="#3、初始化FFmpeg" class="headerlink" title="3、初始化FFmpeg"></a>3、初始化FFmpeg</h2><p>直播推送的过程整体就是一个先将视频数据编码，再将编码后的数据写入数据流中推送给服务器的过程。</p><p>下面初始化的过程就是准备好数据编码器和一条已经连上服务器的数据流</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_com_david_camerapush_ffmpeg_FFmpegHandler_init</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance, jstring url) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *out_url = (*jniEnv)-&gt;GetStringUTFChars(jniEnv, url, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算yuv数据的长度</span></span><br><span class="line">    yuv_width = width;</span><br><span class="line">    yuv_height = height;</span><br><span class="line">    y_length = width * height;</span><br><span class="line">    uv_length = width * height / <span class="number">4</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//output initialize</span></span><br><span class="line">    <span class="keyword">int</span> ret = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="string">"flv"</span>, out_url);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avformat_alloc_output_context2 error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化H264编码器</span></span><br><span class="line">    pCodec = avcodec_find_encoder(AV_CODEC_ID_H264);</span><br><span class="line">    <span class="keyword">if</span> (!pCodec) &#123;</span><br><span class="line">        LOGE(<span class="string">"Can not find encoder!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodecCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="comment">//编码器的ID号，这里为264编码器</span></span><br><span class="line">    pCodecCtx-&gt;codec_id = pCodec-&gt;id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//像素的格式，也就是说采用什么样的色彩空间来表明一个像素点，这里使用YUV420P</span></span><br><span class="line">    pCodecCtx-&gt;pix_fmt = AV_PIX_FMT_YUV420P;</span><br><span class="line">    <span class="comment">//编码器编码的数据类型</span></span><br><span class="line">    pCodecCtx-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    <span class="comment">//编码目标的视频帧大小，以像素为单位</span></span><br><span class="line">    pCodecCtx-&gt;width = width;</span><br><span class="line">    pCodecCtx-&gt;height = height;</span><br><span class="line">    <span class="comment">//帧频</span></span><br><span class="line">    pCodecCtx-&gt;framerate = (AVRational) &#123;<span class="number">15</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="comment">//时间基</span></span><br><span class="line">    pCodecCtx-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, <span class="number">15</span>&#125;;</span><br><span class="line">    <span class="comment">//目标的码率，即采样的码率；显然，采样码率越大，视频大小越大</span></span><br><span class="line">    pCodecCtx-&gt;bit_rate = <span class="number">400000</span>;</span><br><span class="line">    pCodecCtx-&gt;gop_size = <span class="number">50</span>;</span><br><span class="line">    <span class="comment">/* Some formats want stream headers to be separate. */</span></span><br><span class="line">    <span class="keyword">if</span> (ofmt_ctx-&gt;oformat-&gt;flags &amp; AVFMT_GLOBALHEADER)</span><br><span class="line">        pCodecCtx-&gt;flags |= AV_CODEC_FLAG_GLOBAL_HEADER;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//H264 codec param</span></span><br><span class="line">    pCodecCtx-&gt;qcompress = <span class="number">0.6</span>;</span><br><span class="line">    <span class="comment">//最大和最小量化系数</span></span><br><span class="line">    pCodecCtx-&gt;qmin = <span class="number">10</span>;</span><br><span class="line">    pCodecCtx-&gt;qmax = <span class="number">51</span>;</span><br><span class="line">    <span class="comment">//Optional Param</span></span><br><span class="line">    <span class="comment">//两个非B帧之间允许出现多少个B帧数</span></span><br><span class="line">    <span class="comment">//设置0表示不使用B帧，b 帧越多，图片越小</span></span><br><span class="line">    pCodecCtx-&gt;max_b_frames = <span class="number">0</span>;</span><br><span class="line">    AVDictionary *param = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//H.264</span></span><br><span class="line">    <span class="keyword">if</span> (pCodecCtx-&gt;codec_id == AV_CODEC_ID_H264) &#123;</span><br><span class="line">        av_dict_set(&amp;param, <span class="string">"preset"</span>, <span class="string">"superfast"</span>, <span class="number">0</span>); <span class="comment">//x264编码速度的选项</span></span><br><span class="line">        av_dict_set(&amp;param, <span class="string">"tune"</span>, <span class="string">"zerolatency"</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开编码器</span></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodecCtx, pCodec, &amp;param) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open encoder!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 新建传输流，即将要直播的视频流</span></span><br><span class="line">    video_st = avformat_new_stream(ofmt_ctx, pCodec);</span><br><span class="line">    <span class="keyword">if</span> (video_st == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    video_st-&gt;time_base = (AVRational) &#123;<span class="number">25</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    video_st-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    avcodec_parameters_from_context(video_st-&gt;codecpar, pCodecCtx);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打开数据流，表示与rtmp服务器连接</span></span><br><span class="line">    <span class="keyword">int</span> err = avio_open(&amp;ofmt_ctx-&gt;pb, out_url, AVIO_FLAG_READ_WRITE);</span><br><span class="line">    <span class="keyword">if</span> (err &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"Failed to open output：%s"</span>, av_err2str(err));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write File Header</span></span><br><span class="line">    avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">    av_init_packet(&amp;enc_pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4、开始传输"><a href="#4、开始传输" class="headerlink" title="4、开始传输"></a>4、开始传输</h2><p>对YUV数据编码，并将编码后数据写入准备好的直播流中。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line">JNIEXPORT jint JNICALL Java_com_david_camerapush_ffmpeg_FFmpegHandler_pushCameraData</span><br><span class="line">        (JNIEnv *jniEnv, jobject instance, jbyteArray yArray, jint yLen, jbyteArray uArray, jint uLen, jbyteArray vArray, jint vLen) &#123;</span><br><span class="line">    jbyte *yin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, yArray, <span class="literal">NULL</span>);</span><br><span class="line">    jbyte *uin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, uArray, <span class="literal">NULL</span>);</span><br><span class="line">    jbyte *vin = (*jniEnv)-&gt;GetByteArrayElements(jniEnv, vArray, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 初始化Frame</span></span><br><span class="line">    pFrameYUV = av_frame_alloc();</span><br><span class="line">    <span class="comment">// 通过指定像素格式、图像宽、图像高来计算所需的内存大小</span></span><br><span class="line">    <span class="keyword">int</span> picture_size = av_image_get_buffer_size(pCodecCtx-&gt;pix_fmt, pCodecCtx-&gt;width,pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line">    <span class="comment">//分配指定大小的内存空间</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *buffers = (<span class="keyword">uint8_t</span> *) av_malloc(picture_size);</span><br><span class="line">    <span class="comment">//此函数类似于格式化已经申请的内存，即通过av_malloc()函数申请的内存空间。</span></span><br><span class="line">    av_image_fill_arrays(pFrameYUV-&gt;data, pFrameYUV-&gt;linesize, buffers, pCodecCtx-&gt;pix_fmt,pCodecCtx-&gt;width, pCodecCtx-&gt;height, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Frame中数据填充</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">0</span>], yin, (<span class="keyword">size_t</span>) yLen); <span class="comment">//Y</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">1</span>], uin, (<span class="keyword">size_t</span>) uLen); <span class="comment">//U</span></span><br><span class="line">    <span class="built_in">memcpy</span>(pFrameYUV-&gt;data[<span class="number">2</span>], vin, (<span class="keyword">size_t</span>) vLen); <span class="comment">//V</span></span><br><span class="line">    pFrameYUV-&gt;pts = count;</span><br><span class="line">    pFrameYUV-&gt;format = AV_PIX_FMT_YUV420P;</span><br><span class="line">    pFrameYUV-&gt;width = yuv_width;</span><br><span class="line">    pFrameYUV-&gt;height = yuv_height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化AVPacket</span></span><br><span class="line">    enc_pkt.data = <span class="literal">NULL</span>;</span><br><span class="line">    enc_pkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始编码YUV数据</span></span><br><span class="line">    ret = avcodec_send_frame(pCodecCtx, pFrameYUV);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avcodec_send_frame error"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取编码后的H264数据</span></span><br><span class="line">    ret = avcodec_receive_packet(pCodecCtx, &amp;enc_pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span> || enc_pkt.size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"avcodec_receive_packet error %s"</span>, av_err2str(ret));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    enc_pkt.stream_index = video_st-&gt;index;</span><br><span class="line">    enc_pkt.pts = count * (video_st-&gt;time_base.den) / ((video_st-&gt;time_base.num) * fps);</span><br><span class="line">    enc_pkt.dts = enc_pkt.pts;</span><br><span class="line">    enc_pkt.duration = (video_st-&gt;time_base.den) / ((video_st-&gt;time_base.num) * fps);</span><br><span class="line">    enc_pkt.pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 往直播流写数据</span></span><br><span class="line">    ret = av_interleaved_write_frame(ofmt_ctx, &amp;enc_pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret != <span class="number">0</span>) &#123;</span><br><span class="line">        LOGE(<span class="string">"av_interleaved_write_frame failed"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    count++;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//释放内存，Java写多了经常会忘记这块**</span></span><br><span class="line">    av_packet_unref(&amp;enc_pkt);</span><br><span class="line">    av_frame_free(&amp;pFrameYUV);</span><br><span class="line">    av_free(buffers);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, yArray, yin, <span class="number">0</span>);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, uArray, uin, <span class="number">0</span>);</span><br><span class="line">    (*jniEnv)-&gt;ReleaseByteArrayElements(jniEnv, vArray, vin, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="效果"><a href="#效果" class="headerlink" title="效果"></a>效果</h2><p><img src="/2019/01/07/Android音视频-四-FFmpeg-Camera2推流直播/push.jpg" alt=""></p><p>这是Demo运行后的结果，推送视频OK，但是可能会有2到3秒的延迟（可能也跟网速有关）。目前就做到这种程度，后面会优化延迟、音频直播、音视频同步等都会慢慢加上去。</p><p><a href="https://github.com/David1840/CameraPush" target="_blank" rel="noopener">Github源码 — CameraPush</a></p><p><strong>Tips:</strong></p><p><a href="https://david1840.github.io/2018/11/23/FFmpeg%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/" target="_blank" rel="noopener">Mac 下搭建RTMP直播</a></p><p>图片中使用的在Windows下的<a href="https://github.com/illuspas/nginx-rtmp-win32" target="_blank" rel="noopener">nginx-rtmp-win32</a>，不需要编译，点击exe就可以运行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/01/04/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%80-Camera2-API%E9%87%87%E9%9B%86%E6%95%B0%E6%8D
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="直播" scheme="http://yoursite.com/tags/%E7%9B%B4%E6%92%AD/"/>
    
  </entry>
  
</feed>
