<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-03T07:03:17.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android音视频(三)FFmpeg Camera2推流直播</title>
    <link href="http://yoursite.com/2019/01/10/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%B8%89-FFmpeg-Camera2%E6%8E%A8%E6%B5%81%E7%9B%B4%E6%92%AD/"/>
    <id>http://yoursite.com/2019/01/10/Android音视频-三-FFmpeg-Camera2推流直播/</id>
    <published>2019-01-10T07:02:33.000Z</published>
    <updated>2019-01-03T07:03:17.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>Android音视频(二)使用FFmpeg录制视频</title>
    <link href="http://yoursite.com/2019/01/06/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E4%BA%8C-%E4%BD%BF%E7%94%A8FFmpeg%E5%BD%95%E5%88%B6%E8%A7%86%E9%A2%91/"/>
    <id>http://yoursite.com/2019/01/06/Android音视频-二-使用FFmpeg录制视频/</id>
    <published>2019-01-06T07:00:48.000Z</published>
    <updated>2019-01-03T07:03:03.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
  </entry>
  
  <entry>
    <title>写给安卓程序员的C/C++编译入门(交叉编译，Makefile)</title>
    <link href="http://yoursite.com/2019/01/05/%E5%AE%89%E5%8D%93%E7%A8%8B%E5%BA%8F%E5%91%98%E9%9C%80%E8%A6%81%E7%9F%A5%E9%81%93%E7%9A%84%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%92%8CMakefile%E7%9F%A5%E8%AF%86/"/>
    <id>http://yoursite.com/2019/01/05/安卓程序员需要知道的交叉编译和Makefile知识/</id>
    <published>2019-01-05T07:54:16.000Z</published>
    <updated>2019-01-03T06:35:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近一直在和Linux C开发打交道，开发过程中会用到交叉编译和Makefile相关知识，但是对这块真的是没有了解，所以在网上搜索，找到一篇不错的博客。本文转载自该博客<a href="https://www.jianshu.com/p/3ba79f1ade39" target="_blank" rel="noopener">写给安卓程序员的C/C++编译入门(作者：嘉伟咯)</a>。如有侵权请联系删除。</p><h2 id="为什么要学C-C-编译"><a href="#为什么要学C-C-编译" class="headerlink" title="为什么要学C/C++编译"></a>为什么要学C/C++编译</h2><p>很多的安卓程序员可能都会用Android Studio写一些简单的C/C++代码,然后通过jni去调用,但是对C/C++是如何编译的其实并没有什么概念.有人可能会问,为什么安卓程序员会需要了解C/C++是如何编译的呢?</p><p>我一直都认为,要成为一个真正的高级安卓应用开发工程师,安卓源码和C/C++是两座绕不过的大山.安卓源码自然不必多说,而C/C++流行了几十年,存在着许多优秀的开源项目,我们在处理一些特定的需求的时候,可能会需要使用到它们.如脚本语言Lua,计算机视觉库OpenCV,音视频编解码库ffmpeg,谷歌的gRPC,国产游戏引擎Cocos2dx…有些库提供了完整的安卓接口,有些提供了部分安卓接口,有些则没有.在做一些高级功能时,我们常常需要使用源码,通过裁剪和交叉编译,才能编译出可以在安卓上使用的so库.总之,安卓做深做精总避不开C/C++交叉编译。</p><h2 id="C-C-编译器"><a href="#C-C-编译器" class="headerlink" title="C/C++编译器"></a>C/C++编译器</h2><p>类似java编译器javac可以将java代码编译成class文件,C/C++也有gcc、g++、clang等多种编译器可以用于编译C/C++代码.这里我们用gcc来举例。</p><p>gcc原名为GNU C 语言编译器(GNU C Compiler),因为它原本只能处理C语言.但GCC很快地扩展,变得可处理C++。后来又扩展能够支持更多编程语言,如Fortran、Pascal、Objective-C、Java、Ada、Go以及各类处理器架构上的汇编语言等,所以改名GNU编译器套件(GNU Compiler Collection)。</p><p>使用gcc其实只需要一个命令就能将一个c文件编译成可运行程序了:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -o test</span><br></pre></td></tr></table></figure><p>通过上面这条命令可以将test.c编译成可运行程序test.但是其实C/C++的编译是经过了好几个步骤的,我这边先给大家大概的讲一讲。</p><h3 id="C-C-的编译流程"><a href="#C-C-的编译流程" class="headerlink" title="C/C++的编译流程"></a>C/C++的编译流程</h3><p>C/C++的编译可以分为下面几个步骤:</p><p><img src="/2019/01/05/安卓程序员需要知道的交叉编译和Makefile知识/c-c++.png" alt=""></p><h4 id="预处理"><a href="#预处理" class="headerlink" title="预处理"></a>预处理</h4><p>相信学过C/C++的同学都知道”宏”这个东西,它在编译的时候会被展开替换成实际的代码,这个展开的步骤就是在预处理的时候进行的.当然,预处理并不仅仅只是做宏的展开,它还做了类似头文件插入、删除注释等操作.</p><p>预处理之后的产品依然还是C/C++代码,它在代码的逻辑上和输入的C/C++源代码是完全一样的.</p><p>我们来举一个简单的例子,写一个test.h文件和一个test.c文件:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> TEST_H            </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TEST_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> A 1     </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> B 2        </span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法的声明</span></span><br><span class="line"><span class="comment"> */</span>               </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc,<span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    add(A, B);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;                 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以通过下面这个gcc命令预处理test.c文件,并且把预处理结果写到test.i:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -<span class="keyword">E</span> <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="built_in">i</span></span><br></pre></td></tr></table></figure><p>然后就能看到预处理之后的test.c到底长什么样子了:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>可以看到这里它把test.h的内容(add方法的声明)插入到了test.c的代码中,然后将A、B两个宏展开成了1和2,将注释去掉了,还在头部加上了一些信息.但是光看代码逻辑,和之前我们写的代码是完全一样的.</p><h4 id="汇编代码"><a href="#汇编代码" class="headerlink" title="汇编代码"></a>汇编代码</h4><p>可能大家都听过汇编语言这个东西,但是年轻一点的同学不一定真正见过.简单来说汇编语言是将机器语言符号化了的语言,是机器不能直接识别的低级语言.我们可以通过下面的命令,将预处理后的代码编译成汇编语言:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -S <span class="keyword">test</span>.i -o <span class="keyword">test</span>.<span class="built_in">s</span></span><br></pre></td></tr></table></figure><p>然后就能看到生成的test.s文件了,里面就是我们写的c语言代码翻译而成的汇编代码:</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">.file   <span class="string">"test.c"</span></span><br><span class="line">        .text</span><br><span class="line">        .globl  <span class="keyword">add</span></span><br><span class="line">        .<span class="keyword">type</span>   <span class="keyword">add</span>, <span class="title">@function</span></span><br><span class="line"><span class="keyword">add</span>:</span><br><span class="line">.LFB<span class="number">0</span>:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        movl    <span class="symbol">%edi</span>, <span class="number">-4</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    <span class="symbol">%esi</span>, <span class="number">-8</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    <span class="number">-4</span>(<span class="symbol">%rbp</span>), <span class="symbol">%edx</span></span><br><span class="line">        movl    <span class="number">-8</span>(<span class="symbol">%rbp</span>), <span class="symbol">%eax</span></span><br><span class="line">        addl    <span class="symbol">%edx</span>, <span class="symbol">%eax</span></span><br><span class="line">        popq    <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE<span class="number">0</span>:</span><br><span class="line">        .size   <span class="keyword">add</span>, .-<span class="keyword">add</span></span><br><span class="line">        .globl  main</span><br><span class="line">        .<span class="keyword">type</span>   main, <span class="title">@function</span></span><br><span class="line">main:</span><br><span class="line">.LFB<span class="number">1</span>:</span><br><span class="line">        .cfi_startproc</span><br><span class="line">        pushq   <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_offset <span class="number">16</span></span><br><span class="line">        .cfi_offset <span class="number">6</span>, <span class="number">-16</span></span><br><span class="line">        movq    <span class="symbol">%rsp</span>, <span class="symbol">%rbp</span></span><br><span class="line">        .cfi_def_cfa_register <span class="number">6</span></span><br><span class="line">        subq    $<span class="number">16</span>, <span class="symbol">%rsp</span></span><br><span class="line">        movl    <span class="symbol">%edi</span>, <span class="number">-4</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movq    <span class="symbol">%rsi</span>, <span class="number">-16</span>(<span class="symbol">%rbp</span>)</span><br><span class="line">        movl    $<span class="number">2</span>, <span class="symbol">%esi</span></span><br><span class="line">        movl    $<span class="number">1</span>, <span class="symbol">%edi</span></span><br><span class="line">        <span class="keyword">call</span>    <span class="keyword">add</span></span><br><span class="line">        movl    $<span class="number">0</span>, <span class="symbol">%eax</span></span><br><span class="line">        leave</span><br><span class="line">        .cfi_def_cfa <span class="number">7</span>, <span class="number">8</span></span><br><span class="line">        <span class="keyword">ret</span></span><br><span class="line">        .cfi_endproc</span><br><span class="line">.LFE<span class="number">1</span>:</span><br><span class="line">        .size   main, .-main</span><br><span class="line">        .ident  <span class="string">"GCC: (Ubuntu 5.4.0-6ubuntu1~16.04.10) 5.4.0 20160609"</span></span><br><span class="line">        .<span class="keyword">section</span>        .note.GNU-stack,<span class="string">""</span>,<span class="title">@progbits</span></span><br></pre></td></tr></table></figure><h4 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h4><p>汇编这一步是将汇编代码编译成机器语言:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c <span class="keyword">test</span>.s -o <span class="keyword">test</span>.o</span><br></pre></td></tr></table></figure><p>生成的test.o文件里面就是机器代码了,我们可以通过nm命令来列出test.o里面的符号:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nm <span class="keyword">test</span>.o</span><br></pre></td></tr></table></figure><p>得到的结果如下:</p><figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0000000000000000 </span>T add</span><br><span class="line"><span class="symbol">0000000000000014 </span>T main</span><br></pre></td></tr></table></figure><h4 id="链接"><a href="#链接" class="headerlink" title="链接"></a>链接</h4><p>由于我们的例子代码比较简单只有一个test.h和test.h,所以只生成了一个.o文件,其实一般的程序都是由多个模块组合成的.链接这一步就是将多个模块的代码组合成一个可执行程序.我们可以用gcc命令将多个.o文件或者静态库、动态库链接成一个可执行文件:</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc <span class="keyword">test</span>.o -o <span class="keyword">test</span></span><br></pre></td></tr></table></figure><p>得到的就是可执行文件test了,可以直接用下面命令运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./<span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>当然是没有任何输出的,因为我们就没有做任何的打印</p><h2 id="编译so库"><a href="#编译so库" class="headerlink" title="编译so库"></a>编译so库</h2><p>在安卓中我们一般不会直接使用C/C++编译出来的可运行文件.用的更多的应该是so库.那要如何编译so库呢?</p><p>首先我们需要将test.c中的main函数去掉,因为so库中是不会带有main函数的:</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"test.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * add 方法定义</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后可以使用下面命令将test.c编译成test.so:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="keyword">so</span></span><br></pre></td></tr></table></figure><p>其实也就是多了个-shared参数,指定编译的结果为动态链接库.</p><p>这里是直接将.c文件编译成so,当然也能像之前的例子一样先编译出.o文件再通过链接生成so文件.</p><p>当然一般编译动态链接库,我们还会带上-fPIC参数.</p><p>fPIC (Position-Independent Code)告诉编译器产生与位置无关代码,即产生的代码中没有绝对地址,全部使用相对地址.故而代码可以被加载器加载到内存的任意位置,都可以正确的执行.不加fPIC编译出来的so,是要再加载时根据加载到的位置再次重定位的.因为它里面的代码并不是位置无关代码.如果被多个应用程序共同使用,那么它们必须每个程序维护一份.so的代码副本了.因为.so被每个程序加载的位置都不同,显然这些重定位后的代码也不同,当然不能共享.</p><h2 id="交叉编译"><a href="#交叉编译" class="headerlink" title="交叉编译"></a>交叉编译</h2><p>通过上面的例子,我们知道了一个C/C++程序是怎么从源代码一步步编译成可运行程序或者so库的.但是我们编译出来的程序或者so库只能在相同系统的电脑上使用.</p><p>例如我使用的电脑是Linux系统的,那它编译出来的程序也就只能在Linux上运行,不能在安卓或者Windows上运行.</p><p>当然正常情况下不会有人专门去到android系统下编译出程序来给安卓去用.一般我们都是在PC上编译出安卓可用的程序,在给到安卓去跑的.这种是在一个平台上生成另一个平台上的可执行代码的编译方式就叫做交叉编译.</p><p>交叉编译有是三个比较重要的概念要先说明一下:</p><ul><li>build : 当前你使用的计算机</li><li>host : 你的目的是编译出来的程序可以在host上运行</li><li>target : 普通程序没有这个概念。对于想编译出编译器的人来说此属性决定了新编译器编译出的程序可以运行在哪</li></ul><p>如果我们想要交叉编译出安卓可运行的程序或者库的话就不能直接使用gcc去编译了.而需要使用Android NDK提供了的一套交叉编译工具链.</p><p>我们首先要下载Android NDK,然后配置好环境变量NDK_ROOT指向NDK的根目录.</p><p>然后可以通过下面命令安装交叉编译工具链:</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$NDK_ROOT</span>/build/tools/make-standalone-toolchain.sh \</span><br><span class="line">    <span class="attribute">--platform</span>=android-19 \</span><br><span class="line">    <span class="attribute">--install-dir</span>=<span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm \</span><br><span class="line">    <span class="attribute">--toolchain</span>=arm-linux-androideabi-4.9 \</span><br><span class="line">    <span class="attribute">--stl</span>=gnustl</span><br></pre></td></tr></table></figure><p>然后我们就能在HOME/Android/目录下看到安装好的工具链了.进到HOME/Android/standalone-toolchains/android-toolchain-arm/bin/目录下我们可以看到有arm-linux-androideabi-gcc这个程序.</p><p>它就是gcc的安卓交叉编译版本.我们将之前使用gcc去编译的例子全部换成使用它去编译就能编译出运行在安卓上的程序了:</p><p>如下面命令生成的so库就能在安卓上通过jni调用了:</p><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm/bin/arm-linux-androideabi-gcc -shared -fPIC <span class="keyword">test</span>.c -o <span class="keyword">test</span>.<span class="keyword">so</span></span><br></pre></td></tr></table></figure><h3 id="不同CPU架构的编译方式"><a href="#不同CPU架构的编译方式" class="headerlink" title="不同CPU架构的编译方式"></a>不同CPU架构的编译方式</h3><p>当然安卓也有很多不同的CPU架构,不同CPU架构的程序也是不一定兼容的,相信大家之前在使用Android Studio去编译so的时候也有看到编译出来的库有很多个版本像armeabi、armeabi-v7a、mips、x86等.</p><p>那这些不同CPU架构的程序又要如何编译了.</p><p>我们可以在$NDK_ROOT/toolchains目录下看到者几个目录:</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">arm-linux-androideabi-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">aarch64-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">mipsel-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">mips64el-linux-android-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">x86-4</span><span class="selector-class">.9</span></span><br><span class="line"><span class="selector-tag">x86_64-4</span><span class="selector-class">.9</span></span><br></pre></td></tr></table></figure><p>这就是不同CPU架构的交叉编译工具链了.还记得我们安装工具链的命令吗?</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$NDK_ROOT</span>/build/tools/make-standalone-toolchain.sh \</span><br><span class="line">    <span class="attribute">--platform</span>=android-19 \</span><br><span class="line">    <span class="attribute">--install-dir</span>=<span class="variable">$HOME</span>/Android/standalone-toolchains/android-toolchain-arm \</span><br><span class="line">    <span class="attribute">--toolchain</span>=arm-linux-androideabi-4.9 \</span><br><span class="line">    <span class="attribute">--stl</span>=gnust</span><br></pre></td></tr></table></figure><p>toolchain参数就能指定使用哪个工具链,然后就能使用该工具链去编译该架构版本的程序了.</p><p>但是,我们看到这下面并没有armeabi-v7a的工具链,那armeabi-v7a的程序要如何编译呢?</p><p>其实armeabi-v7a的程序也是用arm-linux-androideabi-4.9去编译的,只不过在编译的时候可以带上-march=armv7-a:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-androideabi-gcc -march=armv7-<span class="selector-tag">a</span> -shared -fPIC test<span class="selector-class">.c</span> -o test.so</span><br></pre></td></tr></table></figure><h2 id="Makefile"><a href="#Makefile" class="headerlink" title="Makefile"></a>Makefile</h2><p>我们前面的例子都是直接用gcc或着各个交叉编译的版本的gcc去编译C/C++代码的.在代码量不多的时候这么做还是可行的,但是如果软件一旦复杂一些,代码量一多,那么编译的命令就会十分的复杂,而且还需要考虑到多个模块之间的依赖关系.</p><p>Makefile就是一个帮助我们解决这些问题的工具.它的基本原理十分简单,先让我们看看它最最基本的用法:</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target <span class="string">...</span> : prerequisites <span class="string">...</span></span><br><span class="line"><span class="keyword">command</span></span><br><span class="line"><span class="string">...</span></span><br><span class="line"><span class="string">...</span></span><br></pre></td></tr></table></figure><p>target可以是一个object file(目标文件)，也可以是一个执行文件，还可以是一个标签（label）。</p><p>prerequisites就是，要生成那个target所需要的文件或是目标。</p><p>command也就是make需要执行的命令。（任意的shell命令）</p><p>这是一个文件的依赖关系，也就是说，target这一个或多个的目标文件依赖于prerequisites中的文件，其生成规则定义在 command中。说白一点就是说，prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。这就是makefile的规则。也就是makefile中最核心的内容。</p><p>还是举我们的例子代码,首先创建一个文件,名字叫Makefile,然后写上:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">test<span class="selector-class">.so</span> : test<span class="selector-class">.c</span> test<span class="selector-class">.h</span>                                                          </span><br><span class="line">    arm-linux-androideabi-gcc -march=armv7-<span class="selector-tag">a</span> -shared -fPIC test<span class="selector-class">.c</span> -o test.so</span><br><span class="line">clean :</span><br><span class="line">rm test.so</span><br></pre></td></tr></table></figure><p>然后就可以用make命令去编译了.make命令会找到当前目录下的Makefile,然后比较目标文件文件和依赖文件的修改时间,如果依赖文件的修改时间比较晚,或者干脆就还没有目标文件.就会执行命令.</p><p>clean不是一个文件，它只不过是一个动作名字，有点像c语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找它的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令（不仅用于clean，其他lable同样适用），就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><p>这只是比较简单的用法，具体的Makefile知识请查看<a href="http://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile:MakeFile%E4%BB%8B%E7%BB%8D" target="_blank" rel="noopener">跟我一起写Makefile</a>.</p><h2 id="CMake"><a href="#CMake" class="headerlink" title="CMake"></a>CMake</h2><p>CMake是一种跨平台编译工具，比make更为高级，使用起来要方便得多。CMake主要是编写CMakeLists.txt文件，然后用cmake命令将CMakeLists.txt文件转化为make所需要的makefile文件，最后用make命令编译源码生成可执行程序或共享库（so(shared object)）。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#<span class="number">1</span><span class="selector-class">.cmake</span> verson，指定cmake版本 </span><br><span class="line"><span class="function"><span class="title">cmake_minimum_required</span><span class="params">(VERSION <span class="number">3.2</span>)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">2</span><span class="selector-class">.project</span> name，指定项目的名称，一般和项目的文件夹名称对应</span><br><span class="line"><span class="function"><span class="title">project</span><span class="params">(myPro)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">3</span><span class="selector-class">.head</span> file path，头文件目录</span><br><span class="line"><span class="function"><span class="title">include_directories</span><span class="params">(include)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">4</span>.添加需要链接的库文件目录</span><br><span class="line"><span class="function"><span class="title">link_directories</span><span class="params">(include)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">5</span><span class="selector-class">.source</span> directory，源文件目录</span><br><span class="line"><span class="function"><span class="title">aux_source_directory</span><span class="params">(src DIR_SRCS)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">6</span><span class="selector-class">.set</span> environment variable，设置环境变量，编译用到的源文件全部都要放到这里，否则编译能够通过，但是执行的时候会出现各种问题，比如<span class="string">"symbol lookup error xxxxx , undefined symbol"</span></span><br><span class="line"><span class="function"><span class="title">set</span><span class="params">(TEST_MATH $&#123;DIR_SRCS&#125;)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">7</span><span class="selector-class">.add</span> executable file，添加要编译的可执行文件</span><br><span class="line"><span class="function"><span class="title">add_executable</span><span class="params">($&#123;PROJECT_NAME&#125; $&#123;TEST_MATH&#125;)</span></span></span><br><span class="line"></span><br><span class="line">#<span class="number">8</span><span class="selector-class">.add</span> link library，添加可执行文件所需要的库，比如我们用到了libm.so（命名规则：lib+name+.so），就添加该库的名称</span><br><span class="line"><span class="function"><span class="title">target_link_libraries</span><span class="params">($&#123;PROJECT_NAME&#125; m)</span></span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近一直在和Linux C开发打交道，开发过程中会用到交叉编译和Makefile相关知识，但是对这块真的是没有了解，所以在网上搜索，找到一篇不错的博客。本文转载自该博客&lt;a href=&quot;https://www.jianshu.com/p/3ba79f1ade39&quot; targ
      
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="交叉编译" scheme="http://yoursite.com/tags/%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91/"/>
    
      <category term="Makefile" scheme="http://yoursite.com/tags/Makefile/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(一) Camera2 API采集数据</title>
    <link href="http://yoursite.com/2019/01/04/Android-Camera2%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/01/04/Android-Camera2开发/</id>
    <published>2019-01-04T02:22:47.000Z</published>
    <updated>2019-01-07T02:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>这是Android音视频的第一篇文章，终于回到了我的老本行上，后面音视频开发会基于Android平台（关键我也不太会其他平台，后面会慢慢学习。。。）</p><p>之前好像从来没有做过Camera相关的开发，这块对我来说还是有点陌生，所以从头开始学起。由于Google 现在已经不推荐使用Camera，所以就直接从Camera2开始咯。</p><h2 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h2><p>在Android API21中Google发布了Camera2来取代原本的Camera，两者的变动也是比较大的。</p><p><img src="/2019/01/04/Android-Camera2开发/camera2-1.png" alt=""></p><p>Camera2中Google采用了pipeline（管道）的概念，将Camera Device相机设备和Android Device安卓设备连接起来， Android Device通过管道发送CaptureRequest请求给Camera Device，Camera Device通过管道返回CameraMetadata数据给Android Device，这一切建立在一个叫作CameraCaptureSession的会话中。</p><h2 id="Camera2主要类说明"><a href="#Camera2主要类说明" class="headerlink" title="Camera2主要类说明"></a>Camera2主要类说明</h2><p>在Camera2 架构在核心参与类角色有：CameraManager、CameraDevice、CameraCharacteristics、CameraRequest与CameraRequest.Builder、CameraCaptureSession以及CaptureResult。</p><h3 id="CameraManager"><a href="#CameraManager" class="headerlink" title="CameraManager"></a>CameraManager</h3><p>位于android.hardware.camera2.CameraManager下，也是Android 21(5.0)添加的，和其他系统服务一样通过 <code>Context.getSystemService(Context.CAMERA_SERVICE)</code> 来完成初始化，主要用于管理系统摄像头。</p><ul><li><code>manager.getCameraIdList()</code> 获取Android设备的摄像头列表</li><li><code>manager.getCameraCharacteristics(cameraId)</code> 获取指定摄像头的相关特性</li><li><code>manager.openCamera(String cameraId, CameraDevice.StateCallback callback, Handler handler)</code> 打开指定Id的摄像头，StateCallback 是打开状态的一个监听回调，Handler 表示使用哪个线程处理回调，如果为null则表示当前线程。</li></ul><h3 id="CameraDevice"><a href="#CameraDevice" class="headerlink" title="CameraDevice"></a>CameraDevice</h3><p>CameraDevice是Camera2抽象出来的一个对象，直接与系统硬件摄像头相联系。</p><ul><li><p>通过CameraDevice.StateCallback监听摄像头的状态</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.StateCallback mStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback()&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//摄像头打开，可以创建会话，开始预览</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice camera)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>管理CameraCaptureSession会话，相当于Android Device和Camera Device之间的管道，后面的数据交流都在这个会话中完成。</p></li><li><p>管理CaptureRequest，主要包括通过createCaptureRequest（int templateType）创建捕获请求，在需要预览、拍照、再次预览的时候都需要通过创建请求来完成。</p></li></ul><h3 id="CameraCaptureSession"><a href="#CameraCaptureSession" class="headerlink" title="CameraCaptureSession"></a>CameraCaptureSession</h3><p>正如前面所说，系统向摄像头发送 Capture 请求，而摄像头会返回 CameraMetadata，这一切都是在由对应的CameraDevice创建的CameraCaptureSession 会话完成，当程序需要预览、拍照、再次预览时，都需要先通过会话。CameraCaptureSession一旦被创建，直到对应的CameraDevice关闭才会死掉。虽然CameraCaptureSession会话用于从摄像头中捕获图像，但是只有同一个会话才能再次从同一摄像头中捕获图像。</p><ul><li>管理CameraCaptureSession.StateCallback状态回调，用于接收有关CameraCaptureSession状态的更新的回调对象，主要回调方法有两个当CameraDevice 完成配置，对应的会话开始处理捕获请求时触发onConfigured(CameraCaptureSession session)方法，反之配置失败时候触发onConfigureFailed(CameraCaptureSession session)方法。</li><li>管理CameraCaptureSession.CaptureCallback捕获回调，用于接收捕获请求状态的回调，当请求触发捕获已启动时、捕获完成时、在捕获图像时发生错误的情况下都会触发该回调对应的方法。</li><li>通过调用方法capture(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)提交捕获图像请求，即拍照。</li><li>通过调用方法setRepeatingRequest(CaptureRequest request, CameraCaptureSession.CaptureCallback listener, Handler handler)请求不断重复捕获图像，即实现预览。</li><li>通过方法调用stopRepeating()实现停止捕获图像，即停止预览。</li></ul><h3 id="CameraCharacteristics"><a href="#CameraCharacteristics" class="headerlink" title="CameraCharacteristics"></a>CameraCharacteristics</h3><p>描述Cameradevice属性的对象，可以使用CameraManager通过getCameraCharacteristics（String cameraId）进行查询。</p><h3 id="CameraRequest与CameraRequest-Builder"><a href="#CameraRequest与CameraRequest-Builder" class="headerlink" title="CameraRequest与CameraRequest.Builder"></a>CameraRequest与CameraRequest.Builder</h3><p>CameraRequest代表了一次捕获请求</p><p>CameraRequest.Builder用于描述捕获图片的各种参数设置，包含捕获硬件（传感器，镜头，闪存），对焦模式、曝光模式，处理流水线，控制算法和输出缓冲区的配置，然后传递到对应的会话中进行设置。CameraRequest.Builder负责生成CameraRequest对象。</p><h3 id="CaptureResult"><a href="#CaptureResult" class="headerlink" title="CaptureResult"></a>CaptureResult</h3><p>CaptureRequest描述是从图像传感器捕获单个图像的结果的子集的对象。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>谷歌有写两个示例程序，介绍如何使用Camera2</p><p><a href="https://github.com/googlesamples/android-Camera2Basic" target="_blank" rel="noopener">android-Camera2Basic</a></p><p><a href="https://github.com/googlesamples/android-Camera2Video" target="_blank" rel="noopener">android-Camera2Video</a></p><p>示例程序中有预览、拍照、录像等功能，非常好的入门学习代码。</p><p>在这里还是过一遍整个流程，加深理解。</p><h3 id="1、-打开摄像头"><a href="#1、-打开摄像头" class="headerlink" title="1、 打开摄像头"></a>1、 打开摄像头</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 判断权限</span></span><br><span class="line">        <span class="keyword">if</span> (ContextCompat.checkSelfPermission(getActivity(), Manifest.permission.CAMERA)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            requestCameraPermission();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置参数，获取摄像头ID、设置预览宽高等</span></span><br><span class="line">        setUpCameraOutputs(width, height);</span><br><span class="line">        <span class="comment">// 配置TextureView的纹理转换，解决Camera显示变形问题</span></span><br><span class="line">        configureTransform(width, height);</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        CameraManager manager = (CameraManager) activity.getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//Semaphore 信号量，保证只能有一条线程使用Camera设备</span></span><br><span class="line">            <span class="keyword">if</span> (!mCameraOpenCloseLock.tryAcquire(<span class="number">2500</span>, TimeUnit.MILLISECONDS)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Time out waiting to lock camera opening."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//真正去打开摄像头，在mStateCallback中获取成功或失败的回调</span></span><br><span class="line">            manager.openCamera(mCameraId, mStateCallback, mBackgroundHandler); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Interrupted while trying to lock camera opening."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CameraDevice.StateCallback mStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// This method is called when the camera is opened.  We start camera preview here.</span></span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            mCameraDevice = cameraDevice;</span><br><span class="line">            <span class="comment">//创建会话，开始预览</span></span><br><span class="line">            createCameraPreviewSession();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(@NonNull CameraDevice cameraDevice)</span> </span>&#123;</span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            cameraDevice.close();</span><br><span class="line">            mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(@NonNull CameraDevice cameraDevice, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">            mCameraOpenCloseLock.release();</span><br><span class="line">            cameraDevice.close();</span><br><span class="line">            mCameraDevice = <span class="keyword">null</span>;</span><br><span class="line">            Activity activity = getActivity();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != activity) &#123;</span><br><span class="line">                activity.finish();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure><h3 id="2、创建会话，开始预览"><a href="#2、创建会话，开始预览" class="headerlink" title="2、创建会话，开始预览"></a>2、创建会话，开始预览</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createCameraPreviewSession</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SurfaceTexture texture = mTextureView.getSurfaceTexture();</span><br><span class="line">        <span class="keyword">assert</span> texture != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We configure the size of default buffer to be the size of camera preview we want.</span></span><br><span class="line">        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is the output Surface we need to start preview.</span></span><br><span class="line">        Surface surface = <span class="keyword">new</span> Surface(texture);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We set up a CaptureRequest.Builder with the output Surface.</span></span><br><span class="line">        mPreviewRequestBuilder</span><br><span class="line">                = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">        <span class="comment">//这里是指实时图像数据的输出目标，以后录制视频、直播等都需要在这里添加对应的Target</span></span><br><span class="line">        mPreviewRequestBuilder.addTarget(surface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Here, we create a CameraCaptureSession for camera preview.</span></span><br><span class="line">        mCameraDevice.createCaptureSession(Arrays.asList(surface, mImageReader.getSurface()),</span><br><span class="line">                <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// The camera is already closed</span></span><br><span class="line">                        <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">                            <span class="keyword">return</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// When the session is ready, we start displaying the preview.</span></span><br><span class="line">                        mCaptureSession = cameraCaptureSession;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="comment">// 设置自动对焦</span></span><br><span class="line">                            mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">                            <span class="comment">// Flash is automatically enabled when necessary.</span></span><br><span class="line">                            setAutoFlash(mPreviewRequestBuilder);</span><br><span class="line"></span><br><span class="line">                            <span class="comment">// Finally, we start displaying the camera preview.</span></span><br><span class="line">                            mPreviewRequest = mPreviewRequestBuilder.build();</span><br><span class="line">                            <span class="comment">//不断捕获图像，显示预览图像</span></span><br><span class="line">                            mCaptureSession.setRepeatingRequest(mPreviewRequest,</span><br><span class="line">                                    mCaptureCallback, mBackgroundHandler);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">                            @NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                        showToast(<span class="string">"Failed"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;, <span class="keyword">null</span></span><br><span class="line">        );</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3、拍照"><a href="#3、拍照" class="headerlink" title="3、拍照"></a>3、拍照</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Initiate a still image capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    lockFocus();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock the focus as the first step for a still image capture.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lockFocus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 告诉摄像机开始对焦</span></span><br><span class="line">        mPreviewRequestBuilder.set(CaptureRequest.CONTROL_AF_TRIGGER,</span><br><span class="line">                CameraMetadata.CONTROL_AF_TRIGGER_START);</span><br><span class="line">        <span class="comment">// Tell #mCaptureCallback to wait for the lock.</span></span><br><span class="line">        mState = STATE_WAITING_LOCK;</span><br><span class="line">        <span class="comment">// 发送CaptureRequest要求摄像机捕捉图像</span></span><br><span class="line">        mCaptureSession.capture(mPreviewRequestBuilder.build(), mCaptureCallback,</span><br><span class="line">                mBackgroundHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CameraCaptureSession.CaptureCallback mCaptureCallback</span><br><span class="line">            = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(CaptureResult result)</span> </span>&#123;</span><br><span class="line">              <span class="comment">//处理对焦、闪光灯等</span></span><br><span class="line">              .......</span><br><span class="line">             </span><br><span class="line">              <span class="keyword">case</span> STATE_WAITING_LOCK: &#123;</span><br><span class="line">                    .......</span><br><span class="line">                    <span class="comment">//对焦完成，保存一张图片</span></span><br><span class="line">                    captureStillPicture()；</span><br><span class="line">                    .......</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">captureStillPicture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == activity || <span class="keyword">null</span> == mCameraDevice) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// This is the CaptureRequest.Builder that we use to take a picture.</span></span><br><span class="line">        <span class="comment">// 将mImageReader作为目标，获得的图片数据会交给mImageReader处理</span></span><br><span class="line">        <span class="comment">// 初始化时 mImageReader.setOnImageAvailableListener(mOnImageAvailableListener, mBackgroundHandler);</span></span><br><span class="line">        <span class="comment">// 所以数据最终会在mOnImageAvailableListener中处理</span></span><br><span class="line">        <span class="keyword">final</span> CaptureRequest.Builder captureBuilder =</span><br><span class="line">                mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);</span><br><span class="line">        captureBuilder.addTarget(mImageReader.getSurface());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Use the same AE and AF modes as the preview.</span></span><br><span class="line">        captureBuilder.set(CaptureRequest.CONTROL_AF_MODE,</span><br><span class="line">                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE);</span><br><span class="line">        setAutoFlash(captureBuilder);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Orientation</span></span><br><span class="line">        <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">        captureBuilder.set(CaptureRequest.JPEG_ORIENTATION, getOrientation(rotation));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 拍照事件的最终回调，图片处理完后调用onCaptureCompleted</span></span><br><span class="line">        CameraCaptureSession.CaptureCallback CaptureCallback</span><br><span class="line">                = <span class="keyword">new</span> CameraCaptureSession.CaptureCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCaptureCompleted</span><span class="params">(@NonNull CameraCaptureSession session,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull CaptureRequest request,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           @NonNull TotalCaptureResult result)</span> </span>&#123;</span><br><span class="line">                showToast(<span class="string">"Saved: "</span> + mFile);</span><br><span class="line">                Log.d(TAG, mFile.toString());</span><br><span class="line">                unlockFocus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        mCaptureSession.stopRepeating();</span><br><span class="line">        mCaptureSession.abortCaptures();</span><br><span class="line">        mCaptureSession.capture(captureBuilder.build(), CaptureCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数据处理、保存</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ImageReader.OnImageAvailableListener mOnImageAvailableListener</span><br><span class="line">        = <span class="keyword">new</span> ImageReader.OnImageAvailableListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onImageAvailable</span><span class="params">(ImageReader reader)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//mBackgroundHandler.post(new ImageSaver(reader.acquireNextImage(), mFile));</span></span><br><span class="line">        Image mImage = reader.acquireNextImage();</span><br><span class="line">        ByteBuffer buffer = mImage.getPlanes()[<span class="number">0</span>].getBuffer();</span><br><span class="line">        <span class="keyword">byte</span>[] bytes = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];</span><br><span class="line">        buffer.get(bytes);</span><br><span class="line">        <span class="comment">// 文件操作</span></span><br><span class="line">        <span class="comment">// ......</span></span><br><span class="line">        <span class="comment">// 这里获取到的是视频的原始数据，要对数据做进一步的算法处理、或者采用第三方的编码库进行压缩、以及网络传输等，都可以从这里拿到数据。</span></span><br><span class="line">        mImage.close()；</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="录像"><a href="#录像" class="headerlink" title="录像"></a>录像</h3><p>主要看一下MediaRecorder录制视频相关代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startRecordingVideo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == mCameraDevice || !mTextureView.isAvailable() || <span class="keyword">null</span> == mPreviewSize) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 关闭之前的会话，新的会话会添加录像的Target</span></span><br><span class="line">        closePreviewSession();</span><br><span class="line">        <span class="comment">// 配置MediaRecorder，音频、视频来源，编码格式等</span></span><br><span class="line">        setUpMediaRecorder();</span><br><span class="line">        SurfaceTexture texture = mTextureView.getSurfaceTexture();</span><br><span class="line">        <span class="keyword">assert</span> texture != <span class="keyword">null</span>;</span><br><span class="line">        texture.setDefaultBufferSize(mPreviewSize.getWidth(), mPreviewSize.getHeight());</span><br><span class="line">        <span class="comment">// 创建一个适合视频录制的请求</span></span><br><span class="line">        mPreviewBuilder = mCameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_RECORD);</span><br><span class="line">        List&lt;Surface&gt; surfaces = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up Surface for the camera preview</span></span><br><span class="line">        Surface previewSurface = <span class="keyword">new</span> Surface(texture);</span><br><span class="line">        surfaces.add(previewSurface);</span><br><span class="line">        mPreviewBuilder.addTarget(previewSurface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up Surface for the MediaRecorder 重要的一步，视频信息会交给mMediaRecorder处理</span></span><br><span class="line">        Surface recorderSurface = mMediaRecorder.getSurface();</span><br><span class="line">        surfaces.add(recorderSurface);</span><br><span class="line">        mPreviewBuilder.addTarget(recorderSurface);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Start a capture session</span></span><br><span class="line">        <span class="comment">// Once the session starts, we can update the UI and start recording</span></span><br><span class="line">        mCameraDevice.createCaptureSession(surfaces, <span class="keyword">new</span> CameraCaptureSession.StateCallback() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigured</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                mPreviewSession = cameraCaptureSession;</span><br><span class="line">                updatePreview();</span><br><span class="line">                getActivity().runOnUiThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// UI</span></span><br><span class="line">                        mButtonVideo.setText(R.string.stop);</span><br><span class="line">                        mIsRecordingVideo = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                        <span class="comment">// 开始录制</span></span><br><span class="line">                        mMediaRecorder.start();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigureFailed</span><span class="params">(@NonNull CameraCaptureSession cameraCaptureSession)</span> </span>&#123;</span><br><span class="line">                Activity activity = getActivity();</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != activity) &#123;</span><br><span class="line">                    Toast.makeText(activity, <span class="string">"Failed"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, mBackgroundHandler);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException | IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 配置MediaRecorder</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setUpMediaRecorder</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Activity activity = getActivity();</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == activity) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置要用于录制的音频源。</span></span><br><span class="line">    mMediaRecorder.setAudioSource(MediaRecorder.AudioSource.MIC);</span><br><span class="line">    <span class="comment">// 设置要用于录制的视频源。</span></span><br><span class="line">    mMediaRecorder.setVideoSource(MediaRecorder.VideoSource.SURFACE);</span><br><span class="line">    <span class="comment">// 设置录制期间生成的输出文件的格式。</span></span><br><span class="line">    mMediaRecorder.setOutputFormat(MediaRecorder.OutputFormat.MPEG_4);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 生成MP4文件路径</span></span><br><span class="line">    <span class="keyword">if</span> (mNextVideoAbsolutePath == <span class="keyword">null</span> || mNextVideoAbsolutePath.isEmpty()) &#123;</span><br><span class="line">        mNextVideoAbsolutePath = getVideoFilePath(getActivity());</span><br><span class="line">    &#125;</span><br><span class="line">    mMediaRecorder.setOutputFile(mNextVideoAbsolutePath);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设置用于录制的视频编码比特率。</span></span><br><span class="line">    mMediaRecorder.setVideoEncodingBitRate(<span class="number">10000000</span>);</span><br><span class="line">    <span class="comment">// 设置要捕获的视频的帧速率。</span></span><br><span class="line">    mMediaRecorder.setVideoFrameRate(<span class="number">30</span>);</span><br><span class="line">    mMediaRecorder.setVideoSize(mVideoSize.getWidth(), mVideoSize.getHeight());</span><br><span class="line">    <span class="comment">// 设置要用于录制的视频编码器。</span></span><br><span class="line">    mMediaRecorder.setVideoEncoder(MediaRecorder.VideoEncoder.H264);</span><br><span class="line">    <span class="comment">// 设置要用于录制的音频编码器。</span></span><br><span class="line">    mMediaRecorder.setAudioEncoder(MediaRecorder.AudioEncoder.AAC);</span><br><span class="line">    <span class="keyword">int</span> rotation = activity.getWindowManager().getDefaultDisplay().getRotation();</span><br><span class="line">    <span class="keyword">switch</span> (mSensorOrientation) &#123;</span><br><span class="line">        <span class="keyword">case</span> SENSOR_ORIENTATION_DEFAULT_DEGREES:</span><br><span class="line">            mMediaRecorder.setOrientationHint(DEFAULT_ORIENTATIONS.get(rotation));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SENSOR_ORIENTATION_INVERSE_DEGREES:</span><br><span class="line">            mMediaRecorder.setOrientationHint(INVERSE_ORIENTATIONS.get(rotation));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在调用start前必须的一步</span></span><br><span class="line">    mMediaRecorder.prepare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 常规使用MediaRecorder去录制视频的例子如下：</span><br><span class="line"> * MediaRecorder recorder = new MediaRecorder()<span class="comment">;</span></span><br><span class="line"> * recorder.setAudioSource(MediaRecorder.AudioSource.MIC)<span class="comment">;</span></span><br><span class="line"> * recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP)<span class="comment">;</span></span><br><span class="line"> * recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB)<span class="comment">;</span></span><br><span class="line"> * recorder.setOutputFile(PATH_NAME)<span class="comment">;</span></span><br><span class="line"> * recorder.prepare()<span class="comment">;</span></span><br><span class="line"> * recorder.start()<span class="comment">;   // Recording is now started</span></span><br><span class="line"> * ...</span><br><span class="line"> * recorder.stop()<span class="comment">;</span></span><br><span class="line"> * recorder.reset()<span class="comment">;   // You can reuse the object by going back to setAudioSource() step</span></span><br><span class="line"> * recorder.release()<span class="comment">; // Now the object cannot be reused</span></span><br><span class="line"> **/</span><br></pre></td></tr></table></figure><p>Camera2预览、拍照和录像的大概流程就是这样，相对来说挺复杂的，但也非常重要，后面会继续深入分析原理和源码。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是Android音视频的第一篇文章，终于回到了我的老本行上，后面音视频开发会基于Android平台（关键我也不太会其他平台，后面会慢慢学习。。。）&lt;/p&gt;
&lt;p&gt;之前好像从来没有做过Camera相关的开发，这块对我来说还是有点陌生，所以从头开始学起。由于Google 现在
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
  </entry>
  
  <entry>
    <title>Mac下FFmpeg+H264编译Android平台</title>
    <link href="http://yoursite.com/2019/01/02/FFmpeg%E3%80%81H264%E7%BC%96%E8%AF%91Android%E5%B9%B3%E5%8F%B0/"/>
    <id>http://yoursite.com/2019/01/02/FFmpeg、H264编译Android平台/</id>
    <published>2019-01-02T04:11:30.000Z</published>
    <updated>2019-01-05T06:42:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>FFmpeg编译Android平台一直都是让人头痛的问题，现在还要将H264库同时编译到库中，更是让我头痛了一段时间，网上搜索了很久，尝试了很多例子，最终编译成功，在这里分享下我的编译脚本文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FFmpeg编译Android平台一直都是让人头痛的问题，现在还要将H264库同时编译到库中，更是让我头痛了一段时间，网上搜索了很久，尝试了很多例子，最终编译成功，在这里分享下我的编译脚本文件。&lt;/p&gt;

      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>C语言回调函数</title>
    <link href="http://yoursite.com/2018/12/23/C%E8%AF%AD%E8%A8%80%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/12/23/C语言回调函数/</id>
    <published>2018-12-23T06:48:51.000Z</published>
    <updated>2019-01-03T02:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>想要理解C语言的回调函数，需要先理解什么是函数指针。</p><h2 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h2><p>函数指针是指向函数的指针变量。</p><p>通常我们说的指针变量是指向一个整型、字符型或数组等变量，而函数指针是指向函数。</p><p>函数指针可以像一般函数一样，用于调用函数、传递参数。</p><p>函数指针变量的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(*fun_ptr)</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>; <span class="comment">// 声明一个指向同样参数、返回值的函数指针类型</span></span><br></pre></td></tr></table></figure><h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><p>以下实例声明了函数指针变量 p，指向函数 max：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* p 是函数指针 */</span></span><br><span class="line">    <span class="keyword">int</span> (* p)(<span class="keyword">int</span>, <span class="keyword">int</span>) = &amp; max; <span class="comment">// &amp;可以省略</span></span><br><span class="line">    <span class="keyword">int</span> a, b, c, d;</span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"请输入三个数字:"</span>);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d %d %d"</span>, &amp; a, &amp; b, &amp; c);</span><br><span class="line"> </span><br><span class="line">    <span class="comment">/* 与直接调用函数等价，d = max(max(a, b), c) */</span></span><br><span class="line">    d = p(p(a, b), c); </span><br><span class="line"> </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"最大的数字是: %d\n"</span>, d);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译执行，输出结果如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">请输入三个数字:1 2 3</span></span><br><span class="line"><span class="section">最大的数字是: 3</span></span><br></pre></td></tr></table></figure><h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>函数指针理解后就轮到我们的正主了。那么我们从三个问题开始：</p><ol><li><p>回调函数是什么</p></li><li><p>回调函数该如何使用</p></li><li><p>回调函数在什么时候用</p></li></ol><h4 id="1、回调函数是什么"><a href="#1、回调函数是什么" class="headerlink" title="1、回调函数是什么"></a>1、回调函数是什么</h4><p>函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个通过函数指针调用的函数。</p><p>简单讲：回调函数是由别人的函数执行时调用你实现的函数。</p><h4 id="2、回调函数该如何使用"><a href="#2、回调函数该如何使用" class="headerlink" title="2、回调函数该如何使用"></a>2、回调函数该如何使用</h4><p>示例1：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;  </span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;  </span></span></span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun1</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"hello world.\n"</span>);  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> (*Pfun)())</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    Pfun();  </span><br><span class="line">&#125;  </span><br><span class="line">  </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    callback(fun1);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>callback回调定义的函数fun1，传递给callback的是函数fun1的地址。fun1是一个不含参数返回值为整型的函数，如果fun含有参数，还想使用回调函数则可用下面的示例2。</p><p>示例2：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun2</span><span class="params">(<span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%s.\n"</span>, s);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback</span><span class="params">(<span class="keyword">int</span> (*Pfun)(<span class="keyword">char</span> *), <span class="keyword">char</span> *s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">Pfun(s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">callback(fun2, <span class="string">"hello world"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3、回调函数在什么时候用"><a href="#3、回调函数在什么时候用" class="headerlink" title="3、回调函数在什么时候用"></a>3、回调函数在什么时候用</h4><p>通常，当我们想通过一个统一接口实现不同内容的时候，用回调函数来实现就非常合适。任何时候，如果你所编写的函数必须能够在不同的时刻执行不同的类型的工作或者执行只能由函数调用者定义的工作，你都可以用回调函数来实现。许多窗口系统就是使用回调函数连接多个动作，如拖拽鼠标和点击按钮来指定调用用户程序中的某个特定函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;想要理解C语言的回调函数，需要先理解什么是函数指针。&lt;/p&gt;
&lt;h2 id=&quot;函数指针&quot;&gt;&lt;a href=&quot;#函数指针&quot; class=&quot;headerlink&quot; title=&quot;函数指针&quot;&gt;&lt;/a&gt;函数指针&lt;/h2&gt;&lt;p&gt;函数指针是指向函数的指针变量。&lt;/p&gt;
&lt;p&gt;通常我们说
      
    
    </summary>
    
      <category term="C/C++" scheme="http://yoursite.com/categories/C-C/"/>
    
    
      <category term="C语言" scheme="http://yoursite.com/tags/C%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>YUV数据格式与YUV_420_888</title>
    <link href="http://yoursite.com/2018/12/20/YUV%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E4%B8%8EYUV_420_888/"/>
    <id>http://yoursite.com/2018/12/20/YUV数据格式与YUV_420_888/</id>
    <published>2018-12-20T06:45:00.000Z</published>
    <updated>2019-01-03T06:45:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在准备做Android Camera2相关应用，刚好也碰上了YUV格式相关的问题，所以还是写一篇博客理解YUV格式数据。</p><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><em>YUV</em>是一种颜色空间，基于<em>YUV</em>的颜色编码是流媒体的常用编码方式。</p><p><em>YUV</em>是编译true-color颜色空间（color space）的种类，Y’UV, YUV, YCbCr，YPbPr等专有名词都可以称为<em>YUV</em>，彼此有重叠。<strong>“Y”表示明亮度（Luminance、Luma），“U”和“V”则是色度、浓度（Chrominance、Chroma）</strong>，Y′UV, YUV, YCbCr, YPbPr所指涉的范围，常有混淆或重叠的情况。</p><p>YUV格式有两大类：planar和packed。</p><ul><li>平面格式（planar formats） ：对于planar的YUV格式，先连续存储所有像素点的Y，紧接着存储所有像素点的U，随后是所有像素点的V，如 YYYY YYYY UU VV。</li><li>紧缩格式（packed formats）：对于packed的YUV格式，每个像素点的Y,U,V是连续交替存储的，如YUV YUV YUV YUV，这种排列方式跟 RGB 很类似。</li></ul><h2 id="历史"><a href="#历史" class="headerlink" title="历史"></a>历史</h2><p>Y’UV的发明是由于彩色电视与黑白电视的过渡时期。黑白视频只有Y（Luma，Luminance）视频，也就是灰阶值。到了彩色电视规格的制定，是以YUV/<a href="https://zh.wikipedia.org/wiki/YIQ" target="_blank" rel="noopener">YIQ</a>的格式来处理彩色电视图像，把UV视作表示彩度的C（Chrominance或Chroma），如果忽略C信号，那么剩下的Y（Luma）信号就跟之前的黑白电视频号相同，这样一来便解决彩色电视机与黑白电视机的兼容问题。Y’UV最大的优点在于只需占用极少的带宽。</p><p>因为UV分别代表不同颜色信号，所以直接使用R与B信号表示色度的UV。 也就是说UV信号告诉了电视要偏移某象素的的颜色，而不改变其亮度。 或者UV信号告诉了显示器使得某个颜色亮度依某个基准偏移。 UV的值越高，代表该像素会有更饱和的颜色。</p><p>彩色图像记录的格式，常见的有RGB、YUV、CMYK等。彩色电视最早的构想是使用RGB三原色来同时传输。这种设计方式是原来黑白带宽的3倍，在当时并不是很好的设计。RGB诉求于人眼对色彩的感应，YUV则着重于视觉对于亮度的敏感程度，Y代表的是亮度，UV代表的是彩度（因此黑白电影可省略UV，相近于RGB），分别用Cr和Cb来表示，因此YUV的记录通常以Y:UV的格式呈现。</p><p>将一张图片的Y、U、V数据单独显示就会如下图所示：</p><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv.png" alt="YUV数据显示"></p><h2 id="常见YUV格式"><a href="#常见YUV格式" class="headerlink" title="常见YUV格式"></a>常见YUV格式</h2><p>YUV的存储格式其实与其采样的方式密切相关，主流的采样方式有三种，YUV4:4:4，YUV4:2:2，YUV4:2:0。<br>$$<br>以黑点表示采样该像素点的Y分量，以空心圆圈表示采用该像素点的UV分量<br>$$</p><h3 id="YUV444"><a href="#YUV444" class="headerlink" title="YUV444"></a>YUV444</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv444.png" alt=""></p><p>4:4:4表示完全取样，每个像素点都采样单独的 YUV 分量信息，包含了最全面的 YUV 信息。</p><h3 id="YUV422"><a href="#YUV422" class="headerlink" title="YUV422"></a>YUV422</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv422.png" alt=""></p><p>在 YUV444 编码的基础上采用 2 * 1 的矩阵进行二次取样，也就是在水平方向上隔一列采样一次 UV 信息，在垂直方向上进行完全取样，每两个Y共用一组UV分量。</p><ul><li><p>YUYV格式</p><p>字节排列 : YUYV YUYV YUYV YUYV</p></li><li><p>UYVY 格式 </p><p>字节排列 : UYVY UYVY UYVY UYVY</p></li><li><p>YUV422P格式 </p><p>字节排列 :YYYY YYYY UUUU VVVV</p></li></ul><h3 id="YUV420"><a href="#YUV420" class="headerlink" title="YUV420"></a>YUV420</h3><p><img src="/2018/12/20/YUV数据格式与YUV_420_888/yuv420.png" alt=""></p><p>解决 YUV444 占用空间过大问题，也是最常用的采样格式。在 YUV444 格式的基础上使用 2 <em> 2 矩阵对像素点进行二次取样，4 个像素点具有单独 Y 分量且共享同一个 UV 信息，总 6 字节。一帧图像占用总空间 (W </em> H + W * H / 2) bytes，比 YUV444 少一半空间。</p><ul><li>I420格式<br>字节排列 YYYY YYYY UU VV，全部都是平面型排列</li><li>NV21格式<br>字节排列 YYYY YYYY UV UV，Y 平面和 UV 平面， UV 内部是紧凑型</li><li>YV12格式<br>字节排列 YYYY YYYY VV UU，平面型，V 在 U 前面</li></ul><p>更多YUV格式参看：<a href="https://blog.csdn.net/airk000/article/details/25032901" target="_blank" rel="noopener">V4L2文档翻译（十）</a></p><h3 id="4-：2：-2-和4：2：0-转换"><a href="#4-：2：-2-和4：2：0-转换" class="headerlink" title="4 ：2： 2 和4：2：0 转换"></a>4 ：2： 2 和4：2：0 转换</h3><p>最简单的方式：</p><p>YUV4:2:2 —&gt; YUV4:2:0  Y不变，将U和V信号值在行(垂直方向)在进行一次隔行抽样</p><p> YUV4:2:0 —&gt; YUV4:2:2  Y不变，将U和V信号值的每一行分别拷贝一份形成连续两行数据</p><h2 id="YUV-420-888"><a href="#YUV-420-888" class="headerlink" title="YUV_420_888"></a>YUV_420_888</h2><p>YUV_420_888是在Android Camera2直播开发中遇到的一个Android内部的YUV格式，当时也是在这个格式上面纠结好久，直播的视频流想用YUV420P格式的数据，但却不清楚这个YUV_420_888到底对应的是NV21或者YUV420P还是其他，网上对这个格式的讲解也比较少。在搜索一番之后终于搞定，在这里记录一下。</p><p>下面这两篇博客介绍了YUV_420_888以及如何解析，讲的很清晰，这里还是不自己去写了。</p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fblog.csdn.net%2Fj12345678901%2Farticle%2Fdetails%2F78110640" target="_blank" rel="noopener">android camera2 拿到的yuv420数据到底是什么样的？</a></p><p><a href="https://link.juejin.im/?target=https%3A%2F%2Fwww.polarxiong.com%2Farchives%2FAndroid-Image%25E7%25B1%25BB%25E6%25B5%2585%25E6%259E%2590-%25E7%25BB%2593%25E5%2590%2588YUV_420_888.html" target="_blank" rel="noopener">Android: Image类浅析(结合YUV_420_888)</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在准备做Android Camera2相关应用，刚好也碰上了YUV格式相关的问题，所以还是写一篇博客理解YUV格式数据。&lt;/p&gt;
&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Linux中断和中断处理</title>
    <link href="http://yoursite.com/2018/12/18/Linux%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/"/>
    <id>http://yoursite.com/2018/12/18/Linux中断和中断处理/</id>
    <published>2018-12-18T12:33:10.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。</p><h2 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h2><p>中断本质上是一种特殊的电信号，有硬件设备发送给处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统处理这些新到来的数据。不同设备对应的中断不同，而每个中断都通过一个唯一的数字标志（中断请求线，IRQ线），操作系统可以根据这些标志提供对应的中断处理程序。</p><h2 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h2><p>在响应一个特定中断的时候，内核会执行一个函数，该函数就被称为中断处理程序或中断服务例程。产生中断的每个设备都有一个相应的中断处理程序。</p><p>在Linux中，中断处理程序就是普通的C函数，不过必须按照特定的类型声明，以便内核能够以标准的方式传递处理程序的信息。被内核调用来响应中断，运行于我们称之为中断上下文中的特殊上下文中。</p><p>因为中断随时可能发生，所以中断处理程序也就随时可能发生。所以必须保证中断处理程序能够快速执行，这样才能保证尽可能快地恢复中断代码的执行。</p><h2 id="上半部与下半部的对比"><a href="#上半部与下半部的对比" class="headerlink" title="上半部与下半部的对比"></a>上半部与下半部的对比</h2><p>又想中断处理程序执行得快，又想中断处理程序完成的工作量多，这两个目的显然有所抵触，所以我们一般把中断处理切为两个部分。</p><p>中断处理程序是上半部（top half）——接收到一个中断，它就立即开始执行，但只做有严格时限的工作。能够被允许稍后完成的工作会推迟到下半部（bottom half）去。</p><h2 id="注册、释放中断处理程序"><a href="#注册、释放中断处理程序" class="headerlink" title="注册、释放中断处理程序"></a>注册、释放中断处理程序</h2><p>中断处理程序是管理硬件的驱动程序的组成部分。驱动程序可以通过 <code>request-irq()</code>函数注册一个中断处理程序，并且激活给定的中断线，以处理中断。</p><p>卸载驱动时，需要注销相对应的中断处理程序，并释放中断线。<code>free_irq()</code>                                                                    </p><h2 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h2><p><code>static irqreturn_t intr_handler(int irq,void *dev)</code>                                                                                                                                              </p><p>第一个参数irq是这个处理程序要响应的中断的中断号，目前已经没有太大用了。</p><p>第二个参数dev是一个通用指针。可以用来区分共享同一中断处理程序的多个设备。</p><h2 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文为《Linux内核设计与实现》第七章 “中断和中断处理” 阅读笔记。&lt;/p&gt;
&lt;h2 id=&quot;中断&quot;&gt;&lt;a href=&quot;#中断&quot; class=&quot;headerlink&quot; title=&quot;中断&quot;&gt;&lt;/a&gt;中断&lt;/h2&gt;&lt;p&gt;中断本质上是一种特殊的电信号，有硬件设备发送给处理器
      
    
    </summary>
    
      <category term="Linux系统" scheme="http://yoursite.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Linux" scheme="http://yoursite.com/tags/Linux/"/>
    
      <category term="中断" scheme="http://yoursite.com/tags/%E4%B8%AD%E6%96%AD/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频转图片</title>
    <link href="http://yoursite.com/2018/12/10/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E8%BD%AC%E5%9B%BE%E7%89%87/"/>
    <id>http://yoursite.com/2018/12/10/FFmpeg代码实现视频转图片/</id>
    <published>2018-12-10T10:59:09.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。</p><h2 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h2><ol><li>打开输入文件 <code>avformat_open_input</code></li><li>找到视频流   <code>av_find_best_stream</code></li><li>找到对应的解码器 <code>avcodec_find_decoder</code></li><li>初始化一个编解码上下文 <code>avcodec_alloc_context3</code></li><li>拷贝流参数到编解码上下文中 <code>avcodec_parameters_to_context</code></li><li>打开解码器 <code>avcodec_open2</code></li><li>读取视频帧 <code>av_read_frame</code></li><li>发送等待解码帧 <code>avcodec_send_packet</code></li><li>接收解码后frame数据 <code>avcodec_receive_frame</code></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *in_filename, *out_filename;</span><br><span class="line">    AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> AVCodec *codec;</span><br><span class="line">    AVCodecContext *codeCtx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    AVStream *stream = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> stream_index;</span><br><span class="line"></span><br><span class="line">    AVPacket avpkt;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> frame_count;</span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc &lt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Usage: %s &lt;input file&gt; &lt;output file&gt;\n"</span>, argv[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    in_filename = argv[<span class="number">1</span>];</span><br><span class="line">    out_filename = argv[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">if</span> (avformat_open_input(&amp;fmt_ctx, in_filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open source file %s\n"</span>, in_filename);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (avformat_find_stream_info(fmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find stream information\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_dump_format(fmt_ctx, <span class="number">0</span>, in_filename, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    av_init_packet(&amp;avpkt);</span><br><span class="line">    avpkt.data = <span class="literal">NULL</span>;</span><br><span class="line">    avpkt.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 2</span></span><br><span class="line">    stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not find %s stream in input file '%s'\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO), in_filename);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stream = fmt_ctx-&gt;streams[stream_index];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3</span></span><br><span class="line">    codec = avcodec_find_decoder(stream-&gt;codecpar-&gt;codec_id);</span><br><span class="line">    <span class="keyword">if</span> (codec == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4</span></span><br><span class="line">    codeCtx = avcodec_alloc_context3(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (!codeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 5</span></span><br><span class="line">    <span class="keyword">if</span> ((ret = avcodec_parameters_to_context(codeCtx, stream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 6</span></span><br><span class="line">    avcodec_open2(codeCtx, codec, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化frame，解码后数据</span></span><br><span class="line">    frame = av_frame_alloc();</span><br><span class="line">    <span class="keyword">if</span> (!frame) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video frame\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    frame_count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 7</span></span><br><span class="line">    <span class="keyword">while</span> (av_read_frame(fmt_ctx, &amp;avpkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (avpkt.stream_index == stream_index) &#123;</span><br><span class="line">            <span class="comment">// 8</span></span><br><span class="line">            <span class="keyword">int</span> re = avcodec_send_packet(codeCtx, &amp;avpkt);</span><br><span class="line">            <span class="keyword">if</span> (re &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 9 这里必须用while()，因为一次avcodec_receive_frame可能无法接收到所有数据</span></span><br><span class="line">            <span class="keyword">while</span> (avcodec_receive_frame(codeCtx, frame) == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 拼接图片路径、名称</span></span><br><span class="line">                <span class="built_in">snprintf</span>(buf, <span class="keyword">sizeof</span>(buf), <span class="string">"%s/Demo-%d.jpg"</span>, out_filename, frame_count);</span><br><span class="line">                saveJpg(frame, buf); <span class="comment">//保存为jpg图片</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            frame_count++;</span><br><span class="line">        &#125;</span><br><span class="line">        av_packet_unref(&amp;avpkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="视频编码（保存为图片）"><a href="#视频编码（保存为图片）" class="headerlink" title="视频编码（保存为图片）"></a>视频编码（保存为图片）</h2><p>编码整体在流程上和解码一致</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">saveJpg</span><span class="params">(AVFrame *pFrame, <span class="keyword">char</span> *out_name)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> width = pFrame-&gt;width;</span><br><span class="line">    <span class="keyword">int</span> height = pFrame-&gt;height;</span><br><span class="line">    AVCodecContext *pCodeCtx = <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    AVFormatContext *pFormatCtx = avformat_alloc_context();</span><br><span class="line">    <span class="comment">// 设置输出文件格式</span></span><br><span class="line">    pFormatCtx-&gt;oformat = av_guess_format(<span class="string">"mjpeg"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建并初始化输出AVIOContext</span></span><br><span class="line">    <span class="keyword">if</span> (avio_open(&amp;pFormatCtx-&gt;pb, out_name, AVIO_FLAG_READ_WRITE) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Couldn't open output file."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构建一个新stream</span></span><br><span class="line">    AVStream *pAVStream = avformat_new_stream(pFormatCtx, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (pAVStream == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    AVCodecParameters *parameters = pAVStream-&gt;codecpar;</span><br><span class="line">    parameters-&gt;codec_id = pFormatCtx-&gt;oformat-&gt;video_codec;</span><br><span class="line">    parameters-&gt;codec_type = AVMEDIA_TYPE_VIDEO;</span><br><span class="line">    parameters-&gt;format = AV_PIX_FMT_YUVJ420P;</span><br><span class="line">    parameters-&gt;width = pFrame-&gt;width;</span><br><span class="line">    parameters-&gt;height = pFrame-&gt;height;</span><br><span class="line"></span><br><span class="line">    AVCodec *pCodec = avcodec_find_encoder(pAVStream-&gt;codecpar-&gt;codec_id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!pCodec) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not find encoder\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx = avcodec_alloc_context3(pCodec);</span><br><span class="line">    <span class="keyword">if</span> (!pCodeCtx) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not allocate video codec context\n"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((avcodec_parameters_to_context(pCodeCtx, pAVStream-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed to copy %s codec parameters to decoder context\n"</span>,</span><br><span class="line">                av_get_media_type_string(AVMEDIA_TYPE_VIDEO));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pCodeCtx-&gt;time_base = (AVRational) &#123;<span class="number">1</span>, <span class="number">25</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (avcodec_open2(pCodeCtx, pCodec, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not open codec."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = avformat_write_header(pFormatCtx, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"write_header fail\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> y_size = width * height;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Encode</span></span><br><span class="line">    <span class="comment">// 给AVPacket分配足够大的空间</span></span><br><span class="line">    AVPacket pkt;</span><br><span class="line">    av_new_packet(&amp;pkt, y_size * <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编码数据</span></span><br><span class="line">    ret = avcodec_send_frame(pCodeCtx, pFrame);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_send_frame."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到编码后数据</span></span><br><span class="line">    ret = avcodec_receive_packet(pCodeCtx, &amp;pkt);</span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not avcodec_receive_packet"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ret = av_write_frame(pFormatCtx, &amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"Could not av_write_frame"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    av_packet_unref(&amp;pkt);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Write Trailer</span></span><br><span class="line">    av_write_trailer(pFormatCtx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    avcodec_close(pCodeCtx);</span><br><span class="line">    avio_close(pFormatCtx-&gt;pb);</span><br><span class="line">    avformat_free_context(pFormatCtx);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h2><p><img src="/2018/12/10/FFmpeg代码实现视频转图片/decoder.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;代码实现视频转图片主要是使用了FFmpeg视频编解码相关的知识，所以首先了解下FFmpeg中的编解码相关函数以及流程，后面再看代码就会比较轻松了。&lt;/p&gt;
&lt;h2 id=&quot;视频解码&quot;&gt;&lt;a href=&quot;#视频解码&quot; class=&quot;headerlink&quot; title=&quot;视频解
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现最简版本小咖秀</title>
    <link href="http://yoursite.com/2018/12/07/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%9C%80%E7%AE%80%E7%89%88%E6%9C%AC%E5%B0%8F%E5%92%96%E7%A7%80/"/>
    <id>http://yoursite.com/2018/12/07/FFmpeg代码实现最简版本小咖秀/</id>
    <published>2018-12-07T08:27:40.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。</p><p>前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。</p><p>源码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> ret = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">int</span> err_code;</span><br><span class="line"><span class="keyword">char</span> errors[ERROR_STR_SIZE];</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> *src_file1, *src_file2, *out_file;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ifmt_ctx1 = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ifmt_ctx2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *in_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *in_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">AVStream *out_stream1 = <span class="literal">NULL</span>;</span><br><span class="line">AVStream *out_stream2 = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> vedio_stream_indes = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件最大时长，保证音频和视频数据长度一致</span></span><br><span class="line"><span class="keyword">double</span> max_duration = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stream1 = <span class="number">0</span>, stream2 = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">av_log_set_level(AV_LOG_DEBUG);</span><br><span class="line"></span><br><span class="line">src_file1 = argv[<span class="number">1</span>];</span><br><span class="line">src_file2 = argv[<span class="number">2</span>];</span><br><span class="line">out_file = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//打开两个输入文件</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx1, src_file1, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"Could not open src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file1, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_open_input(&amp;ifmt_ctx2, src_file2, <span class="number">0</span>, <span class="number">0</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Could not open the second src file, %s, %d(%s)\n"</span>,</span><br><span class="line">           src_file2, err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建输出上下文</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_file)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to create an context of outfile , %d(%s) \n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 找到第一个参数里最好的音频流和第二个文件中的视频流下标</span></span><br><span class="line">audio_stream_index = av_find_best_stream(ifmt_ctx1, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">vedio_stream_indes = av_find_best_stream(ifmt_ctx2, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第一个文件中的音频流</span></span><br><span class="line">in_stream1 = ifmt_ctx1-&gt;streams[audio_stream_index];</span><br><span class="line">stream1 = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 创建音频输出流</span></span><br><span class="line">out_stream1 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream1) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream1-&gt;codecpar, in_stream1-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream1-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取第二个文件中的视频流</span></span><br><span class="line">in_stream2 = ifmt_ctx2-&gt;streams[vedio_stream_indes];</span><br><span class="line">stream2 = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建视频输出流</span></span><br><span class="line">out_stream2 = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (!out_stream2) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"Failed to alloc out stream!\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 拷贝流参数</span></span><br><span class="line"><span class="keyword">if</span> ((err_code = avcodec_parameters_copy(out_stream2-&gt;codecpar, in_stream2-&gt;codecpar)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">           <span class="string">"Failed to copy codec parameter, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">    <span class="keyword">goto</span> END;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">out_stream2-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">av_dump_format(ofmt_ctx, <span class="number">0</span>, out_file, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个流的长度，确定最终文件的长度</span></span><br><span class="line"><span class="keyword">if</span> (in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base) &gt; in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base)) &#123;</span><br><span class="line">    max_duration = in_stream2-&gt;duration * av_q2d(in_stream2-&gt;time_base);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    max_duration = in_stream1-&gt;duration * av_q2d(in_stream1-&gt;time_base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打开输出文件</span></span><br><span class="line"><span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, out_file, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,</span><br><span class="line">               <span class="string">"Could not open output file, %s, %d(%s)\n"</span>,</span><br><span class="line">               out_file, err_code, errors);</span><br><span class="line">        <span class="keyword">goto</span> END;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写头信息</span></span><br><span class="line">avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">av_init_packet(&amp;pkt);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取音频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx1, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream1-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的音频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == audio_stream_index) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream1-&gt;time_base, out_stream1-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream1-&gt;time_base, out_stream1-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream1;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取视频数据并写入输出文件中</span></span><br><span class="line"><span class="keyword">while</span> (av_read_frame(ifmt_ctx2, &amp;pkt) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 如果读取的时间超过了最长时间表示不需要该帧，跳过</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.pts * av_q2d(in_stream2-&gt;time_base) &gt; max_duration) &#123;</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 如果是我们需要的视频流，转换时间基后写入文件</span></span><br><span class="line">    <span class="keyword">if</span> (pkt.stream_index == vedio_stream_indes) &#123;</span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts, in_stream2-&gt;time_base, out_stream2-&gt;time_base,</span><br><span class="line">                                   (AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX));</span><br><span class="line">        pkt.duration = av_rescale_q(max_duration, in_stream2-&gt;time_base, out_stream2-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line">        pkt.stream_index = stream2;</span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx)；</span><br><span class="line"></span><br><span class="line">ret = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">END:</span><br><span class="line"><span class="comment">// 释放内存</span></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx1) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ifmt_ctx2) &#123;</span><br><span class="line">    avformat_close_input(&amp;ifmt_ctx2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (ofmt_ctx) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!(ofmt-&gt;flags &amp; AVFMT_NOFILE)) &#123;</span><br><span class="line">        avio_closep(&amp;ofmt_ctx-&gt;pb);</span><br><span class="line">    &#125;</span><br><span class="line">    avformat_free_context(ofmt_ctx);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终效果如下，从左到右：输入1、输入2、输出文件。输出文件拿到了输入1的音频、输入2的视频信息，并且时长为输入2的时长。</p><p><img src="/2018/12/07/FFmpeg代码实现最简版本小咖秀/merge1.png" alt=""></p><p>目前只是在做C语言开发，后面会慢慢把重心移到Android平台上，在FFmpeg和Android平台的基础上玩更多有意思的东西。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天代码实现了从两个音视频文件中分别抽取音频、视频数据，并将这两种数据存储在一个新的MP4文件中，文件可以正常播放画面和声音，也就是实现一个最简版本的小咖秀。&lt;/p&gt;
&lt;p&gt;前面几篇博客已经把需要的知识都讲了一遍，代码流程也基本一致，下面的代码看起来也会非常轻松。&lt;/p&gt;

      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现视频剪切</title>
    <link href="http://yoursite.com/2018/12/06/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E5%89%AA%E8%BE%91/"/>
    <id>http://yoursite.com/2018/12/06/FFmpeg代码实现视频剪辑/</id>
    <published>2018-12-06T04:07:22.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。</p><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>说起来这个功能的实现也很简单，给定一个起始时间、一个结束时间，把视频文件打开，然后把容器中的每条流从起始时间开始，到结束时间为止的数据拷贝到输出流，然后输出流保存为容器，这样就能看到一个剪切后的视频文件了。</p><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><h4 id="第一步-定义参数"><a href="#第一步-定义参数" class="headerlink" title="第一步 定义参数"></a>第一步 定义参数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">AVFormatContext *ifmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVOutputFormat *ofmt = <span class="literal">NULL</span>;</span><br><span class="line">AVPacket pkt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> start_seconds； <span class="comment">//开始时间</span></span><br><span class="line"><span class="keyword">double</span> end_seconds；   <span class="comment">//结束时间</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *in_filename； <span class="comment">//输入文件</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *out_filename；<span class="comment">//输出文件</span></span><br></pre></td></tr></table></figure><h4 id="第二步-初始化上下文"><a href="#第二步-初始化上下文" class="headerlink" title="第二步 初始化上下文"></a>第二步 初始化上下文</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">avformat_open_input(&amp;ifmt_ctx, in_filename, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//本质上调用了avformat_alloc_context、av_guess_format这两个函数，即创建了输出上下文，又根据输出文件后缀生成了最适合的输出容器</span></span><br><span class="line">avformat_alloc_output_context2(&amp;ofmt_ctx, <span class="literal">NULL</span>, <span class="literal">NULL</span>, out_filename); </span><br><span class="line">ofmt = ofmt_ctx-&gt;oformat;</span><br></pre></td></tr></table></figure><h4 id="第三步-创建流及参数拷贝"><a href="#第三步-创建流及参数拷贝" class="headerlink" title="第三步 创建流及参数拷贝"></a>第三步 创建流及参数拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; ifmt_ctx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        AVStream *in_stream = ifmt_ctx-&gt;streams[i];</span><br><span class="line">        AVStream *out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line">        <span class="keyword">if</span> (!out_stream) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Failed allocating output stream\n"</span>);</span><br><span class="line">            ret = AVERROR_UNKNOWN;</span><br><span class="line">            <span class="keyword">goto</span> end;</span><br><span class="line">        &#125;</span><br><span class="line">        avcodec_parameters_copy(out_stream-&gt;codecpar, in_stream-&gt;codecpar);</span><br><span class="line">        out_stream-&gt;codecpar-&gt;codec_tag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="第四步-打开输出文件"><a href="#第四步-打开输出文件" class="headerlink" title="第四步 打开输出文件"></a>第四步 打开输出文件</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">avio_open(&amp;ofmt_ctx-&gt;pb, out_filename, AVIO_FLAG_WRITE);</span><br></pre></td></tr></table></figure><h4 id="第五步-处理、写入数据"><a href="#第五步-处理、写入数据" class="headerlink" title="第五步  处理、写入数据"></a>第五步  处理、写入数据</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写头信息</span></span><br><span class="line">ret = avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error occurred when opening output file\n"</span>);</span><br><span class="line">    <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//跳转到指定帧</span></span><br><span class="line">ret = av_seek_frame(ifmt_ctx, <span class="number">-1</span>, start_seconds * AV_TIME_BASE, AVSEEK_FLAG_ANY);</span><br><span class="line"><span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error seek\n"</span>);</span><br><span class="line">        <span class="keyword">goto</span> end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据流数量申请空间，并全部初始化为0</span></span><br><span class="line"><span class="keyword">int64_t</span> *dts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(dts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int64_t</span> *pts_start_from = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"><span class="built_in">memset</span>(pts_start_from, <span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">int64_t</span>) * ifmt_ctx-&gt;nb_streams);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        AVStream *in_stream, *out_stream;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//读取数据</span></span><br><span class="line">        ret = av_read_frame(ifmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        in_stream = ifmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line">        out_stream = ofmt_ctx-&gt;streams[pkt.stream_index];</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间超过要截取的时间，就退出循环</span></span><br><span class="line">        <span class="keyword">if</span> (av_q2d(in_stream-&gt;time_base) * pkt.pts &gt; end_seconds) &#123;</span><br><span class="line">            av_packet_unref(&amp;pkt);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将截取后的每个流的起始dts 、pts保存下来，作为开始时间，用来做后面的时间基转换</span></span><br><span class="line">        <span class="keyword">if</span> (dts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            dts_start_from[pkt.stream_index] = pkt.dts;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pts_start_from[pkt.stream_index] == <span class="number">0</span>) &#123;</span><br><span class="line">            pts_start_from[pkt.stream_index] = pkt.pts;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 时间基转换</span></span><br><span class="line">        pkt.pts = av_rescale_q_rnd(pkt.pts - pts_start_from[pkt.stream_index], in_stream-&gt;time_base, out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        pkt.dts = av_rescale_q_rnd(pkt.dts - dts_start_from[pkt.stream_index], in_stream-&gt;time_base,out_stream-&gt;time_base, AV_ROUND_NEAR_INF | AV_ROUND_PASS_MINMAX);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.pts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pkt.dts &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            pkt.dts = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pkt.duration = (<span class="keyword">int</span>) av_rescale_q((<span class="keyword">int64_t</span>) pkt.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        pkt.pos = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//一帧视频播放时间必须在解码时间点之后，当出现pkt.pts &lt; pkt.dts时会导致程序异常，所以我们丢掉有问题的帧，不会有太大影响。</span></span><br><span class="line">        <span class="keyword">if</span> (pkt.pts &lt; pkt.dts) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ret = av_interleaved_write_frame(ofmt_ctx, &amp;pkt);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error write packet\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        av_packet_unref(&amp;pkt);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//释放资源</span></span><br><span class="line"><span class="built_in">free</span>(dts_start_from);</span><br><span class="line"><span class="built_in">free</span>(pts_start_from);</span><br><span class="line"></span><br><span class="line"><span class="comment">//写文件尾信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br></pre></td></tr></table></figure><p>整个处理流程就这样了，还是比较简单的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;有几天没写FFmpeg代码了，今天趁着有空闲来撸下FFmpeg剪切视频代码，我也是边学习边写，如果有错误，请在评论中指出，互相学习。&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;&lt;a href=&quot;#思路&quot; class=&quot;headerlink&quot; title=&quot;思路&quot;&gt;&lt;/a&gt;思路&lt;/h2
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI开发-Linux C程序移植</title>
    <link href="http://yoursite.com/2018/12/05/Android-JNI%E5%BC%80%E5%8F%91-LinuxC%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/"/>
    <id>http://yoursite.com/2018/12/05/Android-JNI开发-LinuxC程序移植/</id>
    <published>2018-12-05T09:51:16.000Z</published>
    <updated>2018-12-05T11:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要提供一些特有的接口给C就好了，以后只维护一套代码，简单方便。</p><p>经过一天的尝试，最终成功完成了一个满足需求的Demo，整体结构如下：</p><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni1.png" alt=""></p><p>整体来看也比较简单，Java调JNI，JNI启动Linux程序，Linux程序运行中需要操作界面时再用JNI的反射方法调用到Java层修改界面。</p><p>接下来看下具体实现：</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni2.png" alt=""></p><p><strong>LinuxHandler.java 定义native方法和等待反射调用方法</strong></p><p><strong>Androidhandle.c  Linux代码调用方法反射Java层</strong></p><p><strong>demo.c    Linux小组同事提供的测试代码，里面有他们简化的业务逻辑</strong></p><p><strong>linuxhandle.c   JNI方法</strong></p><h4 id="LinuxHandler-java"><a href="#LinuxHandler-java" class="headerlink" title="LinuxHandler.java"></a>LinuxHandler.java</h4><p>Java层启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">startLinux</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"speak C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"showMsg C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了三个方法，native方法startLinux()从Java层启动Linux程序，另外两个是模拟等待反射调用的操作界面方法。</p><h4 id="linuxhandle-c"><a href="#linuxhandle-c" class="headerlink" title="linuxhandle.c"></a>linuxhandle.c</h4><p>真正去启动Linux程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"demo.h"</span> <span class="comment">//Linux C 头文件，调用main()方法</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JavaVM *local_jvm = <span class="literal">NULL</span>; </span><br><span class="line">jobject local_object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_***_linuxdemo_LinuxHandle</span></span><br><span class="line"><span class="comment"> * Method:    startLinux</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_***_linuxdemo_LinuxHandle_startLinux</span><br><span class="line">        (JNIEnv *env, jobject object) &#123;</span><br><span class="line">    (*env)-&gt;GetJavaVM(env, &amp;local_jvm); <span class="comment">//保存到全局变量JVM中</span></span><br><span class="line">    local_object = (*env)-&gt;NewGlobalRef(env, object); <span class="comment">/* 创建对象的本地变量 */</span></span><br><span class="line">    main(); <span class="comment">//启动Linux C程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Androidhandle-c"><a href="#Androidhandle-c" class="headerlink" title="Androidhandle.c"></a>Androidhandle.c</h3><p>等待Linux程序调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage_c</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> JavaVM *local_jvm; <span class="comment">//获取全局JVM，由它获取JNIEnv</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">extern</span> jobject local_object;</span><br><span class="line">    (*local_jvm)-&gt;AttachCurrentThread(local_jvm, &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jclass jclass1 = (*env)-&gt;FindClass(env, <span class="string">"com/***/linuxdemo/LinuxHandle"</span>);</span><br><span class="line">    </span><br><span class="line">    jmethodID methodID = (*env)-&gt;GetMethodID(env, jclass1, <span class="string">"showMsg"</span>,</span><br><span class="line">                                             <span class="string">"(Ljava/lang/String;)V"</span>);</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, local_object, methodID, (*env)-&gt;NewStringUTF(env, message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak_c</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">    LOGE(<span class="string">"speak at C"</span>);</span><br><span class="line">    <span class="comment">//同样反射到Java层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo-c"><a href="#Demo-c" class="headerlink" title="Demo.c"></a>Demo.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Androidhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ......  <span class="comment">//公司业务逻辑代码</span></span><br><span class="line">    speak_c(<span class="string">"1234"</span>);</span><br><span class="line">    showMessage_c(<span class="string">"adc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己做完后也做了多次验证，并且导入第三方SO库测试也没有问题，但因为还只是个验证可行性的Demo，后面就要开始正式做移植的项目了，如果遇到了什么坑我会尽快补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg中的时间戳与时间基</title>
    <link href="http://yoursite.com/2018/12/05/FFmpeg%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E6%97%B6%E9%97%B4%E5%9F%BA/"/>
    <id>http://yoursite.com/2018/12/05/FFmpeg中的时间戳与时间基/</id>
    <published>2018-12-05T05:42:44.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。</p><h3 id="PTS和DTS"><a href="#PTS和DTS" class="headerlink" title="PTS和DTS"></a>PTS和DTS</h3><p>这两个概念其实在刚开始的时候就提到过，今天的概念跟它们还是有很大关系的，所以再说一次概念，具体解释请看<a href="https://www.jianshu.com/p/e3acc140aa90" target="_blank" rel="noopener">音视频基础概念</a>。</p><ul><li>PTS: Decode Time Stamp，显示渲染用的时间戳，告诉我们什么时候需要显示</li><li>DTS: Presentation Time Stamp，视频解码时的时间戳，告诉我们什么时候需要解码</li></ul><h3 id="时间基"><a href="#时间基" class="headerlink" title="时间基"></a>时间基</h3><p>在写代码处理音视频流的时候经常会看到<code>in_stream-&gt;time_base</code>这样的代码，这表示的是输入流的时间基，time_base时间基的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment"> * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment"> * 这是表示帧时间戳的基本时间单位(以秒为单位)。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>可以看出时间基是一个分数，以秒为单位，比如1/50秒，那它到底表示的是什么意思呢？以帧率为例，如果它的时间基是1/50秒，那么就表示每隔1/50秒显示一帧数据，也就是每1秒显示50帧，帧率为50FPS。</p><p>每一帧数据都有对应的PTS，在播放视频或音频的时候我们需要将PTS时间戳转化为以秒为单位的时间，用来最后的展示。那如何计算一桢在整个视频中的时间位置？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算一桢在整个视频中的时间位置</span></span><br><span class="line">timestamp(秒) = pts * av_q2d(st-&gt;time_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算视频长度的方法：</span></span><br><span class="line">time(秒) = st-&gt;duration * av_q2d(st-&gt;time_base);</span><br></pre></td></tr></table></figure><h4 id="内部时间基"><a href="#内部时间基" class="headerlink" title="内部时间基"></a>内部时间基</h4><p>FFmpeg中的所有时间都是以它为一个单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal time base represented as integer</span></span><br><span class="line"><span class="comment"> * 内部时间基</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE            1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部时间基的分数表示，实际上它是AV_TIME_BASE的倒数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE_Q   (AVRational)&#123;1, AV_TIME_BASE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ffmpeg内部的时间与标准的时间转换方法</span></span><br><span class="line">timestamp(ffmpeg内部时间戳) = AV_TIME_BASE * time(秒)</span><br><span class="line">time(秒) = AV_TIME_BASE_Q * timestamp(ffmpeg内部时间戳)</span><br></pre></td></tr></table></figure><p>当需要把视频跳转到N秒的时候可以使用下面的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame(fmt_ctx, index_of_video, N * <span class="built_in">AV_TIME_BASE</span>, <span class="built_in">AVSEEK_FLAG_BACKWARD</span>);</span><br></pre></td></tr></table></figure><p>有时候我们需要在不同的时间基之间做换算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> av_rescale_q(<span class="keyword">int64_t</span> a, AVRational bq, AVRational cq) av_const;</span><br></pre></td></tr></table></figure><p>这个方法实际的操作是 <code>a * bq / cq</code>，看起来简单，但它内部处理了数值溢出的问题，所以我们在操作的时候最好还是直接调用这个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。&lt;/p&gt;
&lt;h3 id=&quot;PTS和DTS&quot;&gt;&lt;a href=&quot;#PTS和DTS&quot; 
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之二叉树的所有路径</title>
    <link href="http://yoursite.com/2018/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2018/12/04/每日一算法之二叉树的所有路径/</id>
    <published>2018-12-04T01:07:40.000Z</published>
    <updated>2018-12-05T03:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>有关二叉树的问题绝大多数都可以通过递归解决。先序遍历二叉树，将每个节点加在字符串的后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int = 0) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">binaryTreePaths</span><span class="params">(root: TreeNode?)</span>: List&lt;String&gt; </span>&#123;</span><br><span class="line">        val result = ArrayList&lt;String&gt;()</span><br><span class="line">        binaryTreePaths2(root, <span class="string">""</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> fun <span class="title">binaryTreePaths2</span><span class="params">(root: TreeNode?, str: String, result: MutableList&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mStr = str</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStr.isEmpty())&#123;</span><br><span class="line">            mStr = root.`val`.toString() + <span class="string">""</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mStr += <span class="string">"-&gt;"</span> + root.`val`</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> || root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            binaryTreePaths2(root.left, mStr, result)</span><br><span class="line">            binaryTreePaths2(root.right, mStr, result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.add(mStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个问题，在leetcode上，同样的代码逻辑，同样的测试用例，Java代码17ms，Kotlin却要用352 ms，这差距有点太大了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-使用第三方SO库</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9SO%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-使用第三方SO库/</id>
    <published>2018-12-03T11:09:27.000Z</published>
    <updated>2018-12-03T12:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要通过我自己的C文件再去调用so库中的方法。</p><h1 id="生成SO库"><a href="#生成SO库" class="headerlink" title="生成SO库"></a>生成SO库</h1><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>新建项目JNISODemo，在MainActivity中定义Native方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function">String <span class="title">getString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="头文件生成"><a href="#头文件生成" class="headerlink" title="头文件生成"></a>头文件生成</h3><p>.h文件的生成是在命令行cd到main目录下，再使用javah生成。</p><p>这次是想介绍下快捷方式。</p><p><strong>File -&gt; Settings -&gt; Tools -&gt; External tools -&gt; +</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-c4046ae731276f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Program:</span>   <span class="variable">$JDKPath</span><span class="variable">$\</span>bin\javah.exe </span><br><span class="line"><span class="symbol">Arguments:</span>  -classpath . -jni -o <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\jni\<span class="variable">$Prompt</span><span class="variable">$ </span> <span class="variable">$FileClass</span><span class="variable">$ </span></span><br><span class="line">Working <span class="symbol">directory:</span> <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\java</span><br></pre></td></tr></table></figure><p>在我们声明native方法的类上点击右键，javah，输入命名（我命名为Test.h)，之后就会先自动创建一个jni文件夹，然后生成一个Test.h文件，copy Test.h，并将命名改为Test.c。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-469baae7078430a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码"><a href="#完成C代码" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>在Test.c中简单完成下我们定义的方法，返回一个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_david_jnisodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jnisodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"This is a test!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             Test</span><br><span class="line">             </span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/jni/Test.c )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_library(log-lib log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       Test</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">ndk </span>&#123;</span><br><span class="line">    ldLibs <span class="string">"log"</span><span class="comment">//实现__android_log_print</span></span><br><span class="line">    abiFilters  <span class="string">"armeabi-v7a"</span> <span class="comment">//平台配置，因为在Android上，就只写了一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译完成后就如下图，产生一个libTest.so的文件，这就是我们要的。把它当做Linux最后打包成的so文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-caee5784088bdb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="导入第三方so"><a href="#导入第三方so" class="headerlink" title="导入第三方so"></a>导入第三方so</h1><p>新建一个项目JNIUseSoDemo，项目结构如下。同样是在MainActivity中定义Native方法，生成UseSo.c。将我们上一步生成的so文件拷贝到jniLibs下（armeabi-v7a是平台）。以及上一步中的头文件也拷贝到jni下。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-120270e98dea640c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码-1"><a href="#完成C代码-1" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>我在UseSo中getString方法去调用了so库中的getString方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span> <span class="comment">//so库的头文件，必须要引用！</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Header for class com_david_jniusesodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jniusesodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Java_com_david_jnisodemo_MainActivity_getString(env, instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当然还没有完成。</p><h3 id="CMakeList-txt-1"><a href="#CMakeList-txt-1" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><p>在CMake中将LibTest.so导入工程</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add_library( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             UseSo</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             src/main/jni/UseSo.c )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#导入第三方so包，并声明为 IMPORTED 属性，指明只是想把 so 导入到项目中</span></span><br><span class="line">add_library( Test</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#指明 so 库的路径，CMAKE_SOURCE_DIR 表示 CMakeLists.txt 的路径             </span></span><br><span class="line">set_target_properties(</span><br><span class="line">             Test</span><br><span class="line">             PROPERTIES IMPORTED_LOCATION</span><br><span class="line">             $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/armeabi-v7a/libTest.so )</span><br><span class="line"></span><br><span class="line"><span class="comment">#指明头文件路径，不然会提示找不到 so 的方法</span></span><br><span class="line">include_directories(src/main/jni/)</span><br><span class="line"></span><br><span class="line">find_library(log-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       UseSo</span><br><span class="line"></span><br><span class="line">                       Test</span><br><span class="line"></span><br><span class="line">                       $&#123;log-<span class="class"><span class="keyword">lib</span>&#125; )</span></span><br></pre></td></tr></table></figure><h3 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ndk</span> &#123;</span><br><span class="line">    <span class="attribute">abiFilters</span> <span class="string">'armeabi-v7a'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用"><a href="#最终调用" class="headerlink" title="最终调用"></a>最终调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"UseSo"</span>); <span class="comment">//加载SO库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">"TEST"</span>,getString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getString</span><span class="params">()</span></span>; <span class="comment">//它会调用Java_com_david_jniusesodemo_MainActivity_getString方法，然后该方法又回去调用so库中的Java_com_david_jnisodemo_MainActivity_getString方法，得到返回字符串。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3809817-07915a8ceb23d42d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>验证没有问题，导入第三方so库完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之奇偶链表</title>
    <link href="http://yoursite.com/2018/12/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/12/03/每日一算法之奇偶链表/</id>
    <published>2018-12-03T07:02:11.000Z</published>
    <updated>2018-12-03T12:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;NULL </span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><p>这道题还是比较简单，下面的代码只是一种解决方法。odd节点指向奇节点，even指向偶节点，将even后的奇节点放在它的前面，然后-&gt;next往后依次，直到结束，所有的奇节点就在前面，偶节点在后，顺序没变。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">oddEvenList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> = <span class="title">odd</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">        odd-&gt;next-&gt;next = tmp;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有遍历节点，将奇偶节点分开成两个链表，最后再将偶链表连在奇链表后面也是可以的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
&lt;p&gt;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。&lt;/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-LOG日志</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-LOG/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-LOG/</id>
    <published>2018-12-03T02:43:38.000Z</published>
    <updated>2018-12-03T03:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便以后查看使用。</p><h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><pre><code>defaultConfig {   ndk {       ldLibs &quot;log&quot; //实现__android_log_print       moduleName &quot;demo&quot;  //设置库(so)文件名称       abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;   }}</code></pre><p><code>ldLibs &quot;log&quot;</code>是实现JNI Log的关键。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG    <span class="meta-string">"MyDemo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGE(<span class="string">"myName : %s"</span>, name); <span class="comment">// Log.e(TAG,"myName : $name")</span></span><br><span class="line">LOGD(<span class="string">"age: %d"</span>,age); <span class="comment">// Log.d(TAG,"age : $age")</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之判断回文联表</title>
    <link href="http://yoursite.com/2018/11/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E8%81%94%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/11/30/每日一算法之判断回文联表/</id>
    <published>2018-11-30T06:36:00.000Z</published>
    <updated>2018-11-30T07:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？（<a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">leetcode原题</a>）</p><p>拿到这个题的时候，看到给出的第二个示例以及要求O(1) 空间复杂度就知道要利用链表逆序思想，将链表后半部分逆序。然后从前到中和从后到中一一对比即可。</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node1</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node2</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node3</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node2每次跳两步，node1每次跳一步，当node2-&gt;next或者node2-&gt;next-&gt;next为空时</span></span><br><span class="line">    <span class="comment">//链表个数为奇数，node1就处在中间位置，</span></span><br><span class="line">    <span class="comment">//链表个数为偶数，node1和node1-&gt;next就是中间两个位置。</span></span><br><span class="line">    <span class="keyword">while</span>(node2-&gt;next!=<span class="literal">NULL</span> &amp;&amp; node2-&gt;next-&gt;next !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node2 = node2-&gt;next-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆序后半段链表</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//     转为</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3&lt;-3&lt;-2&lt;-1</span></span><br><span class="line">    node2 = node1-&gt;next;</span><br><span class="line">    node1-&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node3 = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        node1 = node2;</span><br><span class="line">        node2 = node3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node3 = node1;</span><br><span class="line">    node2 = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从前端和后端开始对比数字</span></span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span> &amp;&amp; node1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2-&gt;val != node1-&gt;val)&#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在程序中应该把链表恢复原样，毕竟还有可能要用到这个链表，参照上面，这里就偷懒没写了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没有写算法了，为了链表的逆序在纸上画了半天才理清逻辑。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android模拟屏幕点击</title>
    <link href="http://yoursite.com/2018/11/30/Android%E6%A8%A1%E6%8B%9F%E5%B1%8F%E5%B9%95%E7%82%B9%E5%87%BB/"/>
    <id>http://yoursite.com/2018/11/30/Android模拟屏幕点击/</id>
    <published>2018-11-30T02:28:20.000Z</published>
    <updated>2018-11-30T02:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。</p><p>也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB中的”adb shell tap x y”来点击屏幕，亲测可行，并且代码很简单。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> order = listOf(<span class="string">"input"</span>,</span><br><span class="line">                <span class="string">"tap"</span>,</span><br><span class="line">                <span class="string">""</span> + x,</span><br><span class="line">                <span class="string">""</span> + y)</span><br><span class="line">        ProcessBuilder(order).start()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要传入要点击点的位置坐标，所以要提前计算好坐标，因为我的是专用的Android设备，不用考虑分辨率适配什么的，所以就这样OK了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。&lt;/p&gt;
&lt;p&gt;也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现抽取音频、视频数据</title>
    <link href="http://yoursite.com/2018/11/27/FFmpeg%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E3%80%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/11/27/FFmpeg代码实现抽取音频、视频数据/</id>
    <published>2018-11-27T08:40:27.000Z</published>
    <updated>2018-12-28T06:58:36.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>应该是第一次在Mac上做C/C++开发，纠结过后选择使用CLion 开发。<a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">CLion</a>是 JetBrains下专门用来开发C/C++的IDE，已经用习惯了Android studio和IntelliJ IDEA ，所以CLion用起来还是很顺手的。</p><p>在新建一个C项目后，需要把FFmpeg的库导入才能正常运行。我们修改项目的CMakeLists.txt文件。</p><p><img src="/2018/11/27/FFmpeg代码实现抽取音频、视频数据/extr_voice.png" alt=""></p><h2 id="抽取音频AAC数据"><a href="#抽取音频AAC数据" class="headerlink" title="抽取音频AAC数据"></a>抽取音频AAC数据</h2><p>其实我们要做的主要就是一个文件的操作，把一个文件打开，从里面拿出它的一部分数据，再把这部分数据放到另一个文件中保存。</p><h5 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持各种各样的输出文件格式，MP4，FLV，3GP等等</span></span><br><span class="line">AVOutputFormat *output_fmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入流</span></span><br><span class="line">AVStream *in_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流</span></span><br><span class="line">AVStream *out_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储压缩数据</span></span><br><span class="line">AVPacket packet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要拷贝的流</span></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-打开输入文件，提取参数"><a href="#1-打开输入文件，提取参数" class="headerlink" title="1.打开输入文件，提取参数"></a>1.打开输入文件，提取参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开输入文件，关于输入文件的所有就保存到fmt_ctx中了</span></span><br><span class="line">err_code = avformat_open_input(&amp;fmt_ctx, src_fileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err_code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"cant open file:%s\n"</span>, av_err2str(err_code));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fmt_ctx-&gt;nb_streams&lt;<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//流数小于2，说明这个文件音频、视频流这两条都不能保证，输入文件有错误 </span></span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"输入文件错误，流不足2条\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//拿到文件中音频流</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"> <span class="comment">//参数信息</span></span><br><span class="line"> AVCodecParameters *in_codecpar = in_stream-&gt;codecpar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的音频流</span></span><br><span class="line">audio_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(audio_stream_index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"寻找最好音频流失败，请检查输入文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备输出文件，输出流"><a href="#2-准备输出文件，输出流" class="headerlink" title="2.准备输出文件，输出流"></a>2.准备输出文件，输出流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出上下文</span></span><br><span class="line">ofmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据目标文件名生成最适合的输出容器</span></span><br><span class="line">output_fmt = av_guess_format(<span class="literal">NULL</span>,dst_fileName,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(!output_fmt)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"根据目标生成输出容器失败！\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt_ctx-&gt;oformat = output_fmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建输出流</span></span><br><span class="line"> out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span>(!out_stream)&#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"创建输出流失败！\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-数据拷贝"><a href="#3-数据拷贝" class="headerlink" title="3. 数据拷贝"></a>3. 数据拷贝</h3><h4 id="3-1-参数信息"><a href="#3-1-参数信息" class="headerlink" title="3.1 参数信息"></a>3.1 参数信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将参数信息拷贝到输出流中，我们只是抽取音频流，并不做音频处理，所以这里只是Copy</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avcodec_parameters_copy(out_stream-&gt;codecpar, in_codecpar)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"拷贝编码参数失败！, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-初始化AVIOContext"><a href="#3-2-初始化AVIOContext" class="headerlink" title="3.2 初始化AVIOContext"></a>3.2 初始化AVIOContext</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化AVIOContext,文件操作由它完成</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, dst_fileName, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Could not open file %s, %d(%s)\n"</span>,</span><br><span class="line">           dst_fileName,</span><br><span class="line">           err_code,</span><br><span class="line">           errors);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-开始拷贝"><a href="#3-3-开始拷贝" class="headerlink" title="3.3 开始拷贝"></a>3.3 开始拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化 AVPacket， 我们从文件中读出的数据会暂存在其中</span></span><br><span class="line">av_init_packet(&amp;packet);</span><br><span class="line">packet.data = <span class="literal">NULL</span>;</span><br><span class="line">packet.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写头部信息</span></span><br><span class="line"><span class="keyword">if</span> (avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Error occurred when opening output file"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//每读出一帧数据</span></span><br><span class="line"><span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;packet) &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>(packet.stream_index == audio_stream_index)&#123;</span><br><span class="line">        <span class="comment">//时间基计算，音频pts和dts一致</span></span><br><span class="line">        packet.pts = av_rescale_q_rnd(packet.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br><span class="line">        packet.dts = packet.pts;</span><br><span class="line">        packet.duration = av_rescale_q(packet.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        packet.pos = <span class="number">-1</span>;</span><br><span class="line">        packet.stream_index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将包写到输出媒体文件</span></span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;packet);</span><br><span class="line">        <span class="comment">//减少引用计数，避免内存泄漏</span></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾部信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后别忘了释放内存</span></span><br><span class="line">avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">avio_close(ofmt_ctx-&gt;pb);</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>./MyC /Users/david/Desktop/1080p.mov /Users/david/Desktop/test.aac</code></p><h2 id="抽取视频数据"><a href="#抽取视频数据" class="headerlink" title="抽取视频数据"></a>抽取视频数据</h2><p>抽取视频信息并保存在文件中的流程甚至代码和上面抽取音频基本一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到文件中音频流 或者 视频流，所有流都在streams数组中</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的视频流</span></span><br><span class="line">video_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">packet.dts = av_rescale_q_rnd(packet.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br></pre></td></tr></table></figure><p>基本上就是一些参数的改变，所有流程和代码保持不变，就可以把一个音视频文件中的视频数据抽取出来了，mp4、H264等格式随便，就是这么简单。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。&lt;/p&gt;
&lt;h2 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h2&gt;&lt;p&gt;应该是第一次在Mac上做C/C++开发，纠
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
</feed>
