<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-10T07:17:30.604Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android7.1 Launcher3去除抽屉</title>
    <link href="http://yoursite.com/2020/08/07/Android7-1-Launcher3%E5%8E%BB%E9%99%A4%E6%8A%BD%E5%B1%89/"/>
    <id>http://yoursite.com/2020/08/07/Android7-1-Launcher3去除抽屉/</id>
    <published>2020-08-07T06:48:54.000Z</published>
    <updated>2020-08-10T07:17:30.604Z</updated>
    
    <content type="html"><![CDATA[<p>最近接了个工作，去除公司设备上Launcher的抽屉，所有应用单层展示。网上也查找了一番，最终摸索着基本完成了工作，在此记录下去除抽屉的所有操作。</p><h3 id="去掉searchBox-bar"><a href="#去掉searchBox-bar" class="headerlink" title="去掉searchBox bar"></a>去掉searchBox bar</h3><ol><li><p><code>packages/apps/Launcher3/res/layout/qsb_default_view.xml</code></p><p>屏蔽掉FrameLayout中的布局</p></li><li><p><code>packages/apps/Launcher3/src/com/android/launcher3/QsbContainerView.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getDefaultView</span><span class="params">(LayoutInflater inflater, ViewGroup parent, <span class="keyword">boolean</span> showSetup)</span> </span>&#123;</span><br><span class="line">            View v = inflater.inflate(R.layout.qsb_default_view, parent, <span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// if (showSetup) &#123;</span></span><br><span class="line">            <span class="comment">//     View setupButton = v.findViewById(R.id.btn_qsb_setup);</span></span><br><span class="line">            <span class="comment">//     setupButton.setVisibility(View.VISIBLE);</span></span><br><span class="line">            <span class="comment">//     setupButton.setOnClickListener(this);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">            <span class="comment">// v.findViewById(R.id.btn_qsb_search).setOnClickListener(this);</span></span><br><span class="line">            <span class="keyword">return</span> v;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// if (view.getId() == R.id.btn_qsb_search) &#123;</span></span><br><span class="line">            <span class="comment">//     getActivity().startSearch("", false, null, true);</span></span><br><span class="line">            <span class="comment">// &#125; else if (view.getId() == R.id.btn_qsb_setup) &#123;</span></span><br><span class="line">            <span class="comment">//     // Allocate a new widget id for QSB</span></span><br><span class="line">            <span class="comment">//     sSavedWidgetId = Launcher.getLauncher(getActivity())</span></span><br><span class="line">            <span class="comment">//             .getAppWidgetHost().allocateAppWidgetId();</span></span><br><span class="line">            <span class="comment">//     // Start intent for bind the widget</span></span><br><span class="line">            <span class="comment">//     Intent intent = new Intent(AppWidgetManager.ACTION_APPWIDGET_BIND);</span></span><br><span class="line">            <span class="comment">//     intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_ID, sSavedWidgetId);</span></span><br><span class="line">            <span class="comment">//     intent.putExtra(AppWidgetManager.EXTRA_APPWIDGET_PROVIDER, mWidgetInfo.provider);</span></span><br><span class="line">            <span class="comment">//     startActivityForResult(intent, REQUEST_BIND_QSB);</span></span><br><span class="line">            <span class="comment">// &#125;</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>packages/apps/Launcher3/src/com/android/launcher3/Workspace.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addToCustomContentPage</span><span class="params">(View customContent, CustomContentCallbacks callbacks,</span></span></span><br><span class="line"><span class="function"><span class="params">            String description)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getPageIndexForScreenId(CUSTOM_CONTENT_SCREEN_ID) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Expected custom content screen to exist"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Add the custom content to the full screen custom page</span></span><br><span class="line">        CellLayout customScreen = getScreenWithId(CUSTOM_CONTENT_SCREEN_ID);</span><br><span class="line">        <span class="keyword">int</span> spanX = customScreen.getCountX();</span><br><span class="line">        <span class="keyword">int</span> spanY = customScreen.getCountY();</span><br><span class="line">        <span class="comment">// CellLayout.LayoutParams lp = new CellLayout.LayoutParams(0, 0, spanX, spanY);</span></span><br><span class="line">        <span class="comment">// lp.canReorder  = false;</span></span><br><span class="line">        <span class="comment">// lp.isFullscreen = true;</span></span><br><span class="line">        <span class="keyword">if</span> (customContent <span class="keyword">instanceof</span> Insettable) &#123;</span><br><span class="line">            ((Insettable)customContent).setInsets(mInsets);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Verify that the child is removed from any existing parent.</span></span><br><span class="line">        <span class="keyword">if</span> (customContent.getParent() <span class="keyword">instanceof</span> ViewGroup) &#123;</span><br><span class="line">            ViewGroup parent = (ViewGroup) customContent.getParent();</span><br><span class="line">            parent.removeView(customContent);</span><br><span class="line">        &#125;</span><br><span class="line">        customScreen.removeAllViews();</span><br><span class="line">        customContent.setFocusable(<span class="keyword">true</span>);</span><br><span class="line">        customContent.setOnKeyListener(<span class="keyword">new</span> FullscreenKeyEventListener());</span><br><span class="line">        customContent.setOnFocusChangeListener(mLauncher.mFocusHandler</span><br><span class="line">                .getHideIndicatorOnFocusListener());</span><br><span class="line">        <span class="comment">// customScreen.addViewToCellLayout(customContent, 0, 0, lp, true);</span></span><br><span class="line">        mCustomContentDescription = description;</span><br><span class="line"></span><br><span class="line">        mCustomContentCallbacks = callbacks;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="去掉向上滑动的箭头"><a href="#去掉向上滑动的箭头" class="headerlink" title="去掉向上滑动的箭头"></a>去掉向上滑动的箭头</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/pageindicators/PageIndicatorLineCaret.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">       mAllAppsHandle = (ImageView) findViewById(R.id.all_apps_handle);</span><br><span class="line">       mAllAppsHandle.setImageDrawable(getCaretDrawable());</span><br><span class="line">       mAllAppsHandle.setOnTouchListener(mLauncher.getHapticFeedbackTouchListener());</span><br><span class="line">       mAllAppsHandle.setOnClickListener(mLauncher);</span><br><span class="line">       mAllAppsHandle.setOnLongClickListener(mLauncher);</span><br><span class="line">       mAllAppsHandle.setOnFocusChangeListener(mLauncher.mFocusHandler);</span><br><span class="line">       mAllAppsHandle.setVisibility(<span class="number">8</span>); <span class="comment">// View.GONE</span></span><br><span class="line">       mLauncher.setAllAppsButton(mAllAppsHandle);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="去掉第一屏firstPage"><a href="#去掉第一屏firstPage" class="headerlink" title="去掉第一屏firstPage"></a>去掉第一屏firstPage</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/Workspace.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeAllWorkspaceScreens</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// Disable all layout transitions before removing all pages to ensure that we don't get the</span></span><br><span class="line">       <span class="comment">// transition animations competing with us changing the scroll when we add pages or the</span></span><br><span class="line">       <span class="comment">// custom content screen</span></span><br><span class="line">       disableLayoutTransitions();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Since we increment the current page when we call addCustomContentPage via bindScreens</span></span><br><span class="line">       <span class="comment">// (and other places), we need to adjust the current page back when we clear the pages</span></span><br><span class="line">       <span class="keyword">if</span> (hasCustomContent()) &#123;</span><br><span class="line">           removeCustomContentPage();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Recycle the QSB widget</span></span><br><span class="line">       View qsb = findViewById(getEmbeddedQsbId());</span><br><span class="line">       <span class="keyword">if</span> (qsb != <span class="keyword">null</span>) &#123;</span><br><span class="line">           ((ViewGroup) qsb.getParent()).removeView(qsb);</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Remove the pages and clear the screen models</span></span><br><span class="line">       removeAllViews();</span><br><span class="line">       mScreenOrder.clear();</span><br><span class="line">       mWorkspaceScreens.clear();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// Ensure that the first page is always present</span></span><br><span class="line">       <span class="comment">// bindAndInitFirstWorkspaceScreen(qsb); // 删除第一屏</span></span><br><span class="line"></span><br><span class="line">       <span class="comment">// Re-enable the layout transitions</span></span><br><span class="line">       enableLayoutTransitions();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="去掉hotseat"><a href="#去掉hotseat" class="headerlink" title="去掉hotseat"></a>去掉hotseat</h3><p>1.<code>packages/apps/Launcher3/res/xml/default_workspace_5x6.xml</code></p><p>   <code>packages/apps/Launcher3/res/xml/default_workspace_5x5.xml</code></p><p>屏蔽Hotseat布局</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Hotseat --&gt;</span></span><br><span class="line">   <span class="comment">&lt;!-- &lt;include launcher:workspace="@xml/dw_phone_hotseat" /&gt; --&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li><code>packages/apps/Launcher3/src/com/android/launcher3/DeviceProfile.java</code></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Layout the page indicators</span></span><br><span class="line">        View pageIndicator = launcher.findViewById(R.id.page_indicator);</span><br><span class="line">        <span class="keyword">if</span> (pageIndicator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lp = (FrameLayout.LayoutParams) pageIndicator.getLayoutParams();</span><br><span class="line">            <span class="keyword">if</span> (isVerticalBarLayout()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mInsets.left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lp.leftMargin = mInsets.left + pageIndicatorLandGutterLeftNavBarPx -</span><br><span class="line">                            lp.width - pageIndicatorLandWorkspaceOffsetPx;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInsets.right &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    lp.leftMargin = pageIndicatorLandGutterRightNavBarPx - lp.width -</span><br><span class="line">                            pageIndicatorLandWorkspaceOffsetPx;</span><br><span class="line">                &#125;</span><br><span class="line">                lp.bottomMargin = workspacePadding.bottom;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Put the page indicators above the hotseat</span></span><br><span class="line">                lp.gravity = Gravity.CENTER_HORIZONTAL | Gravity.BOTTOM;</span><br><span class="line">                lp.height = pageIndicatorHeightPx;</span><br><span class="line">                lp.bottomMargin = <span class="number">10</span>; <span class="comment">// 距离底部10dp，占掉Hotseat的位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            pageIndicator.setLayoutParams(lp);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p><code>packages/apps/Launcher3/src/com/android/launcher3/Workspace.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">mDragController.addDragListener(<span class="keyword">new</span> AccessibileDragListenerAdapter(</span><br><span class="line">                   <span class="keyword">this</span>, CellLayout.WORKSPACE_ACCESSIBILITY_DRAG) &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">enableAccessibleDrag</span><span class="params">(<span class="keyword">boolean</span> enable)</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">super</span>.enableAccessibleDrag(enable);</span><br><span class="line">                   <span class="comment">// setEnableForLayout(mLauncher.getHotseat().getLayout(),enable);</span></span><br><span class="line">             </span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Returns a list of all the CellLayouts in the workspace.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function">ArrayList&lt;CellLayout&gt; <span class="title">getWorkspaceAndHotseatCellLayouts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ArrayList&lt;CellLayout&gt; layouts = <span class="keyword">new</span> ArrayList&lt;CellLayout&gt;();</span><br><span class="line">       <span class="keyword">int</span> screenCount = getChildCount();</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> screen = <span class="number">0</span>; screen &lt; screenCount; screen++) &#123;</span><br><span class="line">           layouts.add(((CellLayout) getChildAt(screen)));</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span> (mLauncher.getHotseat() != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// layouts.add(mLauncher.getHotseat().getLayout());</span></span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> layouts;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mLauncher.getHotseat() != <span class="keyword">null</span> &amp;&amp; !isDragWidget(d)) &#123;</span><br><span class="line">           <span class="keyword">if</span> (isPointInSelfOverHotseat(d.x, d.y)) &#123;</span><br><span class="line">               <span class="comment">// layout = mLauncher.getHotseat().getLayout();</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p><code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadExtractedColorsAndColorItems</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="comment">// <span class="doctag">TODO:</span> do this in pre-N as well, once the extraction part is complete.</span></span><br><span class="line">       <span class="keyword">if</span> (Utilities.isNycOrAbove()) &#123;</span><br><span class="line">           mExtractedColors.load(<span class="keyword">this</span>);</span><br><span class="line">           <span class="comment">// mHotseat.updateColor(mExtractedColors, !mPaused);</span></span><br><span class="line">           ...</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="去掉向上滑动显示AllApps的动画效果"><a href="#去掉向上滑动显示AllApps的动画效果" class="headerlink" title="去掉向上滑动显示AllApps的动画效果"></a>去掉向上滑动显示AllApps的动画效果</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showOverviewMode</span><span class="params">(<span class="keyword">boolean</span> animated)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//showOverviewMode(animated, false);</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>packages/apps/Launcher3/src/com/android/launcher3/dragndrop/DragLayer.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (mDragController.onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">           mActiveController = mDragController;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// if (FeatureFlags.LAUNCHER3_ALL_APPS_PULL_UP &amp;&amp; mAllAppsController.onInterceptTouchEvent(ev)) &#123;</span></span><br><span class="line">       <span class="comment">//     mActiveController = mAllAppsController;</span></span><br><span class="line">       <span class="comment">//     return true;</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (mPinchListener != <span class="keyword">null</span> &amp;&amp; mPinchListener.onInterceptTouchEvent(ev)) &#123;</span><br><span class="line">           <span class="comment">// Stop listening for scrolling etc. (onTouchEvent() handles the rest of the pinch.)</span></span><br><span class="line">           mActiveController = mPinchListener;</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p>7.<code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Shows the apps view.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showAppsView</span><span class="params">(<span class="keyword">boolean</span> animated, <span class="keyword">boolean</span> updatePredictedApps,</span></span></span><br><span class="line"><span class="function"><span class="params">           <span class="keyword">boolean</span> focusSearchBar)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// markAppsViewShown();</span></span><br><span class="line">       <span class="comment">// if (updatePredictedApps) &#123;</span></span><br><span class="line">       <span class="comment">//     tryAndUpdatePredictedApps();</span></span><br><span class="line">       <span class="comment">// &#125;</span></span><br><span class="line">       <span class="comment">// showAppsOrWidgets(State.APPS, animated, focusSearchBar);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h3 id="当安装新应用时，安装的应用添加在第一层上"><a href="#当安装新应用时，安装的应用添加在第一层上" class="headerlink" title="当安装新应用时，安装的应用添加在第一层上"></a>当安装新应用时，安装的应用添加在第一层上</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/LauncherModel.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> HashMap&lt;ComponentName, AppInfo&gt; addedOrUpdatedApps = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (added != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">final</span> ArrayList&lt;ItemInfo&gt; addedInfos = <span class="keyword">new</span> ArrayList&lt;ItemInfo&gt;(added);</span><br><span class="line">               addAndBindAddedWorkspaceItems(context, addedInfos);</span><br><span class="line"></span><br><span class="line">               <span class="comment">// addAppsToAllApps(context, added);</span></span><br><span class="line">               <span class="keyword">for</span> (AppInfo ai : added) &#123;</span><br><span class="line">                   addedOrUpdatedApps.put(ai.componentName, ai);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure><h3 id="去掉长按时的删除选项"><a href="#去掉长按时的删除选项" class="headerlink" title="去掉长按时的删除选项"></a>去掉长按时的删除选项</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/DeleteDropTarget.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> true for items that should have a "Remove" action in accessibility. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">supportsAccessibleDrop</span><span class="params">(ItemInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// return (info instanceof ShortcutInfo)</span></span><br><span class="line">    <span class="comment">//         || (info instanceof LauncherAppWidgetInfo)</span></span><br><span class="line">    <span class="comment">//         || (info instanceof FolderInfo);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">supportsDrop</span><span class="params">(DragSource source, ItemInfo info)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去掉桌面长按-、pinch捏动作"><a href="#去掉桌面长按-、pinch捏动作" class="headerlink" title="去掉桌面长按    、pinch捏动作"></a>去掉桌面长按    、pinch捏动作</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/Launcher.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Shows the overview button.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showOverviewMode</span><span class="params">(<span class="keyword">boolean</span> animated)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// showOverviewMode(animated, false);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p><code>packages/apps/Launcher3/src/com/android/launcher3/PinchAnimationManager.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Animates to the specified progress. This should be called repeatedly throughout the pinch</span></span><br><span class="line"><span class="comment">    * gesture to run animations that interpolate throughout the gesture.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> interpolatedProgress The progress from 0 to 1, where 0 is overview and 1 is workspace.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAnimationProgress</span><span class="params">(<span class="keyword">float</span> interpolatedProgress)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">float</span> interpolatedScale = interpolatedProgress * (<span class="number">1f</span> - mOverviewScale) + mOverviewScale;</span><br><span class="line">       <span class="keyword">float</span> interpolatedTranslationY = (<span class="number">1f</span> - interpolatedProgress) * mOverviewTranslationY;</span><br><span class="line">       <span class="comment">// mWorkspace.setScaleX(interpolatedScale);</span></span><br><span class="line">       <span class="comment">// mWorkspace.setScaleY(interpolatedScale);</span></span><br><span class="line">       <span class="comment">// mWorkspace.setTranslationY(interpolatedTranslationY);</span></span><br><span class="line">       <span class="comment">// setOverviewPanelsAlpha(1f - interpolatedProgress, 0);</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">animateThreshold</span><span class="params">(<span class="keyword">float</span> threshold, Workspace.State startState,</span></span></span><br><span class="line"><span class="function"><span class="params">          Workspace.State goingTowards)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// if (threshold == PinchThresholdManager.THRESHOLD_ONE) &#123;</span></span><br><span class="line">      <span class="comment">//     if (startState == OVERVIEW) &#123;</span></span><br><span class="line">      <span class="comment">//         animateOverviewPanelButtons(goingTowards == OVERVIEW);</span></span><br><span class="line">      <span class="comment">//     &#125; else if (startState == NORMAL) &#123;</span></span><br><span class="line">      <span class="comment">//         animateHotseatAndQsb(goingTowards == NORMAL);</span></span><br><span class="line">      <span class="comment">//     &#125;</span></span><br><span class="line">      <span class="comment">// &#125; else </span></span><br><span class="line">      <span class="comment">// if (threshold == PinchThresholdManager.THRESHOLD_TWO) &#123;</span></span><br><span class="line">      <span class="comment">//     if (startState == OVERVIEW) &#123;</span></span><br><span class="line">      <span class="comment">//         animateHotseatAndQsb(goingTowards == NORMAL);</span></span><br><span class="line">      <span class="comment">//         animateScrim(goingTowards == OVERVIEW);</span></span><br><span class="line">      <span class="comment">//     &#125; else if (startState == NORMAL) &#123;</span></span><br><span class="line">      <span class="comment">//         animateOverviewPanelButtons(goingTowards == OVERVIEW);</span></span><br><span class="line">      <span class="comment">//         animateScrim(goingTowards == OVERVIEW);</span></span><br><span class="line">      <span class="comment">//     &#125;</span></span><br><span class="line">      <span class="comment">// &#125; else if (threshold == PinchThresholdManager.THRESHOLD_THREE) &#123;</span></span><br><span class="line">      <span class="comment">//     // Passing threshold 3 ends the pinch and snaps to the new state.</span></span><br><span class="line">      <span class="comment">//     if (startState == OVERVIEW &amp;&amp; goingTowards == NORMAL) &#123;</span></span><br><span class="line">      <span class="comment">//         mLauncher.showWorkspace(true);</span></span><br><span class="line">      <span class="comment">//         mWorkspace.snapToPage(mWorkspace.getCurrentPage());</span></span><br><span class="line">      <span class="comment">//     &#125; else if (startState == NORMAL &amp;&amp; goingTowards == OVERVIEW) &#123;</span></span><br><span class="line">      <span class="comment">//         mLauncher.showOverviewMode(true);</span></span><br><span class="line">      <span class="comment">//     &#125;</span></span><br><span class="line">      <span class="comment">// &#125; else &#123;</span></span><br><span class="line">          Log.e(TAG, <span class="string">"Received unknown threshold to animate: "</span> + threshold);</span><br><span class="line">      <span class="comment">// &#125;</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h3 id="修改无抽屉时的异常"><a href="#修改无抽屉时的异常" class="headerlink" title="修改无抽屉时的异常"></a>修改无抽屉时的异常</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/allapps/AllAppsTransitionController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mDiscoBounceAnimation.setTarget(<span class="keyword">this</span>);</span><br><span class="line">       <span class="keyword">if</span>(mAppsView != <span class="keyword">null</span>)&#123; <span class="comment">// 增加判断</span></span><br><span class="line">           mAppsView.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">               <span class="meta">@Override</span></span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (mDiscoBounceAnimation == <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   mDiscoBounceAnimation.start();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><p><code>packages/apps/Launcher3/src/com/android/launcher3/dragndrop/DragController.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PointF <span class="title">isFlingingToDelete</span><span class="params">(DragSource source)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (<span class="keyword">true</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="屏蔽生成文件夹"><a href="#屏蔽生成文件夹" class="headerlink" title="屏蔽生成文件夹"></a>屏蔽生成文件夹</h3><p><code>packages/apps/Launcher3/src/com/android/launcher3/Workspace.java</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">createUserFolderIfNecessary</span><span class="params">(View newView, <span class="keyword">long</span> container, CellLayout target,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">int</span>[] targetCell, <span class="keyword">float</span> distance, <span class="keyword">boolean</span> external, DragView dragView,</span></span></span><br><span class="line"><span class="function"><span class="params">        Runnable postAnimationRunnable)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(container == -<span class="number">100</span>)&#123; <span class="comment">//禁止形成文件夹</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近接了个工作，去除公司设备上Launcher的抽屉，所有应用单层展示。网上也查找了一番，最终摸索着基本完成了工作，在此记录下去除抽屉的所有操作。&lt;/p&gt;
&lt;h3 id=&quot;去掉searchBox-bar&quot;&gt;&lt;a href=&quot;#去掉searchBox-bar&quot; class=&quot;
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Launcher3" scheme="http://yoursite.com/tags/Launcher3/"/>
    
  </entry>
  
  <entry>
    <title>Android 添加自定义系统服务</title>
    <link href="http://yoursite.com/2020/08/07/Android-%E6%B7%BB%E5%8A%A0%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B3%BB%E7%BB%9F%E6%9C%8D%E5%8A%A1/"/>
    <id>http://yoursite.com/2020/08/07/Android-添加自定义系统服务/</id>
    <published>2020-08-07T06:47:23.000Z</published>
    <updated>2020-08-10T07:28:56.773Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="Service" scheme="http://yoursite.com/tags/Service/"/>
    
  </entry>
  
  <entry>
    <title>Android系统定制笔记</title>
    <link href="http://yoursite.com/2020/07/30/Android%E7%B3%BB%E7%BB%9F%E5%AE%9A%E5%88%B6%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/30/Android系统定制笔记/</id>
    <published>2020-07-30T11:22:56.000Z</published>
    <updated>2020-08-10T07:18:57.164Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一、fastboot刷机"><a href="#一、fastboot刷机" class="headerlink" title="一、fastboot刷机"></a>一、fastboot刷机</h2><p>首先安装adb和fastboot</p><p><code>sudo apt-get install android-tools-adb android-tools-fastboot</code></p><h3 id="进入Fastboot模式"><a href="#进入Fastboot模式" class="headerlink" title="进入Fastboot模式"></a>进入Fastboot模式</h3><p>首先，确保你的手机能够adb连接，然后通过adb执行如下指令进入Fastboot模式，命令如下：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo adb reboot-bootloader</span></span><br></pre></td></tr></table></figure><p>稍等片刻，手机会重启进入Fastboot模式，查看通过如下命令进行确认：</p><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo fastboot devices</span></span><br></pre></td></tr></table></figure><h3 id="刷img文件"><a href="#刷img文件" class="headerlink" title="刷img文件"></a>刷img文件</h3><ol><li>刷boot.img指令</li></ol><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fastboot flash <span class="keyword">boot</span> <span class="keyword">boot</span>.img</span><br></pre></td></tr></table></figure><ol start="2"><li>刷system.img指令</li></ol><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo fastboot flash<span class="built_in"> system </span>system.img</span><br></pre></td></tr></table></figure><ol start="3"><li>刷userdata.img指令</li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">fastboot</span> <span class="selector-tag">flash</span> <span class="selector-tag">userdata</span> <span class="selector-tag">userdata</span><span class="selector-class">.img</span></span><br></pre></td></tr></table></figure><ol start="4"><li>重启手机即可</li></ol><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">sudo fastboot reboot</span></span><br></pre></td></tr></table></figure><h2 id="二、系统编译"><a href="#二、系统编译" class="headerlink" title="二、系统编译"></a>二、系统编译</h2><h3 id="编译系统-全编"><a href="#编译系统-全编" class="headerlink" title="编译系统-全编"></a>编译系统-全编</h3><h4 id="1-安装软件"><a href="#1-安装软件" class="headerlink" title="1.安装软件"></a>1.安装软件</h4><figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-<span class="built_in">get</span> install git-core gnupg flex bison gperf build-essential zip curl zlib1g-<span class="built_in">dev</span> libc6-<span class="built_in">dev</span></span><br><span class="line">lib32ncurses5-<span class="built_in">dev</span> x11proto-core-<span class="built_in">dev</span> libx11-<span class="built_in">dev</span> lib32z-<span class="built_in">dev</span> libgl1-mesa-<span class="built_in">dev</span> g++-multilib mingw32</span><br><span class="line">tofrodos python-markdown libxml2-utils xsltproc</span><br></pre></td></tr></table></figure><h4 id="2-安装openJDK"><a href="#2-安装openJDK" class="headerlink" title="2.安装openJDK"></a>2.安装openJDK</h4><figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo<span class="built_in"> add-apt-repository </span>ppa:openjdk-r/ppa </span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install openjdk-8-jdk</span><br></pre></td></tr></table></figure><p>如果你已经安装openJDK7或其他，可以使用下面命令修改</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo <span class="keyword">update</span>-alternatives <span class="comment">--config java</span></span><br></pre></td></tr></table></figure><h4 id="3-编译系统"><a href="#3-编译系统" class="headerlink" title="3.编译系统"></a>3.编译系统</h4><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>、source build/envsetup.sh</span><br><span class="line"><span class="number">2</span>、lunch</span><br><span class="line">  <span class="comment">//该命令会显示可编译的所有版本，请选择一种，输入对应数字即可</span></span><br><span class="line"><span class="number">3</span>、make –j8</span><br></pre></td></tr></table></figure><p>然后请等待编译结束，编译完成后在/out/target/product/msm8953_64/下找到对应的img文件</p><h3 id="编译系统-模块编译"><a href="#编译系统-模块编译" class="headerlink" title="编译系统-模块编译"></a>编译系统-模块编译</h3><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">make</span> update-api <span class="comment">//更新API接口，代码有修改，git pull拉取代码后请先执行该命令</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">make</span> systemimage -j8  <span class="comment">//单独编译system.img</span></span><br></pre></td></tr></table></figure><h4 id="单模块编译"><a href="#单模块编译" class="headerlink" title="单模块编译"></a>单模块编译</h4><h5 id="修改应用源码"><a href="#修改应用源码" class="headerlink" title="修改应用源码"></a>修改应用源码</h5><p>例如修改了设置Settings代码，可以单独编译Settings的源码，编译出Settings.apk验证</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd packages<span class="meta-keyword">/apps/</span>Settings/</span><br><span class="line"></span><br><span class="line">mm <span class="comment">// 单独编译Settings.apk</span></span><br></pre></td></tr></table></figure><p>编译完成后 </p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb root</span><br><span class="line">adb remount</span><br><span class="line">adb <span class="keyword">push</span> Settings.apk <span class="regexp">/system/</span>priv-app<span class="regexp">/Settings/</span></span><br><span class="line">adb reboot</span><br></pre></td></tr></table></figure><h5 id="修改源码framework后编译"><a href="#修改源码framework后编译" class="headerlink" title="修改源码framework后编译"></a>修改源码framework后编译</h5><ol><li>framework/base/core/res/res下添加或修改资源文件后需要先编译资源，然后编译framework 才可正常引用。</li></ol><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd frameworks<span class="regexp">/base/</span>core<span class="regexp">/res/</span> </span><br><span class="line">mm</span><br></pre></td></tr></table></figure><ol start="2"><li>编译 framework.jar </li></ol><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">cd</span> frameworks/<span class="keyword">base/ </span></span><br><span class="line"><span class="symbol">mm</span></span><br></pre></td></tr></table></figure><ol start="3"><li><p>如果 frameworks/base/services 下有修改，则要编译frameworks/base/services/java/ 执行mm ，编译 services.jar</p></li><li><p>执行如下命令</p></li></ol><figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">adb remount</span><br><span class="line">adb <span class="keyword">push</span> framework-res.apk /<span class="keyword">system</span>/framework/</span><br><span class="line">adb <span class="keyword">push</span> framework.jar /<span class="keyword">system</span>/framework/</span><br><span class="line">adb <span class="keyword">push</span> services.jar /<span class="keyword">system</span>/framework/ （如果有修改的话）</span><br></pre></td></tr></table></figure><ol start="5"><li>push后，可以cd system/framework 进入目录，以ll命令确认下是否push成功。</li><li>adb reboot 重启设备。</li></ol><h2 id="三、系统定制"><a href="#三、系统定制" class="headerlink" title="三、系统定制"></a>三、系统定制</h2><h3 id="1-Launcher过滤App"><a href="#1-Launcher过滤App" class="headerlink" title="1 Launcher过滤App"></a>1 Launcher过滤App</h3><p>LauncherMode.java 中有一个loadAllApps函数，Launcher在其中加载所有App</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the ApplicationInfos</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; apps.size(); i++) &#123;</span><br><span class="line">    LauncherActivityInfoCompat app = apps.get(i);</span><br><span class="line">    Log.e(TAG,<span class="string">"loadAllPackages ="</span>+app.getComponentName().getPackageName());</span><br><span class="line">    <span class="keyword">if</span>(app.getComponentName().getPackageName() == <span class="string">"com.android.settings"</span> || app.getComponentName().getPackageName().contains(<span class="string">"decard"</span>))&#123;</span><br><span class="line">        Log.e(TAG,<span class="string">"settings || decard"</span>);</span><br><span class="line">        <span class="comment">// This builds the icon bitmaps.</span></span><br><span class="line">        mBgAllAppsList.add(<span class="keyword">new</span> AppInfo(mContext, app, user, mIconCache, quietMode));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-去除抽屉"><a href="#2-去除抽屉" class="headerlink" title="2 去除抽屉"></a>2 去除抽屉</h3><p><a href="">Android7.1 Launcher3去除抽屉</a></p><h3 id="3-添加自定义系统服务"><a href="#3-添加自定义系统服务" class="headerlink" title="3 添加自定义系统服务"></a>3 添加自定义系统服务</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;一、fastboot刷机&quot;&gt;&lt;a href=&quot;#一、fastboot刷机&quot; class=&quot;headerlink&quot; title=&quot;一、fastboot刷机&quot;&gt;&lt;/a&gt;一、fastboot刷机&lt;/h2&gt;&lt;p&gt;首先安装adb和fastboot&lt;/p&gt;
&lt;p&gt;&lt;code&gt;
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg滤镜Filter</title>
    <link href="http://yoursite.com/2020/07/14/FFmpeg%E6%BB%A4%E9%95%9CFilter/"/>
    <id>http://yoursite.com/2020/07/14/FFmpeg滤镜Filter/</id>
    <published>2020-07-14T02:09:37.000Z</published>
    <updated>2020-07-14T02:44:44.270Z</updated>
    
    <content type="html"><![CDATA[<p>Filter滤镜，在FFmepg中也是很重要的一部分，今天开始来学习下如何使用Filter。</p><h3 id="Filter能做什么？"><a href="#Filter能做什么？" class="headerlink" title="Filter能做什么？"></a>Filter能做什么？</h3><p>比较常见的有：</p><ul><li>音视频的倍速播放</li><li>视频添加删除Logo</li><li>视频画中画</li></ul><p>###Filter的原理</p><ol><li>将压缩后的每一帧数据进行解码</li><li>对解码后的音视频数据进行运算</li><li>最后将处理好的数据进行编码 </li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Filter滤镜，在FFmepg中也是很重要的一部分，今天开始来学习下如何使用Filter。&lt;/p&gt;
&lt;h3 id=&quot;Filter能做什么？&quot;&gt;&lt;a href=&quot;#Filter能做什么？&quot; class=&quot;headerlink&quot; title=&quot;Filter能做什么？&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="FFmpeg" scheme="http://yoursite.com/categories/FFmpeg/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>使用Android Studio导入Android系统源码</title>
    <link href="http://yoursite.com/2020/06/09/%E4%BD%BF%E7%94%A8Android-Studio%E5%AF%BC%E5%85%A5Android%E7%B3%BB%E7%BB%9F%E6%BA%90%E7%A0%81/"/>
    <id>http://yoursite.com/2020/06/09/使用Android-Studio导入Android系统源码/</id>
    <published>2020-06-09T01:29:00.000Z</published>
    <updated>2020-06-09T02:47:16.503Z</updated>
    
    <content type="html"><![CDATA[<p>在这里我们默认大家已经下载好了Android系统的源代码，关于如何下载，网上有很多详尽的教程，我这里就不再过多的赘述，不会的同学可以自行百度。</p><blockquote><p>使用Android Studio导入系统源代码需要对代码进行一定的编译操作，如果有些同学使用的是Windows系统，可以尝试在Cygwin下进行编译，或者将在Linux下编译生成的三个产物拷贝到Windows的源代码根目录下，也可以起到一样的效果。</p></blockquote><p>这里需要执行以下四条命令：</p><ol><li><p>“source build/envsetup.sh” (source可以用 . 代替，即”. build/envsetup.sh”)</p></li><li><p>“lunch”，并选择要编译的项目。</p></li><li><p>“make idegen -j4” (这里的 -j4 表示用4线程来编译，可以不加)</p></li><li><p>“sudo development/tools/idegen/idegen.sh”</p></li></ol><p>下面进行分步讲解：</p><ol><li><p>进入系统源码的根目录(即可以看到frameworks、kernel等等文件夹的那一级目录)，执行”. build/envsetup.sh”命令</p><p><img src="/2020/06/09/使用Android-Studio导入Android系统源码/1.png" alt=""></p></li><li><p>继续执行”lunch”命令，并选择你想要编译的那个项目.我的系统是FireFly Rk3399开发版提供的系统，可编译的比较多。</p><p><img src="/2020/06/09/使用Android-Studio导入Android系统源码/2.png" alt=""></p><p>选择9，编译rk3399_firefly-userdebug</p><p><img src="/2020/06/09/使用Android-Studio导入Android系统源码/3.png" alt=""></p></li><li><p>前面两步是对编译环境进行配置，接下来执行”make idegen -j4”</p><p><img src="/2020/06/09/使用Android-Studio导入Android系统源码/4.png" alt=""></p></li><li><p>看到以上输出以后，执行”sudo<br>development/tools/idegen/idegen.sh”，并继续等待，这个过程可能比较长，不要着急</p></li></ol><p><img src="/2020/06/09/使用Android-Studio导入Android系统源码/5.png" alt=""></p><p>完成以上四个步骤之后，会发现在源码根目录下出现了三个新的文件(也有可能是两个)</p><ol><li><p>android.iml (记录项目所包含的module、依赖关系、SDK版本等等，类似一个XML文件)</p></li><li><p>android.ipr (工程的具体配置，代码以及依赖的lib等信息，类似于Visual Studio的sln文件)</p></li><li><p>android.iws (主要包含一些个人的配置信息，也有可能在执行上述操作后没有生成，这个没关系，在打开过一次项目之后就会自动生成了)</p><p>“android.iml”和”android.ipr”一般是”只读”的属性，我们这里建议大家，把这两个文件改成可读可写，否则，在更改一些项目配置的时候可能会出现无法保存的情况，执行如下两条命令即可。</p></li></ol><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">chmod</span> 777 <span class="selector-tag">android</span><span class="selector-class">.iml</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">sudo</span> <span class="selector-tag">chmod</span> 777 <span class="selector-tag">android</span><span class="selector-class">.ipr</span></span><br></pre></td></tr></table></figure><p>如果你的电脑性能足够好(内存大于16G，代码下载在SSD上)，那么可以直接打开Android Studio，点击”Open an existing Android Studio project”选项，找到并选中刚刚生成的”android.ipr”文件，点击OK，就可以开始导入项目了。 第一次导入，这个过程可能会持续很久，几十分钟或者超过一个小时。不过成功之后，以后再打开项目就会快很多了。</p><p>​        如果电脑性能一般的话，我建议，可以在导入项目前，手动对”android.iml”文件进行一下修改，可以使我们导入的时间尽可能的缩短一些。</p><p>​        首先，要保证”android.iml”文件已经添加了”可写入”的属性(上文中已经介绍了如何修改文件属性)。</p><p>​        接下来，使用文本编辑器打开”android.iml”文件，并执行以下修改(仅代表我的个人习惯，也可以根据同学们的喜好自己调整)：</p><ol><li>搜索关键字”orderEntry”，我一般会将所有带有这个关键字的标签项全部删除，仅保留以下三行，大概如下</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">   ......</span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">content</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"sourceFolder"</span> <span class="attr">forTests</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">orderEntry</span> <span class="attr">type</span>=<span class="string">"inheritedJdk"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">   <span class="tag">&lt;<span class="name">orderEntryProperties</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;/<span class="name">component</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">module</span>&gt;</span></span><br></pre></td></tr></table></figure><ol start="2"><li>搜索”excludeFolder“关键字，对这里进行一些修改，将我们不需要看的代码Exclude掉。通过这个步骤，能极大地提升第一次加载项目的速度。</li></ol><p>​        等项目加载完成后，我们还可以通过Android Studio对Exclude的Module进行调整，所以也不用害怕这里Exclude掉了有用的代码，或少Exclude了一部分代码，在项目加载完以后再进行调整就行了。</p><p>​        以下是我的配置，大家可以参考(由于我比较关注Framework以及Telephony相关的代码，所以重点保留了这两部分，而其他一些如kernel、bootloader的代码，我就Exclude掉了，同学们也可以根据自己的需求来进行修改)。</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/.repo"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/art"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/bionic"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/bootable"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/build"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/compatibility"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/dalvik"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/developers"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/developers/samples"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/development"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/device/google"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/device/sample"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/docs"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/external"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/flashing-files"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/frameworks/base/docs"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/kernel"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/libcore"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/libnativehelper"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/out"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/pdk"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/platform_testing"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/prebuilt"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/prebuilts"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/shortcut-fe"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/test"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/toolchain"</span> /&gt;</span><br><span class="line"></span><br><span class="line">&lt;excludeFolder <span class="attribute">url</span>=<span class="string">"file://<span class="variable">$MODULE_DIR</span>$/tools"</span> /&gt;</span><br></pre></td></tr></table></figure><p>​        完成之后，按照上面说的步骤，使用Android Studio选中”android.ipr”打开项目即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在这里我们默认大家已经下载好了Android系统的源代码，关于如何下载，网上有很多详尽的教程，我这里就不再过多的赘述，不会的同学可以自行百度。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;使用Android Studio导入系统源代码需要对代码进行一定的编译操作，如果有些同学使
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="系统" scheme="http://yoursite.com/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-Builder模式</title>
    <link href="http://yoursite.com/2020/03/04/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-Builder%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/04/设计模式-Builder模式/</id>
    <published>2020-03-04T09:13:39.000Z</published>
    <updated>2020-07-13T08:15:13.067Z</updated>
    
    <content type="html"><![CDATA[<p>建造者模式（Builder）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ol><li>相同的方法，不同的执行顺序，产生不同的事件结果时。</li><li>多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不同时。</li><li>产品类非常复杂，或者产品类中的调用顺序不同产生了不同的作用，这个时候使用建造者模式非常合适。</li><li>当初始化一个对象特别负责，如参数多，且很多掺乎都有默认值时。</li></ol><h2 id="UML类图"><a href="#UML类图" class="headerlink" title="UML类图"></a>UML类图</h2><ul><li>Product产品类 —— 产品的抽象类</li><li>Builder——抽象Builder类，规范产品的组建</li><li>ConcreteBuilder——具体的Builder类</li><li>Director——统一组装过程</li></ul><p><img src="/2020/03/04/设计模式-Builder模式/1.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;建造者模式（Builder）将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。&lt;/p&gt;
&lt;h2 id=&quot;使用场景&quot;&gt;&lt;a href=&quot;#使用场景&quot; class=&quot;headerlink&quot; title=&quot;使用场景&quot;&gt;&lt;/a&gt;使用场景&lt;/h2&gt;&lt;ol&gt;
&lt;
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android开发-Jetpack组件CameraX</title>
    <link href="http://yoursite.com/2020/02/25/Android%E5%BC%80%E5%8F%91-Jetpack%E7%BB%84%E4%BB%B6CameraX/"/>
    <id>http://yoursite.com/2020/02/25/Android开发-Jetpack组件CameraX/</id>
    <published>2020-02-25T03:36:26.000Z</published>
    <updated>2020-06-09T11:24:28.003Z</updated>
    
    <content type="html"><![CDATA[<p>CameraX 是一个 Jetpack 支持库，旨在帮助您简化相机应用的开发工作。它提供一致且易于使用的 API 界面，适用于大多数 Android 设备，并可向后兼容至 Android 5.0（API 级别 21）。</p><p>虽然它利用的是 camera2 的功能，但使用的是更为简单且基于用例的方法，该方法具有生命周期感知能力。它还解决了设备兼容性问题，因此您无需在代码库中包含设备专属代码。这些功能减少了将相机功能添加到应用时需要编写的代码量。</p><p>目前处于 Alpha 版测试阶段，因为其 API 界面尚未最终确定。我们不建议在生产环境中使用 Alpha 库。CameraX 库应在生产环境中严格避免依赖 Alpha 库，因为其 API 界面可能会以与源代码和二进制文件不兼容的方式发生变化。</p><p>相比较于使用Camera2预览、拍照时大量的接口、回调，使用CameraX基本可以使用不超过100行代码实现相同功能。虽然目前仍是测试版本，但个人强烈建议先学习下，CameraX 真的超简单，超好用！！！后面正式版发布后就可以随时使用。</p><h2 id="CameraX使用"><a href="#CameraX使用" class="headerlink" title="CameraX使用"></a>CameraX使用</h2><h3 id="CameraX-结构"><a href="#CameraX-结构" class="headerlink" title="CameraX 结构"></a>CameraX 结构</h3><p>开发者使用 CameraX，借助名为“用例”的抽象概念与设备的相机进行交互。目前提供的用例如下：</p><ul><li>预览：准备一个预览 SurfaceTexture</li><li>图片拍摄：拍摄并保存照片</li><li>图片分析：提供 CPU 可访问的缓冲区以进行分析（例如进行机器学习）</li></ul><p>不同用例可以相互组合使用，也可以同时处于活动状态。例如，用户可以在应用中使用预览用例查看进入相机视野的画面、加入图片分析用例来确定照片里的人物是否在微笑，以及包含一个图片拍摄用例以便在人物微笑时拍摄照片。</p><h3 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h3><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def camerax_version = <span class="string">"1.0.0-beta04"</span></span><br><span class="line"> <span class="comment">// CameraX core library using camera2 implementation</span></span><br><span class="line"><span class="keyword">implementation</span> <span class="string">"androidx.camera:camera-camera2:$camerax_version"</span></span><br><span class="line"> <span class="comment">// CameraX Lifecycle Library</span></span><br><span class="line"><span class="keyword">implementation</span> <span class="string">"androidx.camera:camera-lifecycle:$camerax_version"</span></span><br><span class="line"> <span class="comment">// CameraX View class</span></span><br><span class="line"><span class="keyword">implementation</span> <span class="string">"androidx.camera:camera-view:1.0.0-alpha11"</span></span><br></pre></td></tr></table></figure><h3 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">androidx.camera.view.PreviewView</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:id</span>=<span class="string">"@+id/viewFinder"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">android:layout_height</span>=<span class="string">"match_parent"</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>使用androidx.camera.view.PreviewView类。它是CameraX中显示预览用例的自定义视图。该类管理Surface生命周期，以及预览纵横比和方向。在它内部使用TextureView或SurfaceView来显示。</p><h3 id="实现预览"><a href="#实现预览" class="headerlink" title="实现预览"></a>实现预览</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">startCamera</span><span class="params">()</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> cameraProviderFuture = ProcessCameraProvider.getInstance(<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line">        cameraProviderFuture.addListener(Runnable &#123;</span><br><span class="line">            <span class="comment">// Used to bind the lifecycle of cameras to the lifecycle owner</span></span><br><span class="line">            <span class="keyword">val</span> cameraProvider: ProcessCameraProvider = cameraProviderFuture.<span class="keyword">get</span>()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Preview</span></span><br><span class="line">            preview = Preview.Builder()</span><br><span class="line">                    .build()</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Select back camera</span></span><br><span class="line">            <span class="keyword">val</span> cameraSelector = CameraSelector.Builder().requireLensFacing(CameraSelector.LENS_FACING_BACK).build()</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Unbind use cases before rebinding</span></span><br><span class="line">                cameraProvider.unbindAll()</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Bind use cases to camera</span></span><br><span class="line">                camera = cameraProvider.bindToLifecycle(</span><br><span class="line">                        <span class="keyword">this</span>, cameraSelector, preview)</span><br><span class="line">                preview?.setSurfaceProvider(viewFinder.createSurfaceProvider())</span><br><span class="line">            &#125; <span class="keyword">catch</span> (exc: Exception) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"Use case binding failed"</span>, exc)</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;, ContextCompat.getMainExecutor(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>就这样就可以实现Camera的预览功能，是不是很简单，想起之前写Camera2的痛苦，眼泪都快流下来了。</p><h3 id="拍照"><a href="#拍照" class="headerlink" title="拍照"></a>拍照</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在startCamera中增加</span></span><br><span class="line"><span class="comment">// ImageCapture</span></span><br><span class="line">imageCapture = ImageCapture.Builder()</span><br><span class="line">               .setCaptureMode(ImageCapture.CAPTURE_MODE_MINIMIZE_LATENCY)</span><br><span class="line">               .build()</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">takePhoto</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Get a stable reference of the modifiable image capture use case</span></span><br><span class="line">    <span class="keyword">val</span> imageCapture = imageCapture ?: <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create timestamped output file to hold the image</span></span><br><span class="line">    <span class="keyword">val</span> photoFile = File(</span><br><span class="line">            outputDirectory,</span><br><span class="line">            SimpleDateFormat(FILENAME_FORMAT, Locale.CHINA</span><br><span class="line">            ).format(System.currentTimeMillis()) + <span class="string">".jpg"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create output options object which contains file + metadata</span></span><br><span class="line">    <span class="keyword">val</span> outputOptions = ImageCapture.OutputFileOptions.Builder(photoFile).build()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Setup image capture listener which is triggered after photo has</span></span><br><span class="line">    <span class="comment">// been taken</span></span><br><span class="line">    imageCapture.takePicture(</span><br><span class="line">            outputOptions, ContextCompat.getMainExecutor(<span class="keyword">this</span>), <span class="keyword">object</span> : ImageCapture.OnImageSavedCallback &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onError</span><span class="params">(exc: <span class="type">ImageCaptureException</span>)</span></span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"Photo capture failed: <span class="subst">$&#123;exc.message&#125;</span>"</span>, exc)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onImageSaved</span><span class="params">(output: <span class="type">ImageCapture</span>.<span class="type">OutputFileResults</span>)</span></span> &#123;</span><br><span class="line">            <span class="keyword">val</span> savedUri = Uri.fromFile(photoFile)</span><br><span class="line">            <span class="keyword">val</span> msg = <span class="string">"Photo capture succeeded: <span class="variable">$savedUri</span>"</span></span><br><span class="line">            Toast.makeText(baseContext, msg, Toast.LENGTH_SHORT).show()</span><br><span class="line">            Log.d(TAG, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后绑定到Camera上</span></span><br><span class="line"><span class="comment">// Bind use cases to camera</span></span><br><span class="line">camera = cameraProvider.bindToLifecycle(</span><br><span class="line">          <span class="keyword">this</span>, cameraSelector, preview,imageCapture)</span><br></pre></td></tr></table></figure><p>完成了，这代码简洁程度简直爱了！</p><h3 id="图片分析"><a href="#图片分析" class="headerlink" title="图片分析"></a>图片分析</h3><p>写一个内部类，继承ImageAnalysis.Analyzer </p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">LuminosityAnalyzer</span></span>(<span class="keyword">private</span> <span class="keyword">val</span> listener: LumaListener) : ImageAnalysis.Analyzer &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> ByteBuffer.<span class="title">toByteArray</span><span class="params">()</span></span>: ByteArray &#123;</span><br><span class="line">        rewind()    <span class="comment">// Rewind the buffer to zero</span></span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = ByteArray(remaining())</span><br><span class="line">        <span class="keyword">get</span>(<span class="keyword">data</span>)   <span class="comment">// Copy the buffer into a byte array</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">data</span> <span class="comment">// Return the byte array</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">analyze</span><span class="params">(image: <span class="type">ImageProxy</span>)</span></span> &#123;</span><br><span class="line">        <span class="comment">//处理图片数据</span></span><br><span class="line">        <span class="keyword">val</span> buffer = image.planes[<span class="number">0</span>].buffer</span><br><span class="line">        <span class="keyword">val</span> <span class="keyword">data</span> = buffer.toByteArray()</span><br><span class="line">        <span class="keyword">val</span> pixels = <span class="keyword">data</span>.map &#123; it.toInt() and <span class="number">0xFF</span> &#125;</span><br><span class="line">        <span class="keyword">val</span> luma = pixels.average()</span><br><span class="line">        listener(luma)</span><br><span class="line">        image.close()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">imageAnalyzer</span> = ImageAnalysis.<span class="keyword">Builder()</span></span><br><span class="line"><span class="keyword"> </span>       .<span class="keyword">build()</span></span><br><span class="line"><span class="keyword"> </span>       .also &#123;</span><br><span class="line">            <span class="keyword">it.setAnalyzer(cameraExecutor, </span>LuminosityAnalyzer &#123; luma -&gt;</span><br><span class="line">                Log.d(TAG, <span class="string">"Average luminosity: $luma"</span>)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>绑定设备</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Bind use cases to camera</span></span><br><span class="line">camera = cameraProvider.bindToLifecycle(</span><br><span class="line">        <span class="keyword">this</span>, cameraSelector, preview, imageCapture, imageAnalyzer)</span><br></pre></td></tr></table></figure><p>仍然是这么简单！等CameraX正式版本发布，Camera2就扔到垃圾桶去吧。</p><p>记得申请权限啊！<code>Manifest.permission.CAMERA</code></p><p>可以翻墙的请看原文：<a href="https://codelabs.developers.google.com/codelabs/camerax-getting-started/#0" target="_blank" rel="noopener">Getting Started with CameraX</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;CameraX 是一个 Jetpack 支持库，旨在帮助您简化相机应用的开发工作。它提供一致且易于使用的 API 界面，适用于大多数 Android 设备，并可向后兼容至 Android 5.0（API 级别 21）。&lt;/p&gt;
&lt;p&gt;虽然它利用的是 camera2 的功能，
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="CameraX" scheme="http://yoursite.com/tags/CameraX/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-单例模式--LayoutInflater</title>
    <link href="http://yoursite.com/2020/02/23/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/23/设计模式-单例模式/</id>
    <published>2020-02-23T10:17:49.000Z</published>
    <updated>2020-03-04T08:08:16.397Z</updated>
    
    <content type="html"><![CDATA[<p>单例模式应该是我们在开发过程中使用的最多，最频繁的设计模式了。今天就再来学习一下，然后学习Android中单例模式使用–LayoutInflater。</p><h2 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h2><p>所谓单例，就是整个程序有且仅有一个实例。该类负责创建自己的对象，同时确保只有一个对象被创建。在Java，一般常用在工具类的实现或创建对象需要消耗资源。在Android中，创建一个对象需要的资源过多，如访问IO和数据库等资源，就要考虑使用单例模式。</p><p>UML类图如图：</p><p><img src="/2020/02/23/设计模式-单例模式/pic-01.png" alt=""></p><h3 id="懒汉模式"><a href="#懒汉模式" class="headerlink" title="懒汉模式"></a>懒汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程不安全，延迟初始化，严格意义上不是不是单例模式</p><h3 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">return</span> instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全，比较常用，但容易产生垃圾，因为一开始就初始化</p><h3 id="双重锁模式"><a href="#双重锁模式" class="headerlink" title="双重锁模式"></a>双重锁模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton singleton;  </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span> <span class="params">()</span></span>&#123;&#125;  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">    <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">        <span class="keyword">synchronized</span> (Singleton.class) &#123;  </span><br><span class="line">        <span class="keyword">if</span> (singleton == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            singleton = <span class="keyword">new</span> Singleton();  </span><br><span class="line">        &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">return</span> singleton;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程安全，延迟初始化。这种方式采用双锁机制，安全且在多线程情况下能保持高性能。</p><h3 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123; </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> Inner.instance;  </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton instance = <span class="keyword">new</span> Singleton();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有第一次调用getInstance方法时，虚拟机才加载 Inner 并初始化instance ，只有一个线程可以获得对象的初始化锁，其他线程无法进行初始化，保证对象的唯一性。目前此方式是所有单例模式中最推荐的模式，但具体还是根据项目选择。</p><h3 id="枚举单例模式"><a href="#枚举单例模式" class="headerlink" title="枚举单例模式"></a>枚举单例模式</h3><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="type">INSTANCE</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认枚举实例的创建是线程安全的，并且在任何情况下都是单例。</p><p>那么枚举类型日常用例是这样子的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton  &#123;</span><br><span class="line">    INSTANCE </span><br><span class="line"> </span><br><span class="line">    <span class="comment">//doSomething 该实例支持的行为</span></span><br><span class="line">      </span><br><span class="line">    <span class="comment">//可以省略此方法，通过Singleton.INSTANCE进行操作</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton get <span class="title">Instance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Singleton.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>枚举单例模式在《Effective Java》中推荐的单例模式之一。但枚举实例在日常开发是很少使用的，就是很简单以导致可读性较差。</p><p>在以上所有的单例模式中，推荐静态内部类单例模式。主要是非常直观，即保证线程安全又保证唯一性。</p><h2 id="Android中的单例模式–LayoutInflater"><a href="#Android中的单例模式–LayoutInflater" class="headerlink" title="Android中的单例模式–LayoutInflater"></a>Android中的单例模式–LayoutInflater</h2><p>在Android系统中，我们经常会通过Context获取系统级别的服务，如WindowsManagerService等，更常用的是一个LayoutInflater类，这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过Context的getSystemService(String name)获取。我们以LayoutInflater为例来说明。</p><p>在Listview中LayoutInflater相关代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LayoutInflater inflater;</span><br><span class="line">inflater = (LayoutInflater) <span class="keyword">this</span>.context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">getView</span><span class="params">(<span class="keyword">int</span> position, View convertView, ViewGroup parent)</span> </span>&#123;</span><br><span class="line">ViewHolder viewHolder = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">if</span>(convertView==<span class="keyword">null</span>)&#123;</span><br><span class="line">convertView = inflater.inflate(mResourceId, parent,<span class="keyword">false</span>);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到我们使用Context类的getSystemService()获取到了LayoutInflater实例对象，我们追踪到Context类看到，该类是抽象类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么getView中使用的Context对象的具体实现类是什么呢？其实在Application、Activity、Service中都会存在一个Context对象，即Context的总个数为Activity个数+Service个数+1。而ListView通常是显示在Activity中，那么我们就以Activity中的Context来分析。</p><p>我们知道，一个Activity的入口是ActivityThread中的main函数，在main函数中创建一个新的ActivityThread对象，并且启动消息循环（UI线程），创建新的Activity、新的Context对象，然后将该Context对象传递给Activity。下面看ActivityThread源代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">   ...</span><br><span class="line">       </span><br><span class="line">    Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);</span><br><span class="line">    <span class="comment">//主线程消息循环</span></span><br><span class="line">    Looper.prepareMainLooper();</span><br><span class="line">    <span class="comment">//创建一个新的ActivityThread对象</span></span><br><span class="line">    ActivityThread thread = <span class="keyword">new</span> ActivityThread();</span><br><span class="line">    thread.attach(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">        sMainThreadHandler = thread.getHandler();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">        </span><br><span class="line">    Looper.loop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(<span class="keyword">boolean</span> system)</span> </span>&#123;</span><br><span class="line">    sCurrentActivityThread = <span class="keyword">this</span>;</span><br><span class="line">    mSystemThread = system;</span><br><span class="line">    <span class="comment">//不是系统应用的情况</span></span><br><span class="line">    <span class="keyword">if</span> (!system) &#123;</span><br><span class="line">        ViewRootImpl.addFirstDrawHandler(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                ensureJitEnabled();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        android.ddm.DdmHandleAppName.setAppName(<span class="string">"&lt;pre-initialized&gt;"</span>,</span><br><span class="line">                                                UserHandle.myUserId());</span><br><span class="line">        RuntimeInit.setApplicationObject(mAppThread.asBinder());</span><br><span class="line">        <span class="comment">//通过AIDL，获取AMS的代理对象IActivityManager</span></span><br><span class="line">        <span class="keyword">final</span> IActivityManager mgr = ActivityManager.getService();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//关联mAppThread，将AMS和我们的应用进程application进行连接</span></span><br><span class="line">            mgr.attachApplication(mAppThread);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在attach函数中，在非系统应用情况下，会通过Binder机制与AMS通信，最终调用handleLaunchActivity函数。</p><p>Activity的启动流程如下:</p><p><img src="/2020/02/23/设计模式-单例模式/start_activity_process.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent, String reason)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">     ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">     Activity activity = <span class="keyword">null</span>;</span><br><span class="line">     <span class="keyword">try</span> &#123;</span><br><span class="line">            java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">            <span class="comment">//创建新Activity</span></span><br><span class="line">            activity = mInstrumentation.newActivity(</span><br><span class="line">                    cl, component.getClassName(), r.intent);</span><br><span class="line">           </span><br><span class="line">     &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           </span><br><span class="line">     &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">            Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line">            <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                appContext.setOuterContext(activity);</span><br><span class="line">                activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                        r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                        r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                        r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ContextImpl <span class="title">createBaseContextForActivity</span><span class="params">(ActivityClientRecord r)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建Context对象，实现类为ContextImpl</span></span><br><span class="line">    ContextImpl appContext = ContextImpl.createActivityContext(</span><br><span class="line">            <span class="keyword">this</span>, r.packageInfo, r.activityInfo, r.token, displayId, r.overrideConfig);</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">return</span> appContext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从上面的代码可以分析得知，Context的实现类为ContextImpl，继续分析ContextImpl类。在ContextImpl中使用getSystemService获取对应的系统服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContextImpl</span> <span class="keyword">extends</span> <span class="title">Context</span> </span>&#123;</span><br><span class="line">     <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getSystemService</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SystemServiceRegistry.getSystemService(<span class="keyword">this</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getSystemServiceName</span><span class="params">(Class&lt;?&gt; serviceClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SystemServiceRegistry.getSystemServiceName(serviceClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">SystemServiceRegistry</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">     registerService(Context.LAYOUT_INFLATER_SERVICE, LayoutInflater.class,</span><br><span class="line">                <span class="keyword">new</span> CachedServiceFetcher&lt;LayoutInflater&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">createService</span><span class="params">(ContextImpl ctx)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(ctx.getOuterContext());</span><br><span class="line">            &#125;&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String serviceName, Class&lt;T&gt; serviceClass,</span></span></span><br><span class="line"><span class="function"><span class="params">            ServiceFetcher&lt;T&gt; serviceFetcher)</span> </span>&#123;</span><br><span class="line">        SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName);</span><br><span class="line">        SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在静态代码中注册了LAYOUT_INFLATER_SERVICE。在第一次调用时，createService会创建服务对象，然后将服务以键值对的形式存储在一个HashMap中，用户后面只需要通过Key值就能获取到对应的服务，从而达到单例的效果。</p><h2 id="深入理解LayoutInflater"><a href="#深入理解LayoutInflater" class="headerlink" title="深入理解LayoutInflater"></a>深入理解LayoutInflater</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>LayoutInflater是一个抽象类，而在上面的代码中，我们看到注册LAYOUT_INFLATER_SERVICE服务时，创建的是一个PhoneLayoutInflater，所以它才是真正的实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhoneLayoutInflater</span> <span class="keyword">extends</span> <span class="title">LayoutInflater</span> </span>&#123;</span><br><span class="line">    <span class="comment">//内置View的前缀，如TextView的完整路径为android.widget.TextView</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] sClassPrefixList = &#123;</span><br><span class="line">        <span class="string">"android.widget."</span>,</span><br><span class="line">        <span class="string">"android.webkit."</span>,</span><br><span class="line">        <span class="string">"android.app."</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PhoneLayoutInflater</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">PhoneLayoutInflater</span><span class="params">(LayoutInflater original, Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(original, newContext);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span> <span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span> <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String prefix : sClassPrefixList) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                View view = createView(name, prefix, attrs);</span><br><span class="line">                <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">return</span> view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.onCreateView(name, attrs);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LayoutInflater <span class="title">cloneInContext</span><span class="params">(Context newContext)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PhoneLayoutInflater(<span class="keyword">this</span>, newContext);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PhoneLayoutInflater中的代码核心就是onCreateView方法，该方法是在传递进来的View名称前加上sClassPrefixList中的前缀，用来得到该内置View类的完整路径，最后在根据该路径来构建对应的View对象。</p><p>那么LayoutInflater 到底是怎么实现解析 XML 里面的 View，这个还得从Activity的 setContentView(view) 说起。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此处的 getWindow 返回的就是View的容器 PhoneWindow。mWinodw的创建是 Activity 的 attah方法中进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span></span></span><br><span class="line"><span class="function"><span class="params">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span></span></span><br><span class="line"><span class="function"><span class="params">        Application application, Intent intent, ActivityInfo info,</span></span></span><br><span class="line"><span class="function"><span class="params">        CharSequence title, Activity parent, String id,</span></span></span><br><span class="line"><span class="function"><span class="params">        NonConfigurationInstances lastNonConfigurationInstances,</span></span></span><br><span class="line"><span class="function"><span class="params">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span></span></span><br><span class="line"><span class="function"><span class="params">        Window window, ActivityConfigCallback activityConfigCallback)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window, activityConfigCallback);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>我们再看PhoneWindow中的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        installDecor();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">        mContentParent.removeAllViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后还是调用 LaytouInflater 里面的方法了。</p><p>在看inflate方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(@LayoutRes <span class="keyword">int</span> resource, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//首先把 XML 转换成 XML 资源</span></span><br><span class="line">    <span class="keyword">final</span> Resources res = getContext().getResources();</span><br><span class="line">    <span class="keyword">final</span> XmlResourceParser parser = res.getLayout(resource);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// parser 代表 XML 解析器，root 代表父类布局 ，attachToRoot 代表是否添加到 root 视图 </span></span><br><span class="line">        <span class="keyword">return</span> inflate(parser, root, attachToRoot);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        parser.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> View <span class="title">inflate</span><span class="params">(XmlPullParser parser, @Nullable ViewGroup root, <span class="keyword">boolean</span> attachToRoot)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (mConstructorArgs) &#123;</span><br><span class="line">           <span class="keyword">final</span> Context inflaterContext = mContext;</span><br><span class="line">           <span class="keyword">final</span> AttributeSet attrs = Xml.asAttributeSet(parser);</span><br><span class="line">           Context lastContext = (Context) mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">           mConstructorArgs[<span class="number">0</span>] = inflaterContext;</span><br><span class="line">           View result = root;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// Look for the root node.</span></span><br><span class="line">               <span class="keyword">int</span> type;</span><br><span class="line">               <span class="keyword">while</span> ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;</span><br><span class="line">                       type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line">                   <span class="comment">// Empty</span></span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//获取 xml 资源的第一个字符串</span></span><br><span class="line">               <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">               <span class="comment">//如果是merge的话，则直接解析root下面的视图树</span></span><br><span class="line">               <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; can be used only with a valid "</span></span><br><span class="line">                               + <span class="string">"ViewGroup root and attachToRoot=true"</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   rInflate(parser, root, inflaterContext, attrs, <span class="keyword">false</span>);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">//根据 xml 的 tag 来解析 layout 的根视图。name 就是要 </span></span><br><span class="line">                   <span class="comment">//解析的视图的类名。如 LinearLayout。</span></span><br><span class="line">                   <span class="keyword">final</span> View temp = createViewFromTag(root, name, inflaterContext, attrs);</span><br><span class="line"></span><br><span class="line">                   ViewGroup.LayoutParams params = <span class="keyword">null</span>;</span><br><span class="line">                       params = root.generateLayoutParams(attrs);</span><br><span class="line">                       <span class="keyword">if</span> (!attachToRoot) &#123;</span><br><span class="line">   </span><br><span class="line">                           temp.setLayoutParams(params);</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                  rInflate(parser, temp, attrs, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">               </span><br><span class="line">                   <span class="keyword">if</span> (root != <span class="keyword">null</span> &amp;&amp; attachToRoot) &#123;</span><br><span class="line">                       root.addView(temp, params);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (root == <span class="keyword">null</span> || !attachToRoot) &#123;</span><br><span class="line">                       result = temp;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">       &#125;</span><br><span class="line">           <span class="keyword">return</span> result;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>此方法做了以下事情：<br>1、根据 id，生成 XmlPullParser<br>2.如果是 merge ，则直接解析 merge 下的所有子View，这也说明了 为什么 merge 标签为什么会减少一层视图的原因，因为根本没有进入 else 的逻辑。<br>3.如果不是 merge，则进入 else，调用 createViewFromTag 来解析根视图，并赋值给temp<br>4.调用 rInflate ，解析 temp 下面的视图，并将这些视图添加到 temp 中。</p><p>首先看createViewFromTag：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">View <span class="title">createViewFromTag</span><span class="params">(View parent, String name, Context context, AttributeSet attrs,</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="keyword">boolean</span> ignoreThemeAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name.equals(<span class="string">"view"</span>)) &#123;</span><br><span class="line">        name = attrs.getAttributeValue(<span class="keyword">null</span>, <span class="string">"class"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        View view;<span class="comment">// 最后要返回的 View</span></span><br><span class="line">        <span class="keyword">if</span> (mFactory2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory2.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mFactory.onCreateView(name, context, attrs);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            view = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span> &amp;&amp; mPrivateFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">            view = mPrivateFactory.onCreateView(parent, name, context, attrs);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123; <span class="comment">// 如果 Factory 都没有设置过，最后在生成 View</span></span><br><span class="line">            <span class="keyword">final</span> Object lastContext = mConstructorArgs[<span class="number">0</span>];</span><br><span class="line">            mConstructorArgs[<span class="number">0</span>] = context;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (-<span class="number">1</span> == name.indexOf(<span class="string">'.'</span>)) &#123; <span class="comment">// 系统控件 </span></span><br><span class="line">                    view = onCreateView(parent, name, attrs);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;<span class="comment">// 非系统控件，自定义的 View </span></span><br><span class="line">                    view = createView(name, <span class="keyword">null</span>, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mConstructorArgs[<span class="number">0</span>] = lastContext;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> view;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当 name 没有包含 ”.“ 的时候，我们认为他是内置布局组件。</p><p>比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>而自定义View则需要写完整的路径。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">com.test.TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>所以实际上onCreate只是像我们上面说的添加了前缀。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> View <span class="title">onCreateView</span><span class="params">(String name, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createView(name, <span class="string">"android.view."</span>, attrs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终还是调用createView方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> View <span class="title">createView</span><span class="params">(String name, String prefix, AttributeSet attrs)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> ClassNotFoundException, InflateException </span>&#123;</span><br><span class="line">    Constructor&lt;? extends View&gt; constructor = sConstructorMap.get(name);</span><br><span class="line">    Class&lt;? extends View&gt; clazz = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Trace.traceBegin(Trace.TRACE_TAG_VIEW, name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Class not found in the cache, see if it's real, and try to add it</span></span><br><span class="line">            <span class="comment">//如果 prefix 不为空，则需要填写完整路径</span></span><br><span class="line">            clazz = mContext.getClassLoader().loadClass(</span><br><span class="line">                    prefix != <span class="keyword">null</span> ? (prefix + name) : name).asSubclass(View.class);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (mFilter != <span class="keyword">null</span> &amp;&amp; clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> allowed = mFilter.onLoadClass(clazz);</span><br><span class="line">                <span class="keyword">if</span> (!allowed) &#123;</span><br><span class="line">                    failNotAllowed(name, prefix, attrs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//获取构造函数</span></span><br><span class="line">            constructor = clazz.getConstructor(mConstructorSignature);</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//将构造函数存入缓存</span></span><br><span class="line">            sConstructorMap.put(name, constructor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        、、、</span><br><span class="line">         Object[] args = mConstructorArgs;</span><br><span class="line">        args[<span class="number">1</span>] = attrs;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过反射构造View</span></span><br><span class="line">        <span class="keyword">final</span> View view = constructor.newInstance(args);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>createView相对简单，如果有前缀，那么构造View的完整路径，并将该类加载到虚拟机中，然后获取该类的构造函数并缓存，再通过构造函数创建该View对象，最后将该对象返回。</p><p>而我们的窗口是一颗视图树，LayoutInflater需要解析完这棵树，就交给rInflate方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rInflate</span><span class="params">(XmlPullParser parser, View parent, Context context,</span></span></span><br><span class="line"><span class="function"><span class="params">           AttributeSet attrs, <span class="keyword">boolean</span> finishInflate)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//获取树的深度，深度优先遍历</span></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> depth = parser.getDepth();</span><br><span class="line">       <span class="keyword">int</span> type;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">while</span> (((type = parser.next()) != XmlPullParser.END_TAG ||</span><br><span class="line">               parser.getDepth() &gt; depth) &amp;&amp; type != XmlPullParser.END_DOCUMENT) &#123;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">if</span> (type != XmlPullParser.START_TAG) &#123;</span><br><span class="line">               <span class="keyword">continue</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">final</span> String name = parser.getName();</span><br><span class="line">           </span><br><span class="line">           <span class="keyword">if</span> (TAG_REQUEST_FOCUS.equals(name)) &#123;</span><br><span class="line">               parseRequestFocus(parser, parent);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_TAG.equals(name)) &#123;</span><br><span class="line">               parseViewTag(parser, parent, attrs);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_INCLUDE.equals(name)) &#123;</span><br><span class="line">               <span class="keyword">if</span> (parser.getDepth() == <span class="number">0</span>) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;include /&gt; cannot be the root element"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               parseInclude(parser, context, parent, attrs);</span><br><span class="line">           &#125; <span class="keyword">else</span> <span class="keyword">if</span> (TAG_MERGE.equals(name)) &#123;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> InflateException(<span class="string">"&lt;merge /&gt; must be the root element"</span>);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">final</span> View view = createViewFromTag(parent, name, context, attrs);</span><br><span class="line">               <span class="keyword">final</span> ViewGroup viewGroup = (ViewGroup) parent;</span><br><span class="line">               <span class="keyword">final</span> ViewGroup.LayoutParams params = viewGroup.generateLayoutParams(attrs);</span><br><span class="line">               rInflateChildren(parser, view, attrs, <span class="keyword">true</span>);</span><br><span class="line">               viewGroup.addView(view, params);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (finishInflate) &#123;</span><br><span class="line">           parent.onFinishInflate();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>分为 3 步：<br>1.获取树的高度，深度优先遍历<br>2.while 循环，挨个元素进行解析<br>3.根据元素名进行解析，递归调用进行解析，将解析到的 View 添加到 ViewGroup 中。</p><p>当调用了Activity的onResume方法后，通过setContextView设置的内容就会出现在我们视野中。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;单例模式应该是我们在开发过程中使用的最多，最频繁的设计模式了。今天就再来学习一下，然后学习Android中单例模式使用–LayoutInflater。&lt;/p&gt;
&lt;h2 id=&quot;单例模式&quot;&gt;&lt;a href=&quot;#单例模式&quot; class=&quot;headerlink&quot; title=&quot;单
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>设计模式-UML类图</title>
    <link href="http://yoursite.com/2020/02/22/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-UML%E7%B1%BB%E5%9B%BE/"/>
    <id>http://yoursite.com/2020/02/22/设计模式-UML类图/</id>
    <published>2020-02-22T06:40:58.000Z</published>
    <updated>2020-03-04T08:08:22.765Z</updated>
    
    <content type="html"><![CDATA[<p>学习设计模式前先了解下UML类图，书里面会有很多地方用到，不了解UML看下去会很难受。这里主要是用《大话设计模式》中的UML部分。</p><p>先上图，截自《大话设计模式》。图中包含了UML类图中的基本图示法，我们再一一解释。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-01.png" alt=""></p><h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>在上图中，动物的矩形框表示一个类（Class），框中分割成了三层，最上面一层表示类的名称，如果是抽象类，就使用斜体来表示。第二层是类的特性，一般为类的字段和属性。第三层是类的操作。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-02.png" alt=""></p><h3 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h3><p>接口的表示有两种。第一种为左下角 ‘飞翔’ 接口，在接口名称上有《interface》表示。第二种为棒棒糖表示法，正下方唐老鸭讲话的接口，有一个圆圈加直线表示。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-03.png" alt=""></p><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="1、继承关系"><a href="#1、继承关系" class="headerlink" title="1、继承关系"></a>1、继承关系</h3><p>继承关系使用空心三角形+实线来表示，如鸟类继承抽象类动物。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-04.png" alt=""></p><h3 id="2、实现关系"><a href="#2、实现关系" class="headerlink" title="2、实现关系"></a>2、实现关系</h3><p>实现关系用来规定接口和实现接口的类或组件之间的关系。接口可以看作是操作的集合，这些操作用于规定类或组件的服务。在UML中，<strong>用一个带空心箭头的虚线来表示</strong>。如图，大雁实现了飞翔的接口。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-05.png" alt=""></p><h3 id="3、关联关系"><a href="#3、关联关系" class="headerlink" title="3、关联关系"></a>3、关联关系</h3><p>关联关系表示两个类之间存在某种语义上的联系，比如一个公司有多个部门，一个部门有多个员工。关联关系是所有关系语义最弱的关联。关联可以是双向的，也可以是单向的。双向的关联可以有两个箭头或者没有箭头，单向的关联有一个箭头。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-07.png" alt=""></p><p><img src="/2020/02/22/设计模式-UML类图/UML-06.png" alt=""></p><h3 id="4、聚合关系"><a href="#4、聚合关系" class="headerlink" title="4、聚合关系"></a>4、聚合关系</h3><p>聚合关系是一种特殊的关联关系。聚合关系表示了类之间的整体与部分的关系。整体与部分之间并没有相同的生命周期，整体消亡后部分可依旧存在。在UML中<strong>用带有空心菱形的实线表示，空心菱形指向代表整体的类</strong>。比如在大雁和雁群就是聚合关系，每只大雁都属于一个雁群，每个雁群又有多只大雁。再比如电脑是由CPU、主板等组成的。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-08.png" alt=""></p><h3 id="5、组合关系"><a href="#5、组合关系" class="headerlink" title="5、组合关系"></a>5、组合关系</h3><p>组合关系也是部分和整体的关系，相对聚合关系，组合关系中的部分和整体联系更为紧密。整体与部分之间有相同的生命周期，整体消亡后部分也随之消亡。UML中<strong>用带有实心菱形的实线表示</strong>。比如，鸟和其翅膀就是组合关系，翅膀和鸟的生命周期是相同的。连线下的数字被称为基数，一只鸟是有两支翅膀的。如果一个类可能有无数个实例，就用n来表示。关联关系、聚合关系也可以有基数的。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-09.png" alt=""></p><h3 id="6、依赖关系"><a href="#6、依赖关系" class="headerlink" title="6、依赖关系"></a>6、依赖关系</h3><p>有两个元素X、Y,如果修改X的定义可能会引起对Y的定义修改，则称Y依赖与元素X。比如说动物要生存必须要有空气和水，也就是动物依赖空气和水。在UML中<strong>用虚线箭头来表示</strong>。</p><p><img src="/2020/02/22/设计模式-UML类图/UML-10.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习设计模式前先了解下UML类图，书里面会有很多地方用到，不了解UML看下去会很难受。这里主要是用《大话设计模式》中的UML部分。&lt;/p&gt;
&lt;p&gt;先上图，截自《大话设计模式》。图中包含了UML类图中的基本图示法，我们再一一解释。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2020
      
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="UML" scheme="http://yoursite.com/tags/UML/"/>
    
  </entry>
  
  <entry>
    <title>微信小程序蓝牙开发</title>
    <link href="http://yoursite.com/2019/10/25/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%93%9D%E7%89%99%E5%BC%80%E5%8F%91/"/>
    <id>http://yoursite.com/2019/10/25/微信小程序蓝牙开发/</id>
    <published>2019-10-25T02:10:46.000Z</published>
    <updated>2019-11-15T01:54:27.200Z</updated>
    
    <content type="html"><![CDATA[<p>这几天完成了一个微信小程序的蓝牙操作功能，发现微信对蓝牙的操作与我们平时在Android上的蓝牙操作有一些不同，而且微信小程序在文档上有些东西并没有讲清楚，导致走了一些弯路，所以在这里分享下微信小程序的蓝牙开发流程。</p><p><img src="/2019/10/25/微信小程序蓝牙开发/wechat-ble.png" alt=""></p><p>图中展示的是微信小程序蓝牙操作的主要流程。</p><p>主要的流程跟我们在Android上开发流程一致。就是在连接流程中会有特征值的获取。</p><p><img src="/2019/10/25/微信小程序蓝牙开发/2.png" alt=""></p><p>共有4种特征值。对应的特征值会有对应的操作。例如特征值可写的时候我们才能向对应特征值发送数据，否则失败。</p><p>在发送数据时小程序不会对写入数据包大小做限制，但系统与蓝牙设备会限制蓝牙4.0单次传输的数据大小，超过最大字节数后会发生写入错误，建议每次写入不超过20字节。</p><p>具体的函数请看<a href="https://developers.weixin.qq.com/miniprogram/dev/api/device/bluetooth/wx.openBluetoothAdapter.html" target="_blank" rel="noopener">微信API</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这几天完成了一个微信小程序的蓝牙操作功能，发现微信对蓝牙的操作与我们平时在Android上的蓝牙操作有一些不同，而且微信小程序在文档上有些东西并没有讲清楚，导致走了一些弯路，所以在这里分享下微信小程序的蓝牙开发流程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/2019/10/25
      
    
    </summary>
    
      <category term="微信小程序" scheme="http://yoursite.com/categories/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
    
      <category term="微信小程序" scheme="http://yoursite.com/tags/%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>Android音视频(六) 使用OpenGL ES 3.0预览Camera</title>
    <link href="http://yoursite.com/2019/10/11/Android%E9%9F%B3%E8%A7%86%E9%A2%91-%E5%85%AD-%E4%BD%BF%E7%94%A8OpenGL-ES-3-0%E9%A2%84%E8%A7%88Camera2/"/>
    <id>http://yoursite.com/2019/10/11/Android音视频-六-使用OpenGL-ES-3-0预览Camera2/</id>
    <published>2019-10-11T06:48:32.000Z</published>
    <updated>2019-10-13T02:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚学习了OpenGL的纹理相关知识，终于可以接着写Android音视频系列了。</p><p>本篇博客会介绍使用OpenGL ES 3.0相关知识预览Camera，并且提供Camera和Camera2两个版本实现。</p><h2 id="整体流程"><a href="#整体流程" class="headerlink" title="整体流程"></a>整体流程</h2><ol><li>在 GLSurfaceView.Render 中创建一个纹理，再使用该纹理创建一个 SurfaceTexture。</li><li>将该SurfaceTexture 作为相机预览输出<ul><li>使用Camera时直接将该SurfaceTexture传给相机。</li><li>使用Camera2时使用该SurfaceTexture创建一个 Surface 传给相机。</li></ul></li><li>使用 GLSurfaceView.Render 将该纹理渲染到 GLSurfaceView 窗口上。</li><li>使用 GLSurfaceTexture 的 setOnFrameAvailableListener 方法给 SurfaceTexture 添加一个数据帧数据可用的监听器，在监听器中调用 GLSurfaceView 的 requestRender 方法渲染该帧数据，这样相机每次输出一帧数据就可以渲染一次，就可以在GLSurfaceView窗口中看到相机的预览数据了。</li></ol><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>顶点着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec4 vPosition;</span><br><span class="line">layout (location = <span class="number">1</span>) in vec4 aTextureCoord;</span><br><span class="line"><span class="comment">//纹理矩阵</span></span><br><span class="line">uniform mat4 uTextureMatrix;</span><br><span class="line">out vec2 yuvTexCoords;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    gl_Position  = vPosition;</span><br><span class="line">    gl_PointSize = <span class="number">10.0</span>;</span><br><span class="line">    <span class="comment">//只保留x和y分量</span></span><br><span class="line">    yuvTexCoords = (uTextureMatrix * aTextureCoord).xy;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es</span></span><br><span class="line"><span class="comment">//OpenGL ES3.0外部纹理扩展</span></span><br><span class="line"><span class="meta">#extension GL_OES_EGL_image_external_essl3 : require</span></span><br><span class="line">precision mediump <span class="keyword">float</span>;</span><br><span class="line">uniform samplerExternalOES yuvTexSampler;</span><br><span class="line">in vec2 yuvTexCoords;</span><br><span class="line">out vec4 vFragColor;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vFragColor = texture(yuvTexSampler, yuvTexCoords);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>纹理的类型需要使用 samplerExternalOES ，而不是之前渲染图片的 sampler2D。</p><p>我们知道Android相机输出的原始数据一般都为YUV数据，而在OpenGL中使用的绝大部分纹理ID都是RGBA的格式，所以原始数据都是无法直接用OpenGL ES来渲染的。所以我们添加了一个扩展<code>#extension GL_OES_EGL_image_external_essl3 : require</code>，其中定义了一个纹理的扩展类型<code>GL_TEXTURE_EXTERNAL_OES</code>。后面绑定纹理时需要绑定到<code>GL_TEXTURE_EXTERNAL_OES</code>上，而不是类型GL_TEXTURE_2D上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 加载外部纹理</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">loadTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] tex = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//创建一个纹理</span></span><br><span class="line">    GLES30.glGenTextures(<span class="number">1</span>, tex, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">//绑定到外部纹理上</span></span><br><span class="line">    GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, tex[<span class="number">0</span>]);</span><br><span class="line">    <span class="comment">//设置纹理过滤参数</span></span><br><span class="line">    GLES30.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_NEAREST);</span><br><span class="line">    GLES30.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);</span><br><span class="line">    GLES30.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES30.GL_TEXTURE_WRAP_S, GLES30.GL_CLAMP_TO_EDGE);</span><br><span class="line">    GLES30.glTexParameterf(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, GLES30.GL_TEXTURE_WRAP_T, GLES30.GL_CLAMP_TO_EDGE);</span><br><span class="line">    <span class="comment">//解除纹理绑定</span></span><br><span class="line">    GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> tex[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Camera"><a href="#Camera" class="headerlink" title="Camera"></a>Camera</h2><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CameraSurfaceRenderer</span><span class="params">(GLSurfaceView glSurfaceView)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//前置摄像头</span></span><br><span class="line">    <span class="keyword">this</span>.mCameraId = Camera.CameraInfo.CAMERA_FACING_FRONT; </span><br><span class="line">    <span class="comment">//传入的SurfaceView</span></span><br><span class="line">    <span class="keyword">this</span>.mGLSurfaceView = glSurfaceView;</span><br><span class="line">    <span class="comment">// 打开Camera</span></span><br><span class="line">    mCamera = Camera.open(mCameraId);</span><br><span class="line">    <span class="comment">// 设置预览角度</span></span><br><span class="line">    setCameraDisplayOrientation(mCameraId, mCamera);</span><br><span class="line">    </span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onSurfaceCreated"><a href="#onSurfaceCreated" class="headerlink" title="onSurfaceCreated"></a>onSurfaceCreated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//设置背景颜色</span></span><br><span class="line">GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line"><span class="comment">//编译</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = RenderUtil.compileShader(GLES30.GL_VERTEX_SHADER,ResReadUtils.readResource(R.raw.vertex_camera_shader));</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = RenderUtil.compileShader(GLES30.GL_FRAGMENT_SHADER,ResReadUtils.readResource(R.raw.fragment_camera_shader));</span><br><span class="line"><span class="comment">//链接程序片段</span></span><br><span class="line">mProgram = RenderUtil.linkProgram(vertexShaderId, fragmentShaderId);</span><br><span class="line"></span><br><span class="line">uTextureMatrixLocation = GLES30.glGetUniformLocation(mProgram, <span class="string">"uTextureMatrix"</span>);</span><br><span class="line"><span class="comment">//获取Shader中定义的变量在program中的位置</span></span><br><span class="line">uTextureSamplerLocation = GLES30.glGetUniformLocation(mProgram, <span class="string">"yuvTexSampler"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//加载纹理</span></span><br><span class="line">textureId = loadTexture();</span><br><span class="line"><span class="comment">//加载SurfaceTexture</span></span><br><span class="line">loadSurfaceTexture(textureId);</span><br></pre></td></tr></table></figure><p>其实前面部分和加载图片没有什么区别，最后两行，对应上面流程中的1、2步。创建纹理，绑定外部纹理，然后根据纹理ID创建SurfaceTexture作为相机预览输出。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">loadSurfaceTexture</span><span class="params">(<span class="keyword">int</span> textureId)</span> </span>&#123;</span><br><span class="line">       <span class="comment">//根据纹理ID创建SurfaceTexture</span></span><br><span class="line">       mSurfaceTexture = <span class="keyword">new</span> SurfaceTexture(textureId);</span><br><span class="line">       mSurfaceTexture.setOnFrameAvailableListener(<span class="keyword">new</span> SurfaceTexture.OnFrameAvailableListener() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">(SurfaceTexture surfaceTexture)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// 渲染帧数据</span></span><br><span class="line">               mGLSurfaceView.requestRender();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">       <span class="comment">//SurfaceTexture作为相机预览输出</span></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           mCamera.setPreviewTexture(mSurfaceTexture);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//开启相机预览</span></span><br><span class="line">       mCamera.startPreview();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">    GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用程序片段</span></span><br><span class="line">    GLES30.glUseProgram(mProgram);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//更新纹理图像</span></span><br><span class="line">    mSurfaceTexture.updateTexImage();</span><br><span class="line">    mSurfaceTexture.getTransformMatrix(transformMatrix);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//激活纹理单元0</span></span><br><span class="line">    GLES30.glActiveTexture(GLES30.GL_TEXTURE0);</span><br><span class="line">    <span class="comment">//绑定外部纹理到纹理单元0</span></span><br><span class="line">    GLES30.glBindTexture(GLES11Ext.GL_TEXTURE_EXTERNAL_OES, textureId);</span><br><span class="line">    <span class="comment">//将此纹理单元床位片段着色器的uTextureSampler外部纹理采样器</span></span><br><span class="line">    GLES30.glUniform1i(uTextureSamplerLocation, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将纹理矩阵传给片段着色器</span></span><br><span class="line">    GLES30.glUniformMatrix4fv(uTextureMatrixLocation, <span class="number">1</span>, <span class="keyword">false</span>, transformMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    GLES30.glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    GLES30.glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, mTexVertexBuffer);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    GLES20.glDrawElements(GLES20.GL_TRIANGLES, VERTEX_INDEX.length, GLES20.GL_UNSIGNED_SHORT, mVertexIndexBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Activity显示"><a href="#Activity显示" class="headerlink" title="Activity显示"></a>Activity显示</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//实例化一个GLSurfaceView</span></span><br><span class="line">    mGLSurfaceView = <span class="keyword">new</span> GLSurfaceView(<span class="keyword">this</span>);</span><br><span class="line">    mGLSurfaceView.setEGLContextClientVersion(<span class="number">3</span>);</span><br><span class="line">    mGLSurfaceView.setRenderer(<span class="keyword">new</span> CameraSurfaceRenderer(mGLSurfaceView));</span><br><span class="line">    setContentView(mGLSurfaceView);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Camera2"><a href="#Camera2" class="headerlink" title="Camera2"></a>Camera2</h2><p>使用Camera2在OpenGL方面其实是一样的，并没有什么改动。所以只需要看一下Camera2的调用就好。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl, EGLConfig config)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"Renderer"</span>, <span class="string">"onSurfaceCreated"</span>);</span><br><span class="line">        <span class="comment">//加载纹理</span></span><br><span class="line">        textureId = loadTexture();</span><br><span class="line">        <span class="comment">//创建SurfaceTexture，放到前面是为了防止Camera打开后获取SurfaceTexture为空</span></span><br><span class="line">        mSurfaceTexture = <span class="keyword">new</span> SurfaceTexture(textureId);</span><br><span class="line"><span class="comment">//设置背景颜色</span></span><br><span class="line">        GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line">        <span class="comment">//编译</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = RenderUtil.compileShader(GLES30.GL_VERTEX_SHADER, ResReadUtils.readResource(R.raw.vertex_camera_shader));</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = RenderUtil.compileShader(GLES30.GL_FRAGMENT_SHADER, ResReadUtils.readResource(R.raw.fragment_camera_shader));</span><br><span class="line">        <span class="comment">//链接程序片段</span></span><br><span class="line">        mProgram = RenderUtil.linkProgram(vertexShaderId, fragmentShaderId);</span><br><span class="line"></span><br><span class="line">        uTextureMatrixLocation = GLES30.glGetUniformLocation(mProgram, <span class="string">"uTextureMatrix"</span>);</span><br><span class="line">        <span class="comment">//获取Shader中定义的变量在program中的位置</span></span><br><span class="line">        uTextureSamplerLocation = GLES30.glGetUniformLocation(mProgram, <span class="string">"yuvTexSampler"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提供方法获取SurfaceTexture</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> SurfaceTexture <span class="title">getSurfaceTexture</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mSurfaceTexture;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       cameraManager = (CameraManager) MyApplication.getApplication().getSystemService(Context.CAMERA_SERVICE);</span><br><span class="line">       <span class="comment">//获取指定相机的输出尺寸列表</span></span><br><span class="line">       outputSizes = getCameraOutputSizes(cameraId, SurfaceTexture.class);</span><br><span class="line">       photoSize = outputSizes.get(<span class="number">1</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="打开摄像头"><a href="#打开摄像头" class="headerlink" title="打开摄像头"></a>打开摄像头</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SuppressLint</span>(<span class="string">"MissingPermission"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">openCamera</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cameraManager.openCamera(String.valueOf(cameraId), cameraStateCallback, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.e(TAG, <span class="string">"openCamera fail"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">CameraDevice.StateCallback cameraStateCallback = <span class="keyword">new</span> CameraDevice.StateCallback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onOpened</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//从Renderer中获取SurfaceTexture</span></span><br><span class="line">        surfaceTexture = camera2SurfaceRenderer.getSurfaceTexture();</span><br><span class="line">        <span class="keyword">if</span> (surfaceTexture == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        surfaceTexture.setDefaultBufferSize(photoSize.getWidth(), photoSize.getHeight());</span><br><span class="line">        surfaceTexture.setOnFrameAvailableListener(<span class="keyword">new</span> SurfaceTexture.OnFrameAvailableListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFrameAvailable</span><span class="params">(<span class="keyword">final</span> SurfaceTexture surfaceTexture)</span> </span>&#123;</span><br><span class="line">                mGLSurfaceView.requestRender();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        <span class="comment">// 根据SurfaceTexture创建Surface，作为预览数据的Target</span></span><br><span class="line">        surface = <span class="keyword">new</span> Surface(surfaceTexture);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            cameraDevice = camera;</span><br><span class="line">            previewRequestBuilder = cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_PREVIEW);</span><br><span class="line">            previewRequestBuilder.addTarget(surface);</span><br><span class="line">            previewRequest = previewRequestBuilder.build();</span><br><span class="line"></span><br><span class="line">            cameraDevice.createCaptureSession(Arrays.asList(surface), sessionsStateCallback, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CameraAccessException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDisconnected</span><span class="params">(CameraDevice camera)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(CameraDevice camera, <span class="keyword">int</span> error)</span> </span>&#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Open  onError"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="最后看我路飞"><a href="#最后看我路飞" class="headerlink" title="最后看我路飞"></a>最后看我路飞</h2><p><img src="/2019/10/11/Android音视频-六-使用OpenGL-ES-3-0预览Camera2/Camera2_OpenGL.png" alt=""></p><p><a href="https://github.com/David1840/OpenGLES-Learning" target="_blank" rel="noopener">源码地址</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚学习了OpenGL的纹理相关知识，终于可以接着写Android音视频系列了。&lt;/p&gt;
&lt;p&gt;本篇博客会介绍使用OpenGL ES 3.0相关知识预览Camera，并且提供Camera和Camera2两个版本实现。&lt;/p&gt;
&lt;h2 id=&quot;整体流程&quot;&gt;&lt;a href=&quot;#整
      
    
    </summary>
    
      <category term="Android音视频" scheme="http://yoursite.com/categories/Android%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="Camera2" scheme="http://yoursite.com/tags/Camera2/"/>
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="Camera" scheme="http://yoursite.com/tags/Camera/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0纹理映射-绘制一张图片</title>
    <link href="http://yoursite.com/2019/09/17/OpenGL-ES-3-0%E7%BA%B9%E7%90%86/"/>
    <id>http://yoursite.com/2019/09/17/OpenGL-ES-3-0纹理/</id>
    <published>2019-09-17T13:15:12.000Z</published>
    <updated>2019-10-13T02:25:14.000Z</updated>
    
    <content type="html"><![CDATA[<p>本篇博客了解一下2D纹理，并完成一个绘制显示一张图片的Renderer。</p><h3 id="2D纹理"><a href="#2D纹理" class="headerlink" title="2D纹理"></a>2D纹理</h3><p>2D纹理是OpenGL ES中最基本和常用的纹理形式。2D纹理本质上其实：<code>是一个图像数据的二维数组</code>。一个纹理的单独数据元素称作<code>&quot;纹素(Texel,texture pixels)纹理像素简写&quot;</code>。用2D纹理渲染时，纹理坐标用作纹理图像中的索引。2D纹理的纹理坐标用一对2D坐标<code>(s,t)</code>指定，有时也 称作<code>(u,v)</code>坐标。</p><p>纹理坐标在x和y轴上，范围为0到1之间（注意我们使用的是2D纹理图像）。使用纹理坐标获取纹理颜色叫做采样(Sampling)。纹理坐标起始于(0, 0)，也就是纹理图片的左下角，终始于(1, 1)，即纹理图片的右上角。下面的图片展示了我们是如何把纹理坐标映射到三角形上的。</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/tex_coords.png" alt=""></p><p>我们为三角形指定了3个纹理坐标点。如上图所示，我们希望三角形的左下角对应纹理的左下角，因此我们把三角形左下角顶点的纹理坐标设置为(0, 0)；三角形的上顶点对应于图片的上中位置所以我们把它的纹理坐标设置为(0.5, 1.0)；同理右下方的顶点设置为(1, 0)。我们只要给顶点着色器传递这三个纹理坐标就行了，接下来它们会被传片段着色器中，它会为每个片段进行纹理坐标的插值。</p><p>纹理坐标看起来就像这样：</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">float</span> texCoords[] = &#123;</span><br><span class="line">    <span class="number">0.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">1.0</span>f, <span class="number">0.0</span>f, <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">0.5</span>f, <span class="number">1.0</span>f <span class="comment">// 上中</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>对纹理采样的解释非常宽松，它可以采用几种不同的插值方式。所以我们需要自己告诉OpenGL该怎样对纹理<strong>采样</strong>。</p><h4 id="纹理环绕方式"><a href="#纹理环绕方式" class="headerlink" title="纹理环绕方式"></a>纹理环绕方式</h4><p>纹理坐标的范围通常是从(0, 0)到(1, 1)，那如果我们把纹理坐标设置在范围之外会发生什么？OpenGL默认的行为是重复这个纹理图像（我们基本上忽略浮点纹理坐标的整数部分），但OpenGL提供了更多的选择：</p><table><thead><tr><th style="text-align:left">环绕方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_REPEAT</td><td style="text-align:left">对纹理的默认行为。重复纹理图像。</td></tr><tr><td style="text-align:left">GL_MIRRORED_REPEAT</td><td style="text-align:left">和GL_REPEAT一样，但每次重复图片是镜像放置的。</td></tr><tr><td style="text-align:left">GL_CLAMP_TO_EDGE</td><td style="text-align:left">纹理坐标会被约束在0到1之间，超出的部分会重复纹理坐标的边缘，产生一种边缘被拉伸的效果。</td></tr><tr><td style="text-align:left">GL_CLAMP_TO_BORDER</td><td style="text-align:left">超出的坐标为用户指定的边缘颜色。</td></tr></tbody></table><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/texture_wrapping.png" alt=""></p><p>前面提到的每个选项都可以使用glTexParameter*函数对单独的一个坐标轴设置（<code>s</code>、<code>t</code>（如果是使用3D纹理那么还有一个<code>r</code>）它们和<code>x</code>、<code>y</code>、<code>z</code>是等价的）：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_WRAP_S, GL_MIRRORED_REPEAT)<span class="comment">;</span></span><br><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_WRAP_T, GL_MIRRORED_REPEAT)<span class="comment">;</span></span><br></pre></td></tr></table></figure><p>第一个参数指定了纹理目标；我们使用的是2D纹理，因此纹理目标是GL_TEXTURE_2D。第二个参数需要我们指定设置的选项与应用的纹理轴。我们打算配置的是<code>WRAP</code>选项，并且指定<code>S</code>和<code>T</code>轴。最后一个参数需要我们传递一个环绕方式(Wrapping)，在这个例子中OpenGL会给当前激活的纹理设定纹理环绕方式为GL_MIRRORED_REPEAT。</p><h4 id="纹理过滤"><a href="#纹理过滤" class="headerlink" title="纹理过滤"></a>纹理过滤</h4><p>纹理坐标不依赖于分辨率(Resolution)，它可以是任意浮点值，所以OpenGL需要知道怎样将纹理像素映射到纹理坐标。当你有一个很大的物体但是纹理的分辨率很低的时候这就变得很重要了。你可能已经猜到了，OpenGL也有对于纹理过滤(Texture Filtering)的选项。纹理过滤有很多个选项，但是现在我们只讨论最重要的两种：GL_NEAREST和GL_LINEAR。</p><p>GL_NEAREST（也叫邻近过滤，Nearest Neighbor Filtering）是OpenGL默认的纹理过滤方式。当设置为GL_NEAREST的时候，OpenGL会选择中心点最接近纹理坐标的那个像素。下图中你可以看到四个像素，加号代表纹理坐标。左上角那个纹理像素的中心距离纹理坐标最近，所以它会被选择为样本颜色：</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/filter_nearest.png" alt=""></p><p>GL_LINEAR（也叫线性过滤，(Bi)linear Filtering）它会基于纹理坐标附近的纹理像素，计算出一个插值，近似出这些纹理像素之间的颜色。一个纹理像素的中心距离纹理坐标越近，那么这个纹理像素的颜色对最终的样本颜色的贡献越大。下图中你可以看到返回的颜色是邻近像素的混合色：</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/filter_linear.png" alt=""></p><p>那么这两种纹理过滤方式有怎样的视觉效果呢？让我们看看在一个很大的物体上应用一张低分辨率的纹理会发生什么吧（纹理被放大了，每个纹理像素都能看到）：</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/texture_filtering.png" alt=""></p><p>GL_NEAREST产生了颗粒状的图案，我们能够清晰看到组成纹理的像素，而GL_LINEAR能够产生更平滑的图案，很难看出单个的纹理像素。GL_LINEAR可以产生更真实的输出，但有些开发者更喜欢8-bit风格，所以他们会用GL_NEAREST选项。</p><p>当进行放大(Magnify)和缩小(Minify)操作的时候可以设置纹理过滤的选项，比如你可以在纹理被缩小的时候使用邻近过滤，被放大时使用线性过滤。我们需要使用glTexParameter*函数为放大和缩小指定过滤方式。这段代码看起来会和纹理环绕方式的设置很相似：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_MIN_FILTER, GL_NEAREST)<span class="comment">;</span></span><br><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_MAG_FILTER, GL_LINEAR)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h4 id="多级渐远纹理"><a href="#多级渐远纹理" class="headerlink" title="多级渐远纹理"></a>多级渐远纹理</h4><p>想象一下，假设我们有一个包含着上千物体的大房间，每个物体上都有纹理。有些物体会很远，但其纹理会拥有与近处物体同样高的分辨率。由于远处的物体可能只产生很少的片段，OpenGL从高分辨率纹理中为这些片段获取正确的颜色值就很困难，因为它需要对一个跨过纹理很大部分的片段只拾取一个纹理颜色。在小物体上这会产生不真实的感觉，更不用说对它们使用高分辨率纹理浪费内存的问题了。</p><p>OpenGL使用一种叫做多级渐远纹理(Mipmap)的概念来解决这个问题，它简单来说就是一系列的纹理图像，后一个纹理图像是前一个的二分之一。多级渐远纹理背后的理念很简单：距观察者的距离超过一定的阈值，OpenGL会使用不同的多级渐远纹理，即最适合物体的距离的那个。由于距离远，解析度不高也不会被用户注意到。同时，多级渐远纹理另一加分之处是它的性能非常好。让我们看一下多级渐远纹理是什么样子的：</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/mipmaps.png" alt=""></p><p>手工为每个纹理图像创建一系列多级渐远纹理很麻烦，幸好OpenGL有一个glGenerateMipmaps函数，在创建完一个纹理后调用它OpenGL就会承担接下来的所有工作了。</p><table><thead><tr><th style="text-align:left">过滤方式</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_NEAREST_MIPMAP_NEAREST</td><td style="text-align:left">使用最邻近的多级渐远纹理来匹配像素大小，并使用邻近插值进行纹理采样</td></tr><tr><td style="text-align:left">GL_LINEAR_MIPMAP_NEAREST</td><td style="text-align:left">使用最邻近的多级渐远纹理级别，并使用线性插值进行采样</td></tr><tr><td style="text-align:left">GL_NEAREST_MIPMAP_LINEAR</td><td style="text-align:left">在两个最匹配像素大小的多级渐远纹理之间进行线性插值，使用邻近插值进行采样</td></tr><tr><td style="text-align:left">GL_LINEAR_MIPMAP_LINEAR</td><td style="text-align:left">在两个邻近的多级渐远纹理之间使用线性插值，并使用线性插值进行采样</td></tr></tbody></table><p>就像纹理过滤一样，我们可以使用glTexParameteri将过滤方式设置为前面四种提到的方法之一：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR)<span class="comment">;</span></span><br><span class="line">glTexParameteri(<span class="name">GL_TEXTURE_2D</span>, GL_TEXTURE_MAG_FILTER, GL_LINEAR)<span class="comment">;</span></span><br></pre></td></tr></table></figure><h3 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h3><p>首先，定义顶点坐标和纹理坐标</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点坐标</span></span><br><span class="line"><span class="comment"> * (x,y,z)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] POSITION_VERTEX = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>,     <span class="comment">//顶点坐标V0</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>,     <span class="comment">//顶点坐标V1</span></span><br><span class="line">        -<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>,    <span class="comment">//顶点坐标V2</span></span><br><span class="line">        -<span class="number">1f</span>, -<span class="number">1f</span>, <span class="number">0f</span>,   <span class="comment">//顶点坐标V3</span></span><br><span class="line">        <span class="number">1f</span>, -<span class="number">1f</span>, <span class="number">0f</span>     <span class="comment">//顶点坐标V4</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 纹理坐标</span></span><br><span class="line"><span class="comment"> * (s,t)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span>[] TEX_VERTEX = &#123;</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="comment">//纹理坐标V0</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">0f</span>,     <span class="comment">//纹理坐标V1</span></span><br><span class="line">        <span class="number">0f</span>, <span class="number">0f</span>,     <span class="comment">//纹理坐标V2</span></span><br><span class="line">        <span class="number">0f</span>, <span class="number">1.0f</span>,   <span class="comment">//纹理坐标V3</span></span><br><span class="line">        <span class="number">1f</span>, <span class="number">1.0f</span>    <span class="comment">//纹理坐标V4</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这里顶点坐标和纹理坐标是一一对应的，只是因为二者坐标原点不同，坐标值也不同，如下图。</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/OpenGL-texture2.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 索引，最终绘制时通过索引从顶点数据中取出对应顶点，再按照指定的方式进行绘制</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">short</span>[] VERTEX_INDEX = &#123;</span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>,  <span class="comment">//V0,V1,V2 三个顶点组成一个三角形</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">2</span>, <span class="number">3</span>,  <span class="comment">//V0,V2,V3 三个顶点组成一个三角形</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>,  <span class="comment">//V0,V3,V4 三个顶点组成一个三角形</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">4</span>, <span class="number">1</span>   <span class="comment">//V0,V4,V1 三个顶点组成一个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String vertextShader =</span><br><span class="line">                <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                <span class="string">"layout (location = 0) in vec4 vPosition;\n"</span> +</span><br><span class="line">                <span class="string">"layout (location = 1) in vec2 aTextureCoord;\n"</span> +</span><br><span class="line">                <span class="string">"//矩阵\n"</span> +</span><br><span class="line">                <span class="string">"uniform mat4 u_Matrix;\n"</span>+</span><br><span class="line">                <span class="string">"//输出纹理坐标(s,t)\n"</span> +</span><br><span class="line">                <span class="string">"out vec2 vTexCoord;\n"</span> +</span><br><span class="line">                <span class="string">"void main() &#123; \n"</span> +</span><br><span class="line">                <span class="string">"     gl_Position  = u_Matrix * vPosition;\n"</span> +</span><br><span class="line">                <span class="string">"     gl_PointSize = 10.0;\n"</span> +</span><br><span class="line">                <span class="string">"     vTexCoord = aTextureCoord;\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p>片段着色器应该接下来会把输出变量<code>vTexCoord</code>作为输入变量。</p><p>片段着色器也应该能访问纹理对象，但是我们怎样能把纹理对象传给片段着色器呢？GLSL有一个供纹理对象使用的内建数据类型，叫做采样器(Sampler)，它以纹理类型作为后缀，比如<code>sampler1D</code>、<code>sampler3D</code>，或在我们的例子中的<code>sampler2D</code>。我们可以简单声明一个<code>uniform sampler2D</code>把一个纹理添加到片段着色器中，稍后我们会把纹理赋值给这个uniform。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 片段着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String fragmentShader =</span><br><span class="line">                <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                <span class="string">"precision mediump float;\n"</span> +</span><br><span class="line">                <span class="string">"uniform sampler2D uTextureUnit;\n"</span> +</span><br><span class="line">                <span class="string">"//接收刚才顶点着色器传入的纹理坐标(s,t)\n"</span> +</span><br><span class="line">                <span class="string">"in vec2 vTexCoord;\n"</span> +</span><br><span class="line">                <span class="string">"out vec4 vFragColor;\n"</span> +</span><br><span class="line">                <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">                <span class="string">"     vFragColor = texture(uTextureUnit,vTexCoord);\n"</span> +</span><br><span class="line">                <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p>我们使用GLSL内建的texture函数来采样纹理的颜色，它第一个参数是纹理采样器，第二个参数是对应的纹理坐标。texture函数会使用之前设置的纹理参数对相应的颜色值进行采样。这个片段着色器的输出就是纹理的（插值）纹理坐标上的(过滤后的)颜色。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">loadTexture</span><span class="params">(Context context, <span class="keyword">int</span> resourceId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span>[] textureIds = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">//创建一个纹理对象</span></span><br><span class="line">    GLES30.glGenTextures(<span class="number">1</span>, textureIds, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (textureIds[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Could not generate a new OpenGL textureId object."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> BitmapFactory.Options options = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    <span class="comment">//这里需要加载原图未经缩放的数据</span></span><br><span class="line">    options.inScaled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> Bitmap bitmap = BitmapFactory.decodeResource(context.getResources(), resourceId, options);</span><br><span class="line">    <span class="keyword">if</span> (bitmap == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Resource ID "</span> + resourceId + <span class="string">" could not be decoded."</span>);</span><br><span class="line">        GLES30.glDeleteTextures(<span class="number">1</span>, textureIds, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定纹理到OpenGL</span></span><br><span class="line">    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, textureIds[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置默认的纹理过滤参数</span></span><br><span class="line">    GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MIN_FILTER, GLES30.GL_LINEAR_MIPMAP_LINEAR);</span><br><span class="line">    GLES30.glTexParameteri(GLES30.GL_TEXTURE_2D, GLES30.GL_TEXTURE_MAG_FILTER, GLES30.GL_LINEAR);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 加载bitmap到纹理中</span></span><br><span class="line">    GLUtils.texImage2D(GLES30.GL_TEXTURE_2D, <span class="number">0</span>, bitmap, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 生成MIP贴图</span></span><br><span class="line">    GLES30.glGenerateMipmap(GLES30.GL_TEXTURE_2D);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据如果已经被加载进OpenGL,则可以回收该bitmap</span></span><br><span class="line">    bitmap.recycle();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取消绑定纹理</span></span><br><span class="line">    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> textureIds[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>绘制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl)</span> </span>&#123;</span><br><span class="line">    GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用程序片段</span></span><br><span class="line">    GLES30.glUseProgram(mProgram);</span><br><span class="line"></span><br><span class="line">    GLES30.glUniformMatrix4fv(uMatrixLocation, <span class="number">1</span>, <span class="keyword">false</span>, mMatrix, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line"></span><br><span class="line">    GLES30.glEnableVertexAttribArray(<span class="number">1</span>);</span><br><span class="line">    GLES30.glVertexAttribPointer(<span class="number">1</span>, <span class="number">2</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, mTexVertexBuffer);</span><br><span class="line"></span><br><span class="line">    GLES30.glActiveTexture(GLES30.GL_TEXTURE0);</span><br><span class="line">    <span class="comment">//绑定纹理</span></span><br><span class="line">    GLES30.glBindTexture(GLES30.GL_TEXTURE_2D, textureId);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绘制</span></span><br><span class="line">    GLES20.glDrawElements(GLES20.GL_TRIANGLES, VERTEX_INDEX.length, GLES20.GL_UNSIGNED_SHORT, mVertexIndexBuffer);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最终展示：</p><p><img src="/2019/09/17/OpenGL-ES-3-0纹理/OpenGL-show.png" alt=""></p><p><a href="https://github.com/David1840/OpenGLES-Learning/blob/master/app/src/main/java/com/david/opengl/render/TextureRender.java" target="_blank" rel="noopener">源码Github</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本篇博客了解一下2D纹理，并完成一个绘制显示一张图片的Renderer。&lt;/p&gt;
&lt;h3 id=&quot;2D纹理&quot;&gt;&lt;a href=&quot;#2D纹理&quot; class=&quot;headerlink&quot; title=&quot;2D纹理&quot;&gt;&lt;/a&gt;2D纹理&lt;/h3&gt;&lt;p&gt;2D纹理是OpenGL ES中最基本
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI开发--JNI返回Java对象</title>
    <link href="http://yoursite.com/2019/08/20/Android-JNI%E5%BC%80%E5%8F%91-JNI%E8%BF%94%E5%9B%9EJava%E5%AF%B9%E8%B1%A1/"/>
    <id>http://yoursite.com/2019/08/20/Android-JNI开发-JNI返回Java对象/</id>
    <published>2019-08-20T02:32:37.000Z</published>
    <updated>2019-08-29T15:55:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>昨天同事问我一个JNI问题，想从Native代码中返回一个Java对象，但是网上找的例子运行就崩溃了。仔细一想，我好想也没做过这样的操作，赶紧学习一下。</p><p>从Native层返回一个Java对象，有两种操作</p><ol><li>传入一个创建好的Java对象，只在JNI代码中做赋值操作并返回</li><li>完全在JNI代码中新建一个对象，赋值并返回</li></ol><h5 id="创建一个Person类"><a href="#创建一个Person类" class="headerlink" title="创建一个Person类"></a>创建一个Person类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法1 从Java层传入一个对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Person <span class="title">getPerson</span><span class="params">(Person person)</span></span>;</span><br><span class="line"><span class="comment">//方法2 完全从Native代码中创建对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> Person <span class="title">getPerson2</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h5 id="C-代码"><a href="#C-代码" class="headerlink" title="C++代码"></a>C++代码</h5><h6 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_myapplication_MainActivity_getPerson(JNIEnv *env, jobject instance,</span><br><span class="line">                                                      jobject person) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找到对象的Java类</span></span><br><span class="line">    jclass myClass = env-&gt;FindClass(<span class="string">"com/myapplication/Person"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 对应的Java属性</span></span><br><span class="line">    jfieldID name = env-&gt;GetFieldID(myClass, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">    jfieldID age = env-&gt;GetFieldID(myClass, <span class="string">"age"</span>, <span class="string">"I"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//属性赋值，person为传入的Java对象</span></span><br><span class="line">    env-&gt;SetObjectField(person, name, env-&gt;NewStringUTF(<span class="string">"liuwei"</span>));</span><br><span class="line">    env-&gt;SetIntField(person, age, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h6 id="方法2"><a href="#方法2" class="headerlink" title="方法2"></a>方法2</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span></span><br><span class="line">JNIEXPORT jobject JNICALL</span><br><span class="line">Java_com_myapplication_MainActivity_getPerson2(JNIEnv *env, jobject instance) &#123;</span><br><span class="line">   </span><br><span class="line">    jclass myClass = env-&gt;FindClass(<span class="string">"com/myapplication/Person"</span>);</span><br><span class="line">    <span class="comment">// 获取类的构造函数，记住这里是调用无参的构造函数</span></span><br><span class="line">    jmethodID id = env-&gt;GetMethodID(myClass, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line">    <span class="comment">// 创建一个新的对象</span></span><br><span class="line">    jobject person_ = env-&gt;NewObject(myClass, id);</span><br><span class="line">    </span><br><span class="line">    jfieldID name = env-&gt;GetFieldID(myClass, <span class="string">"name"</span>, <span class="string">"Ljava/lang/String;"</span>);</span><br><span class="line">    jfieldID age = env-&gt;GetFieldID(myClass, <span class="string">"age"</span>, <span class="string">"I"</span>);</span><br><span class="line"></span><br><span class="line">    env-&gt;SetObjectField(person_, name, env-&gt;NewStringUTF(<span class="string">"liuwei"</span>));</span><br><span class="line">    env-&gt;SetIntField(person_, age, <span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> person_;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，方法1和方法2的代码区别就2行</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// 获取类的构造函数，记住这里是调用无参的构造函数</span></span><br><span class="line">jmethodID id = env-&gt;GetMethodID(myClass, <span class="string">"&lt;init&gt;"</span>, <span class="string">"()V"</span>);</span><br><span class="line"><span class="comment">// 创建一个新的对象</span></span><br><span class="line">jobject person_ = env-&gt;NewObject(myClass, id);</span><br></pre></td></tr></table></figure><p>在开发时 <code>env-&gt;GetMethodID(myClass, &quot;&lt;init&gt;&quot;, &quot;()V&quot;);</code>很可能会在写代码是标红，提示无法找到<code>&lt;init&gt;</code>,不需要理会，直接编译就好了。</p><h5 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">TextView tv = findViewById(R.id.sample_text);</span><br><span class="line"></span><br><span class="line">Person person = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="comment">//传入Java对象，返回的也是同一个对象</span></span><br><span class="line">getPerson(person);</span><br><span class="line"></span><br><span class="line">tv.setText(person.getName() <span class="comment">// 方法1</span></span><br><span class="line">           + <span class="string">" : "</span> +</span><br><span class="line">           getPerson2().getAge() <span class="comment">// 方法2</span></span><br><span class="line">    );</span><br></pre></td></tr></table></figure><p>搞定！又学习了一个知识点。</p><p>对了，同事代码崩溃的问题就是Java层用了方法2，但是JNI代码却用了方法1，没有创建出一个对象，导致崩溃。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;昨天同事问我一个JNI问题，想从Native代码中返回一个Java对象，但是网上找的例子运行就崩溃了。仔细一想，我好想也没做过这样的操作，赶紧学习一下。&lt;/p&gt;
&lt;p&gt;从Native层返回一个Java对象，有两种操作&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;传入一个创建好的Java对象，
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI开发--资源释放问题</title>
    <link href="http://yoursite.com/2019/08/13/Android-JNI%E5%BC%80%E5%8F%91-%E8%B5%84%E6%BA%90%E9%87%8A%E6%94%BE%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2019/08/13/Android-JNI开发-资源释放问题/</id>
    <published>2019-08-13T06:19:18.000Z</published>
    <updated>2019-10-13T02:25:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近又在开发JNI相关的项目了。本来一切正常，坐等测试完毕发布版本，然而理想是美好的，现实是骨感的。测试跑过来跟我说在测异常流程（开发人员听到估计就头疼）的时候发生了闪退问题。我赶紧拿过来自己测，果然复现了，日志中显示<code>local reference table overflow (max=512)</code> 。嗯？JNI中出现了内存泄漏？可是我已经按照网上的例子把所有该释放的对象都释放了啊，怎么回事啊？</p><p>先简单回顾下网上常见的：</p><ol><li><p>FindClass </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass ref= (env)-&gt;FindClass(<span class="string">"java/lang/String"</span>);</span><br><span class="line">env-&gt;DeleteLocalRef(ref);</span><br></pre></td></tr></table></figure></li><li><p>NewString/ NewStringUTF/NewObject/NewByteArray</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建 jstring 和 char*</span></span><br><span class="line">jstring jstr = (*jniEnv)-&gt;CallObjectMethod(jniEnv, test1, test2);</span><br><span class="line"><span class="keyword">char</span>* cstr = (<span class="keyword">char</span>*) (*jniEnv)-&gt;GetStringUTFChars(jniEnv,jstr, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放</span></span><br><span class="line">(*jniEnv)-&gt;ReleaseStringUTFChars(jniEnv, jstr, cstr);</span><br><span class="line">(*jniEnv)-&gt;DeleteLocalRef(jniEnv, jstr);</span><br></pre></td></tr></table></figure></li><li><p>GetObjectField/GetObjectClass/GetObjectArrayElement</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jclass ref = env-&gt;GetObjectClass(robj);</span><br><span class="line">env-&gt;DeleteLocalRef(ref);</span><br></pre></td></tr></table></figure></li><li><p>GetByteArrayElements</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jbyte* <span class="built_in">array</span>= (*env)-&gt;GetByteArrayElements(env,jarray,&amp;isCopy);</span><br><span class="line">(*env)-&gt;ReleaseByteArrayElements(env,jarray,<span class="built_in">array</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure></li><li><p>NewGlobalRef/DeleteGlobalRef</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jobject ref= env-&gt;NewGlobalRef(<span class="name">customObj</span>)<span class="comment">;</span></span><br><span class="line">env-&gt;DeleteGlobalRef(<span class="name">customObj</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure></li></ol><p>开始了苦逼的代码检查之路，检查代码，上面提到的我都已经做了处理，然后考虑各种方式，各种测试，还是会在异常流程中出现闪退，令人绝望。</p><p>最后，忽然看到了这个：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jbyteArray arr = (jbyteArray) (*env)-&gt;CallObjectMethod(env, local_object, methodID, java_slot,jbyteArray1);</span><br></pre></td></tr></table></figure><p>从JNI中反射调用Java层方法，返回了一个字节数组，这个字节数组会被JVM回收吗？我一直认为这个是会被虚拟机回收的，但到了现在，什么都有可能了，所以我测试了一下，果然，这个数组在异常流程中被不断创建，并且没有得到回收，所以很快就出现了<code>local reference table overflow (max=512)</code>错误。找到问题根源了，赶紧检查代码，所有类似的接口全部进行修改。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(*env)-&gt;DeleteLocalRef(env, arr);</span><br></pre></td></tr></table></figure><p>然后再次送测，终于没有问题了。</p><p>因为这个，要解决只要一行代码的问题，花费了我大半个下午时间，所以在这里记录一下，提醒自己，以后记得释放所有在Native层中创建的本地对象！也希望能帮到遇到类似问题的朋友。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近又在开发JNI相关的项目了。本来一切正常，坐等测试完毕发布版本，然而理想是美好的，现实是骨感的。测试跑过来跟我说在测异常流程（开发人员听到估计就头疼）的时候发生了闪退问题。我赶紧拿过来自己测，果然复现了，日志中显示&lt;code&gt;local reference table 
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0从画圆中了解坐标系统</title>
    <link href="http://yoursite.com/2019/07/25/OpenGL-ES-3-0%E4%BB%8E%E7%94%BB%E5%9C%86%E4%B8%AD%E4%BA%86%E8%A7%A3%E5%9D%90%E6%A0%87%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/</id>
    <published>2019-07-25T07:49:08.000Z</published>
    <updated>2019-07-26T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前学习了绘制点、线、三角形，都很完美的展示出来了，所以有点小膨胀，想画一个圆形证明自己OpenGL已经入门了。</p><p>画一个圆形其实和画一个三角形没有太大区别，因为一个圆形也就是由无数个相同顶点的三角形组成的，三角形个数趋向于无限大的时候，整个图案也就越趋向于圆。顶点数据就不能手写了，可以靠代码生成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] createPositions() &#123;</span><br><span class="line">    <span class="comment">// 绘制的半径</span></span><br><span class="line">    <span class="keyword">float</span> radius = <span class="number">0.8f</span>;</span><br><span class="line">    ArrayList&lt;Float&gt; data = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    data.add(<span class="number">0.0f</span>); <span class="comment">//设置圆心坐标</span></span><br><span class="line">    data.add(<span class="number">0.0f</span>);</span><br><span class="line">    data.add(<span class="number">0.0f</span>);</span><br><span class="line">    <span class="keyword">float</span> angDegSpan = <span class="number">360f</span> / <span class="number">360</span>; <span class="comment">// 分成360份</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">float</span> i = <span class="number">0</span>; i &lt; <span class="number">360</span> + angDegSpan; i += angDegSpan) &#123;</span><br><span class="line">        data.add((<span class="keyword">float</span>) (radius * Math.sin(i * Math.PI / <span class="number">180f</span>)));</span><br><span class="line">        data.add((<span class="keyword">float</span>) (radius * Math.cos(i * Math.PI / <span class="number">180f</span>)));</span><br><span class="line">        data.add(<span class="number">0.0f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">float</span>[] f = <span class="keyword">new</span> <span class="keyword">float</span>[data.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; f.length; i++) &#123;</span><br><span class="line">        f[i] = data.get(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>把圆分成了 360 份。圆形的顶点数据也分为了三部分了，以原心作为我们的中心点，中间的 360 个点用来绘制三角形，最后一个点使得我们的图形闭合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GLES30.glDrawArrays(GLES30.GL_TRIANGLE_FAN, <span class="number">0</span>, <span class="number">362</span>);</span><br></pre></td></tr></table></figure><p>当信心满满地运行后，现实却打了脸：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/1.png" alt=""></p><p>圆形变成了一个椭圆。。。 为什么呢？</p><p>OpenGL希望在每次顶点着色器运行后，我们可见的所有顶点都为标准化设备坐标(Normalized Device Coordinate, NDC)。也就是说，每个顶点的<strong>x</strong>，<strong>y</strong>，<strong>z</strong>坐标都应该在<strong>-1.0</strong>到<strong>1.0</strong>之间，超出这个坐标范围的顶点都将不可见。</p><p>而在上面的例子中，假设实际手机分辨率以像素为单位是<code>720x1280</code>，我们默认使用<code>OpenGL</code>占用整个显示屏。<br>设备在竖屏模式下，那么<code>[-1，1]</code>的范围对应的高有<code>1280像素</code>，而宽却只有<code>720像素</code>。正因为标准化设备坐标假定坐标空间是一个正方形，而实际的设备屏幕不是正方形，因为宽高之间的比例，使得绘制结果与预料结果不一致。</p><p>如何解决这个问题？在OpenGL中使用了正交投影的方式解决这个问题。</p><p>在学习正交投影前先学习下OpenGL的坐标系统。</p><h2 id="坐标系统"><a href="#坐标系统" class="headerlink" title="坐标系统"></a>坐标系统</h2><p>OpenGL中我们通常会自己设定一个坐标的范围，之后再在顶点着色器中将这些坐标变换为标准化设备坐标。然后将这些标准化设备坐标传入光栅器(Rasterizer)，将它们变换为屏幕上的二维坐标或像素。</p><p>将坐标变换为标准化设备坐标，接着再转化为屏幕坐标的过程通常是分步进行的，也就是类似于流水线那样子。在流水线中，物体的顶点在最终转化为屏幕坐标之前还会被变换到多个坐标系统(Coordinate System)。将物体的坐标变换到几个<strong>过渡</strong>坐标系(Intermediate Coordinate System)的优点在于，在这些特定的坐标系统中，一些操作或运算更加方便和容易，这一点很快就会变得很明显。对我们来说比较重要的总共有5个不同的坐标系统：</p><ul><li>局部空间(Local Space，或者称为物体空间(Object Space))</li><li>世界空间(World Space)</li><li>观察空间(View Space，或者称为视觉空间(Eye Space))</li><li>裁剪空间(Clip Space)</li><li>屏幕空间(Screen Space)</li></ul><p>这就是一个顶点在最终被转化为片段之前需要经历的所有不同状态。</p><p>为了将坐标从一个坐标系变换到另一个坐标系，我们需要用到几个变换矩阵，最重要的几个分别是<strong>模型(Model)</strong>、<strong>观察(View)</strong>、<strong>投影(Projection)</strong>三个矩阵。我们的顶点坐标起始于<strong>局部空间(Local Space)</strong>，在这里它称为<strong>局部坐标(Local Coordinate)</strong>，它在之后会变为<strong>世界坐标(World Coordinate)</strong>，<strong>观察坐标(View Coordinate)</strong>，<strong>裁剪坐标(Clip Coordinate)</strong>，并最后以<strong>屏幕坐标(Screen Coordinate)</strong>的形式结束。下面的这张图展示了整个流程以及各个变换过程做了什么：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/coordinate_systems.png" alt=""></p><p>首先了解下OpenGL是一个右手坐标系，简单来说，就是正x轴在你的右手边，正y轴朝上，而正z轴是朝向后方的。想象你的屏幕处于三个轴的中心，则正z轴穿过你的屏幕朝向你。坐标系画起来如下：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/coordinate_systems_right_handed.png" alt=""></p><h3 id="局部空间"><a href="#局部空间" class="headerlink" title="局部空间"></a>局部空间</h3><p>局部空间坐标是 OpenGL 绘制坐标的起点，接下来所有的转换操作都是在局部空间坐标基础上进行的。</p><p>局部空间坐标就是我们自己定义的起始坐标点，是相对于原点 <code>(0,0,0)(0,0,0)</code> 的。</p><p>此时所在的空间就是局部空间，也就是说我们在局部空间里面定义物体的起始坐标。</p><h3 id="世界空间"><a href="#世界空间" class="headerlink" title="世界空间"></a>世界空间</h3><p>如果我们将我们所有的物体导入到程序当中，它们有可能会全挤在世界的原点(0, 0, 0)上，这并不是我们想要的结果。我们想为每一个物体定义一个位置，从而能在更大的世界当中放置它们。世界空间中的坐标正如其名：是指顶点相对于（游戏）世界的坐标。如果你希望将物体分散在世界上摆放（特别是非常真实的那样），这就是你希望物体变换到的空间。物体的坐标将会从局部变换到世界空间；该变换是由模型矩阵(Model Matrix)实现的。</p><p>模型矩阵是一种变换矩阵，它能通过对物体进行位移、缩放、旋转来将它置于它本应该在的位置或朝向。你可以将它想像为变换一个房子，你需要先将它缩小（它在局部空间中太大了），并将其位移至郊区的一个小镇，然后在y轴上往左旋转一点以搭配附近的房子。</p><h3 id="观察空间"><a href="#观察空间" class="headerlink" title="观察空间"></a>观察空间</h3><p>观察空间经常被人们称之OpenGL的摄像机(Camera)（所以有时也称为摄像机空间(Camera Space)或视觉空间(Eye Space)）。观察空间是将世界空间坐标转化为用户视野前方的坐标而产生的结果。因此观察空间就是从摄像机的视角所观察到的空间。而这通常是由一系列的位移和旋转的组合来完成，平移/旋转场景从而使得特定的对象被变换到摄像机的前方。这些组合在一起的变换通常存储在一个观察矩阵(View Matrix)里，它被用来将世界坐标变换到观察空间。</p><p>从日常生活的经验中可以很容易地了解到，随着摄像机位置、姿态的不同，就算是对同一 个场景进行拍摄，得到的画面也是迥然不同的。 因此摄像机的位置、姿态在 OpenGL ES 3.0 应用程序的开发中就显得非常重要，所以先介绍一下摄像机的设置方法。 </p><p>摄像机的设置需要给出 3 方面的信息，包括摄像机的位置、观察的方向以及 up 方向，具体情况如图所示。 </p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-Camera.png" alt=""></p><ul><li>摄像机的位置很容易理解，用其在 3D 空间中的坐标来表示。 </li><li>摄像机观察的方向可以理解为摄像机镜头的指向，用一个观察目标点来表示（通过摄像机位置与观察目标点可以确定一个向量，此向量即代表了摄像机观察的方向）。 </li><li>摄像机的 up 方向可以理解为摄像机顶端的指向，用一个向量来表示。 </li></ul><p>通过摄像机拍摄场景与人眼观察现实世界很类似，因此，通过人眼对现实世界观察的切身感受可以帮助读者理解摄像机的各个参数。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-eye.png" alt=""></p><h3 id="裁剪空间"><a href="#裁剪空间" class="headerlink" title="裁剪空间"></a>裁剪空间</h3><p>在一个顶点着色器运行的最后，OpenGL期望所有的坐标都能落在一个特定的范围内，且任何在这个范围之外的点都应该被裁剪掉(Clipped)。被裁剪掉的坐标就会被忽略，所以剩下的坐标就将变为屏幕上可见的片段。这也就是裁剪空间(Clip Space)名字的由来。</p><p>因为将所有可见的坐标都指定在-1.0到1.0的范围内不是很直观，所以我们会指定自己的坐标集(Coordinate Set)并将它变换回标准化设备坐标系，就像OpenGL期望的那样。</p><p>为了将顶点坐标从观察变换到裁剪空间，我们需要定义一个投影矩阵(Projection Matrix)，它指定了一个范围的坐标，比如在每个维度上的-1000到1000。投影矩阵接着会将在这个指定的范围内的坐标变换为标准化设备坐标的范围(-1.0, 1.0)。所有在范围外的坐标不会被映射到在-1.0到1.0的范围之间，所以会被裁剪掉。在上面这个投影矩阵所指定的范围内，坐标(1250, 500, 750)将是不可见的，这是由于它的x坐标超出了范围，它被转化为一个大于1.0的标准化设备坐标，所以被裁剪掉了。</p><p>由投影矩阵创建的<strong>观察箱</strong>(Viewing Box)被称为平截头体(Frustum)，每个出现在平截头体范围内的坐标都会最终出现在用户的屏幕上。将特定范围内的坐标转化到标准化设备坐标系的过程（而且它很容易被映射到2D观察空间坐标）被称之为投影(Projection)，因为使用投影矩阵能将3D坐标投影(Project)到很容易映射到2D的标准化设备坐标系中。</p><p>一旦所有顶点被变换到裁剪空间，最终的操作——透视除法(Perspective Division)将会执行，在这个过程中我们将位置向量的x，y，z分量分别除以向量的齐次w分量；透视除法是将4D裁剪空间坐标变换为3D标准化设备坐标的过程。这一步会在每一个顶点着色器运行的最后被自动执行。</p><p>在这一阶段之后，最终的坐标将会被映射到屏幕空间中（使用glViewport中的设定），并被变换成片段。</p><p>将观察坐标变换为裁剪坐标的投影矩阵可以为两种不同的形式，每种形式都定义了不同的平截头体。我们可以选择创建一个<strong>正交投影矩阵(Orthographic Projection Matrix)</strong>或一个<strong>透视投影矩阵(Perspective Projection Matrix)</strong>。</p><h4 id="正交投影"><a href="#正交投影" class="headerlink" title="正交投影"></a>正交投影</h4><p>OpenGL ES 3.0 中，根据应用程序中提供的投影矩阵，管线会确定一个可视空间区域，称为视景体。视景体是由 6 个平面确定的，这 6 个平面分别为：上平面（up）、下平面（down）、左平面（left）、右平面（right）、远平面（far）、近平面（near）。 </p><p>场景中处于视景体内的物体会被投影到近平面上（视景体外面的物体将被裁剪掉），然后再将近平面上投影出的内容映射到屏幕上的视口中。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-001.png" alt=""></p><p>由于正交投影是平行投影的一种，其投影线（物体的顶点与近平面上投影点的连线）是平行的。故其视景体为长方体，投影到近平面上的图形不会产生真实世界中“近大远小”的效果，下图更清楚地说明了这个问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-002.png" alt=""></p><h4 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h4><p>现实世界中人眼观察物体时会有“近大远小”的效果，我们看一条无限长的高速公路或铁路时尤其明显，正如下面图片显示的那样：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/perspective.png" alt=""></p><p>由于透视，这两条线在很远的地方看起来会相交。因此，要想开发出更加真实的场景，仅使用正交投影是远远不够的，这时可以采用透视投影。透视投影的投影线是不平行的，他们相交于视点。通过透视投影，可以产生现实世界中“近大远小”的效果，大部分 3D 游戏采用的都是透视投影。</p><p>透视投影中，视景体为锥台形区域，如图所示。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-003.png" alt=""></p><p>从上图中可以看出，透视投影的投影线互不平行，都相交于视点。因此，同样尺寸的物体，近处的投影出来大，远处的投影出来小，从而产生了现实世界中“近大远小”的效果。下图更清楚地说明了这个问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-004.png" alt=""></p><h3 id="把它们都组合到一起"><a href="#把它们都组合到一起" class="headerlink" title="把它们都组合到一起"></a>把它们都组合到一起</h3><p>我们为上述的每一个步骤都创建了一个变换矩阵：模型矩阵、观察矩阵和投影矩阵。一个顶点坐标将会根据以下过程被变换到裁剪坐标：</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/OpenGL-005.png" alt=""></p><p>注意矩阵运算的顺序是相反的（记住我们需要从右往左阅读矩阵的乘法）。最后的顶点应该被赋值到顶点着色器中的gl_Position，OpenGL将会自动进行透视除法和裁剪。</p><h2 id="实现画圆"><a href="#实现画圆" class="headerlink" title="实现画圆"></a>实现画圆</h2><p>上面大概了解了下OpenGL的坐标系统，里面涉及的知识实在太多，后面慢慢了解。我们先使用正交投影完成一个完美的圆的绘制。为了解决图像拉伸问题，就是要保证近平面的宽高比和视口的宽高比一致，而且是以较短的那一边作为 1 的标准，让图像保持居中。</p><p>OpenGL中通过调用 Matrix 类的 orthoM 方法完成对正交投影的设置，其基本代码如下。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">orthoM(<span class="keyword">float</span>[] m,                            <span class="comment">//存储生成矩阵元素的float[]类型数组</span></span><br><span class="line">       <span class="keyword">int</span> mOffset,                          <span class="comment">//填充起始偏移量</span></span><br><span class="line">       <span class="keyword">float</span> left,<span class="keyword">float</span> right,               <span class="comment">//near面的left、right</span></span><br><span class="line">       <span class="keyword">float</span> bottom,<span class="keyword">float</span> top,               <span class="comment">//near面的bottom、top</span></span><br><span class="line">       <span class="keyword">float</span> near,<span class="keyword">float</span> far)                 <span class="comment">//near面、far面与视点的距离</span></span><br></pre></td></tr></table></figure><ul><li>orthoM 方法的功能为根据接收的 6 个正交投影相关参数产生正交投影矩阵，并将矩阵的元素填充到指定的数组中。</li><li>参数 left、right 为近平面左右侧边对应的 x 坐标，top、bottom 为近平面上下侧边对应的 y坐标，分别用来确定左平面、右平面、上平面、下平面的位置。参数 near、far 分别为视景体近平面与远平面距视点的距离。</li></ul><p>近平面的坐标原点位于中心，向右为 X 轴正方向，向上为 Y 轴正方向，所以我们的 left、bottom 要为负数，而 right、top 要为正数。同时，近平面和远平面的距离都是指相对于视点的距离，所以 near、far 要为正数，而且 far&gt;near。</p><p>可以在 GLSurfaceView 的 surfaceChanged 里面来设定正交投影矩阵。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> aspectRatio = width &gt; height ? (<span class="keyword">float</span>) width / (<span class="keyword">float</span>) height : (<span class="keyword">float</span>) height / (<span class="keyword">float</span>) width;</span><br><span class="line"><span class="keyword">if</span> (width &gt; height) &#123;</span><br><span class="line">    Matrix.orthoM(mMatrix, <span class="number">0</span>, -aspectRatio, aspectRatio, -<span class="number">1f</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">10f</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Matrix.orthoM(mMatrix, <span class="number">0</span>, -<span class="number">1f</span>, <span class="number">1f</span>, -aspectRatio, aspectRatio, <span class="number">0f</span>, <span class="number">10f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样就把近平面和视口的宽高比设置为一致的了，解决了之前图像被拉伸的问题。</p><p><img src="/2019/07/25/OpenGL-ES-3-0从画圆中了解坐标系统/2.png" alt=""></p><p>完整代码请看Github：<a href="https://github.com/David1840/OpenGLES-Learning/blob/master/app/src/main/java/com/david/opengl/render/CircleRenderer.java" target="_blank" rel="noopener"><strong>OpenGLES-Learning : CircleRenderer</strong></a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前学习了绘制点、线、三角形，都很完美的展示出来了，所以有点小膨胀，想画一个圆形证明自己OpenGL已经入门了。&lt;/p&gt;
&lt;p&gt;画一个圆形其实和画一个三角形没有太大区别，因为一个圆形也就是由无数个相同顶点的三角形组成的，三角形个数趋向于无限大的时候，整个图案也就越趋向于圆。
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0着色语言</title>
    <link href="http://yoursite.com/2019/07/24/OpenGL-ES-3-0%E7%9D%80%E8%89%B2%E8%AF%AD%E8%A8%80/"/>
    <id>http://yoursite.com/2019/07/24/OpenGL-ES-3-0着色语言/</id>
    <published>2019-07-24T02:46:47.000Z</published>
    <updated>2019-07-26T06:35:04.000Z</updated>
    
    <content type="html"><![CDATA[<p>OpenGL ES 着色语言是一种高级的图形编程语言，其源自应用广泛的 C 语言，同时具有 RenderMan 以及其他着色语言的一些优良特性，易于被开发人员掌握。</p><p>与传统通用编程语言有很大不同的是，其提供了更加丰富的原生类型，如向量、矩阵等。这 些特性的加入使得 OpenGL ES 着色语言在处理 3D 图形方面更加高效、易用。简单来说，OpenGL  ES 着色语言主要包括以下特性。</p><p> OpenGL ES 着色语言是一种高级的过程语言（注意，不是面向对象）。 </p><p> 对顶点着色器、片元着色器使用的是同样的语言，不做区分。 </p><p> 基于 C/C++的基本语法及流程控制。 </p><p> 完美支持向量与矩阵的各种操作。 </p><p> 通过类型限定符来管理输入与输出。 </p><p> 拥有大量的内置函数来提供丰富的功能</p><p>总之，OpenGL ES 着色语言是一种易于实现、功能强大、便于使用，并且可以高度并行处理、性能优良的高级图形编程语言。其可以帮助开发人员在不浪费大量时间的情况下，轻松地为用户带来更完美的视觉体验，开发出更加酷炫的 3D 场景与特效。</p><h2 id="着色语言基础"><a href="#着色语言基础" class="headerlink" title="着色语言基础"></a>着色语言基础</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="1-标量"><a href="#1-标量" class="headerlink" title="1. 标量"></a>1. 标量</h4><p>标量也被称为“无向量”，其值只具有大小，并不具有方向。</p><ul><li>布尔型 bool</li><li>有符号整型int 和 无符号整型 uint</li><li>浮点型 float</li></ul><h4 id="2-向量"><a href="#2-向量" class="headerlink" title="2. 向量"></a>2. 向量</h4><p>向量可以看做是用同样类型的标量组成的，其基本类型也分为 bool、int、uint 及 float 四种。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL1.png" alt="各向量类型及说明"></p><p>向量在着色器代码的开发中有着十分重要的作用，可以很方便地存储以及操作颜色、位置、纹理坐标等不仅包含一个组成部分的量。开发中，有时也可能需要单独访问向量中的某个分量， 基本的语法为“&lt;向量名&gt;.&lt;分量名&gt;”，根据目的的不同，主要有如下几种用法。</p><ul><li><p>将一个向量看作颜色时，可以使用 r、g、b、a 四个分量名，其分别代表红、绿、蓝、透明度 4 个色彩通道，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aColor.r=<span class="number">0.6</span>; <span class="comment">//给向量 aColor 的红色通道分量赋值 </span></span><br><span class="line"></span><br><span class="line">aColor.g=<span class="number">0.8</span>; <span class="comment">//给向量 aColor 的绿色通道分量赋值</span></span><br></pre></td></tr></table></figure></li><li><p>将一个向量看作位置时，可以使用 x、y、z、w 四个分量名，其分别代表 x 轴、y 轴、z轴分量及 W 值，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aPosition.x=<span class="number">67.2</span>; <span class="comment">//给向量 aPosition 的 X 分量赋值 </span></span><br><span class="line"></span><br><span class="line">aPosition.z=<span class="number">48.3</span>; <span class="comment">//给向量 aPosition 的 Z 分量赋值</span></span><br></pre></td></tr></table></figure></li><li><p>将一个向量看作纹理坐标时，可以使用 s、t、p、q 四个分量名，其分别代表纹理坐标的不同分量，具体用法如下。</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aTexCoor.s=<span class="number">0.65</span>; <span class="comment">//给向量 aTexCoor 的 s 分量赋值 </span></span><br><span class="line"></span><br><span class="line">aTexCoor.t=<span class="number">0.34</span>; <span class="comment">//给向量 aTexCoor 的 t 分量赋值</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-矩阵"><a href="#3-矩阵" class="headerlink" title="3. 矩阵"></a>3. 矩阵</h4><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL2.png" alt="矩阵的类型及说明"></p><p>OpenGL ES 着色语言中，矩阵是按列顺序组织的，也就是一个矩阵可以看作由几个列向量组成。对于矩阵的访问，可以将矩阵作为列向量的数组来访问。如 matrix 为一个 mat4，可以使用<code>matrix[2]</code>取到该矩阵的第 3 列，其为一个 vec4；也可以使用 <code>matrix[2][2]</code>取得第 3 列的向量的第 3个分量，其为一个 float；其他的依此类推。</p><h4 id="4-采样器"><a href="#4-采样器" class="headerlink" title="4. 采样器"></a>4. 采样器</h4><p>采样器是着色语言中不同于 C 语言的一种特殊的基本数据类型，其专门用来进行纹理采样的相关操作。一般情况下，一个采样器变量代表一幅或一套纹理贴图。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL3.png" alt="采样器基本类型及说明"></p><h4 id="5-结构体"><a href="#5-结构体" class="headerlink" title="5. 结构体"></a>5. 结构体</h4><p>使用 <strong>struct</strong> 关键字进行声明</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">info</span>&#123;</span></span><br><span class="line">   vec3 color;</span><br><span class="line">   vec3 position;</span><br><span class="line">   vec2 textureCoor;</span><br><span class="line">&#125;</span><br><span class="line">info CubeInfo;</span><br></pre></td></tr></table></figure><h4 id="6-数组"><a href="#6-数组" class="headerlink" title="6. 数组"></a>6. 数组</h4><p>在着色语言中，开发人员可以声明任何类型的数组。声明数组的方式主要有两种，具体如下所列。</p><ol><li><p>在声明数组的同时，指定数组的大小：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vec3 <span class="attribute">position</span><span class="selector-attr">[20]</span>; <span class="comment">//声明了一个包含 20 个 vec3 的数组，索引从 0 开始</span></span><br></pre></td></tr></table></figure></li><li><p>在声明数组并初始化的同时，可以不指定数组的大小：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">float x[<span class="string"></span>]=float[<span class="string">2</span>](<span class="link">1.0,2.0</span>); //数组的长度为 2 </span><br><span class="line">float y[<span class="string"></span>]=float[](1.0,2.0,3.0); //数组的长度为 3</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>OpenGL ES 3.0 的着色语言只支持一维数组的使用，不支持二维以及更多维数组 </p><p>的使用。对于这一点，请读者稍加注意。</p></blockquote><h4 id="7-空类型"><a href="#7-空类型" class="headerlink" title="7. 空类型"></a>7. 空类型</h4><p>空类型使用 <code>void</code> 表示，仅用来声明不返回任何值的函数，比如着色器中的 main 函数就是一个返回值为 <code>void</code> 类型的函数。</p><h3 id="存储限定符"><a href="#存储限定符" class="headerlink" title="存储限定符"></a>存储限定符</h3><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL4.png" alt="4种存储限定符及说明"></p><p>限定符在使用时应该放在变量类型之前，且使用 in、uniform 以及 out 限定符修饰的变量必须为全局变量。</p><p>着色器语言中没有默认限定符的概念，因此如果有需要，必须为全局变量明确指定需要的限定符。</p><h4 id="1-in-centroid-in限定符"><a href="#1-in-centroid-in限定符" class="headerlink" title="1. in/centroid in限定符"></a>1. in/centroid in限定符</h4><p>in/centroid in 限定符修饰的全局变量又称为输入变量，其形成当前着色器与渲染管线前驱阶段的动态输入接口。输入变量的值是在着色器开始执行时，由渲染管线的前一阶段送入。在着色器程序执行过程中，变量不可以被重新赋值。in/centroid in 限定符的使用分为如下两种情况。</p><ol><li><p>顶点着色器的输入变量</p><p>顶点着色器中只能使用 in 限定符来修饰全局变量，不能使用 centroid in 限定符和interpolation 限定符。</p><p>顶点着色器中用 in 限定符修饰的变量其值实质是由宿主程序（本书中为 Java、C++）批量传入渲染管线的，管线进行基本处理后再传递给顶点着色器。数据中有多少个顶点，管线就调用多少次顶点着色器，每次将一个顶点的各种属性数据传递给顶点着色器中对应的 in 变 量。因此，顶点着色器每次执行将完成对一个顶点各项属性数据的处理。</p><p>在顶点着色器中，in 限定符只能用来修饰浮点数标量、浮点数向量、矩阵变量以及有符号或无符号的整型标量或整型向量，不能用来修饰其他类型的变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">in vec3 aPosition; <span class="comment">//顶点位置</span></span><br><span class="line">in vec3 aNormal; <span class="comment">//顶点法向量</span></span><br></pre></td></tr></table></figure></li><li><p>片元着色器的输入变量</p><p>片元着色器中可以使用 in 或 centroid in 限定符来修饰全局变量，其变量用于接收来自顶点着 色器的相关数据，最典型的是接收根据顶点着色器的顶点数据插值产生的片元数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">in vec3 vPosition; <span class="comment">//接收从顶点着色器传递过来的顶点位置数据</span></span><br><span class="line">centroid in vec2 vTexCoord; <span class="comment">//接收从顶点着色器传递过来的纹理坐标数据</span></span><br><span class="line">flat in vec3 vColor; <span class="comment">//接收从顶点着色器传递过来的颜色数据</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="2-uniform-限定符"><a href="#2-uniform-限定符" class="headerlink" title="2. uniform 限定符"></a>2. uniform 限定符</h4><p>uniform 为一致变量限定符，一致变量指的是对于同一组顶点组成的单个 3D 物体中所有顶点都相同的量。uniform 变量可以用在顶点着色器或片元着色器中，其支持用来修饰所有的基本数据类型。与 in 变量类似，一致变量的值也是从宿主程序传入的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">uniform mat4 uMVPMatrix; <span class="comment">//总变换矩阵</span></span><br><span class="line">uniform mat4 uMMatrix; <span class="comment">//基本变换矩阵</span></span><br><span class="line">uniform vec3 uLightLocation; <span class="comment">//光源位置</span></span><br><span class="line">uniform vec3 uCamera; <span class="comment">//摄像机位置</span></span><br></pre></td></tr></table></figure><h4 id="3-out-centroid-out-限定符"><a href="#3-out-centroid-out-限定符" class="headerlink" title="3. out/centroid out 限定符"></a>3. out/centroid out 限定符</h4><p>out/centroid out 限定符修饰的全局变量又称为输出变量，其形成当前着色器与渲染管线后继阶段的动态输出接口。通常在当前着色器程序执行完毕时，输出变量的值才被送入后继阶段进行处理。因此，不能在着色器中声明同时起到输入和输出作用的 inout 全局变量，out/centroid out 限定符的使用分为如下两种情况。</p><ol><li><p>顶点着色器的输出变量</p><p>顶点着色器中可以使用 out 或 centroid out 限定符修饰全局变量，其变量用于向渲染管线后继 阶段传递当前顶点的数据。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL5.png" alt="了默认情况下out变量的工作原理"></p><p>从图中可以看出，在默认情况下，首先顶点着色器在每个顶点中都对 out 变量 vPosition进行了赋值。接着在片元着色器中接收 in 变量 vPosition 的值时得到的并不是某个顶点赋的特定值，而是根据片元所在的位置及图元中各个顶点的位置进行插值计算产生的值。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">out vec4 ambient; <span class="comment">//环境光 out 变量</span></span><br><span class="line">out vec4 diffuse; <span class="comment">//散射光 out 变量</span></span><br><span class="line">centroid out vec2 texCoor; <span class="comment">//纹理坐标 out 变量</span></span><br><span class="line">invariant centroid out vec4 color; <span class="comment">//颜色值 out 变量</span></span><br></pre></td></tr></table></figure></li><li><p>片元着色器的输出变量</p><p>在片元着色器中只能使用 out 限定符来修饰全局变量，而不能使用 centroid out 限定符。片元着色器中的 out 变量一般指的是由片元着色器写入计算完成片元颜色值的变量，一般在片元着色器的最后都需要对其进行赋值，最后将其送入渲染管线的后继阶段进行处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">out vec4 fragColor; <span class="comment">//输出的片元颜色</span></span><br><span class="line">out uint luminosity;</span><br></pre></td></tr></table></figure><blockquote><p>对于顶点着色器而言，一般是既声明 out 变量，又对 out 变量进行赋值用以传递给片元着色器。而片元着色器中声明 in 变量用于接收顶点着色器传过来的值即可，是不可以对 in 变量赋值的。OpenGL ES 3.0 中片元着色器内的内建输出变量gl_FragColor（此内建变量在 OpenGL ES 2.0 中几乎总要用到）不存在了，需要自己声明 out（vec4）变量，用声明的 out 变量替代 gl_FragColor 内建变量。</p></blockquote></li></ol><h4 id="4-const限定符"><a href="#4-const限定符" class="headerlink" title="4. const限定符"></a>4. const限定符</h4><p>用 const 限定符修饰的变量是只读的，其值是不可以变的，也就是常量，又称为编译时常量。</p><h3 id="插值限定符"><a href="#插值限定符" class="headerlink" title="插值限定符"></a>插值限定符</h3><p>插值（interpolation）限定符，其主要用于控制顶点着色器传递到片元着色器数据的插值方式。插值限定符包含 smooth、flat 两种。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL6.png" alt="两种限定符及说明"></p><ol><li><p>smooth限定符</p><p>如果顶点着色器中 out 变量之前含有 smooth 限定符或者不含有任何限定符，则传递到后继片元着色器对应的 in 变量的值，是在光栅化阶段由管线根据片元所属图元各个顶点对应的顶点着色器对此 out 变量的赋值情况，及片元与各顶点的位置关系插值产生。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL7.png" alt="顶点着色器中smooth限定符修饰out变量的工作原理"></p><p>从图中可以看出，当顶点着色器中的 out 变量被 smooth 限定符修饰时，首先顶点着色器在每个顶点中都对 out 变量 vColor 进行了赋值，接着在片元着色器中接收 in 变量 vColor 的值时得到的并不是某个顶点赋的特定值，而是根据片元的位置及图元中各个顶点的位置与各个顶点赋值的情况进行插值计算产生的值。</p><p>下面的代码片段给出了在顶点着色器中正确使用 smooth 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">smooth</span> <span class="keyword">out</span> <span class="type">vec3</span> normal; <span class="comment">// 顶点着色器 out 变量</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了在片元着色器中正确使用 smooth 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">smooth</span> <span class="keyword">in</span> <span class="type">vec3</span> normal; <span class="comment">//片元着色器 in 变量</span></span><br></pre></td></tr></table></figure></li><li><p>flat 限定符</p><p>如果顶点着色器中 out 变量之前含有 flat 限定符，则传递到后继片元着色器中对应的 in 变量的值不是在光栅化阶段插值产生的，一般是由图元的最后一个顶点对应的顶点着色器对此 out 变量所赋的值决定的。此时，图元中每个片元的此项值均相同。</p><p>下面的代码片段给出了在顶点着色器中正确使用 flat 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flat</span> <span class="keyword">out</span> <span class="type">vec4</span> vColor; <span class="comment">//用于传递给片元着色器的变量</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了在片元着色器中正确使用 flat 限定符的情况。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">flat</span> <span class="keyword">in</span> <span class="type">vec4</span> vColor; <span class="comment">//用于接收来自顶点着色器的变量</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="一致块"><a href="#一致块" class="headerlink" title="一致块"></a>一致块</h3><p>多个一致变量的声明可以通过类似结构体形式的接口块实现，该形式的接口块又称为一致块（uniform block）。一致块的数据是通过缓冲对象送入渲染管线的，以一致块的形式批量传送数据比单个传送效率高，其基本语法为：</p><figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">[&lt;layout 限定符&gt;]</span> uniform 一致块名称 &#123;&lt;成员变量列表&gt;&#125; <span class="meta">[&lt;实例名&gt;]</span></span><br></pre></td></tr></table></figure><p>下面的代码片段给出了一致块在顶点着色器中的正确使用。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">uniform</span> Transform&#123;            <span class="comment">//声明一个 uniform 接口块</span></span><br><span class="line">  <span class="type">float</span> radius;               <span class="comment">//半径成员</span></span><br><span class="line">  <span class="type">mat4</span> modelViewMatrix;       <span class="comment">//矩阵成员</span></span><br><span class="line">  <span class="keyword">uniform</span> <span class="type">mat3</span> normalMatrix;  <span class="comment">//矩阵成员</span></span><br><span class="line">&#125; block_Transform;</span><br></pre></td></tr></table></figure><h3 id="layout限定符"><a href="#layout限定符" class="headerlink" title="layout限定符"></a>layout限定符</h3><p>layout 限定符是从 OpenGL ES 3.0 开始出现的，其主要用于设置变量的存储索引（即引用）值，声明有几种不同的形式。 </p><ul><li><p>其可以作为接口块定义的一部分或者接口块的成员。</p></li><li><p>其也可以仅仅修饰 uniform，用于建立其他一致变量声明的参照，语法如下。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">layout</span> 限定符&gt; <span class="keyword">uniform</span></span><br></pre></td></tr></table></figure></li></ul><ul><li><p>其还可以用于修饰被接口限定符修饰的单独变量，语法如下。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;layout 限定符&gt;</span> <span class="section">&lt;接口限定符&gt;</span> <span class="section">&lt;变量声明&gt;</span></span><br></pre></td></tr></table></figure></li></ul><p>接口限定符有 in、out、uniform 三种选择，layout 限定符修饰接口限定符的内容将在下面进行介绍，具体内容如下。</p><ol><li><p>layout 输入限定符</p><p>顶点着色器允许 layout 输入限定符修饰输入变量的声明。下面的代码片段说明了这种形式的声明。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">in</span> <span class="type">vec3</span> aPosition; <span class="comment">// aPosition 输入变量的引用值为 0 </span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">in</span> <span class="type">vec4</span> aColor; <span class="comment">// aColor 输入变量的引用值为 1</span></span><br></pre></td></tr></table></figure></li><li><p>layout 输出限定符</p><p>片元着色器中，layout 限定符通过 location 值将输出变量和指定编号的绘制缓冲绑定起来。每一个输出变量的索引（引用）值都会对应到一个相应编号的绘制缓冲，而这个输出变量的值将写入相应缓冲。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">0</span>) <span class="keyword">out</span> <span class="type">vec4</span> fragColor; <span class="comment">//此输出变量写入到 0 号绘制缓冲</span></span><br><span class="line"><span class="keyword">layout</span> (<span class="keyword">location</span>=<span class="number">1</span>) <span class="keyword">out</span> <span class="type">vec4</span> colors[<span class="number">2</span>]; <span class="comment">//此输出变量写入到 1 号绘制缓冲</span></span><br></pre></td></tr></table></figure><p>顶点着色器不允许有 layout 输出限定符。</p></li></ol><h2 id="特殊的内建函数"><a href="#特殊的内建函数" class="headerlink" title="特殊的内建函数"></a>特殊的内建函数</h2><h3 id="顶点着色器中的内建函数"><a href="#顶点着色器中的内建函数" class="headerlink" title="顶点着色器中的内建函数"></a>顶点着色器中的内建函数</h3><ol><li><p>内建输入变量</p><p>顶点着色器中的内建输入变量主要有 <strong>gl_VertexID</strong> 以及<strong>gl_InstanceID</strong>。这两个变量分别为顶点整数索引和实例 ID，都只在顶点着色器中使用，其具体含义如下。</p><ul><li><p>gl_VertexID</p><p>gl_VertexID 是顶点着色器的一个内建输入变量，类型为“highp int”，主要用来记录顶点的整数索引。</p></li><li><p>gl_InstanceID</p><p>gl_InstanceID 是顶点着色器的另一个内建输入变量，类型为“highp int”，其用来记录采用实例绘制时当前图元对应的实例号。如果当前图元不是来自于实例绘制，则 gl_InstanceID 的值为 0。</p></li></ul></li><li><p>内建输出变量</p><p>顶点着色器中的内建输出变量主要有 <strong>gl_Position</strong> 和 <strong>gl_PointSize</strong>。这两个变量分别用来存放处理后顶点的位置和顶点的大小，都只能在顶点着色器中使用</p></li></ol><h3 id="片元着色器中的内建变量"><a href="#片元着色器中的内建变量" class="headerlink" title="片元着色器中的内建变量"></a>片元着色器中的内建变量</h3><p>片元着色器的内建变量分为输入和输出变量，其中输入变量包括 gl_FragCoord、gl_FrontFacing和 gl_PointCoord。输出变量包括 gl_FragDepth，其值为片元深度值.</p><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><p>与其他高级语言类似，为了方便开发，OpenGL ES 着色语言中也ᨀ供了很多的内置函数。这些函数大都已经被重载，一般具有 4 种变体，分别用来接收和返回 genType、genIType、genUType和 genBType 类型的值。</p><p><img src="/2019/07/24/OpenGL-ES-3-0着色语言/OpenGL-GLSL8.png" alt="4种变体及说明"></p><h2 id="用-invariant-修饰符避免值变问题"><a href="#用-invariant-修饰符避免值变问题" class="headerlink" title="用 invariant 修饰符避免值变问题"></a>用 invariant 修饰符避免值变问题</h2><p>值变问题是指在同样的着色器程序多次运行时，同一个表达式在同样输入值的情况下多次运行，结果不精确一致的现象。在大部分情况下，这并不影响最终效果的正确性。 </p><p>如果在某些特定情况下需要避免值变问题，可以用 invariant 修饰符来修饰变量。采用 invariant修饰符修饰变量主要有如下两种方式。</p><p>（1）在声明变量时加上 invariant 修饰符，具体情况参考如下代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">invariant</span> <span class="keyword">out</span> <span class="type">vec3</span> color;</span><br></pre></td></tr></table></figure><p>（2）对已经声明的变量补充使用 invariant 修饰符进行修饰，具体情况参考如下代码。</p><figure class="highlight glsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">out</span> <span class="type">vec3</span> color; </span><br><span class="line"><span class="keyword">invariant</span> color;</span><br></pre></td></tr></table></figure><p>需要注意的是，并不是所有的变量都可以用 invariant 修饰符修饰，只有符合如下几种情况的变量可以用 invariant 修饰符修饰。 </p><p> 顶点着色器中的内建输出变量，如 gl_Position。 </p><p> 顶点着色器中声明的以 out 修饰符修饰的变量。 </p><p> 片元着色器中内建的输出变量。 </p><p> 片元着色器中声明的以 out 修饰符修饰的变量。</p><p>另外一点就是，在使用时要注意，invariant 修饰符要放在其他的修饰符之前。同时，invariant修饰符只能用来修饰全局变量。</p><p>本文摘抄自《OpenGL ES 3.x 游戏开发》上卷</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;OpenGL ES 着色语言是一种高级的图形编程语言，其源自应用广泛的 C 语言，同时具有 RenderMan 以及其他着色语言的一些优良特性，易于被开发人员掌握。&lt;/p&gt;
&lt;p&gt;与传统通用编程语言有很大不同的是，其提供了更加丰富的原生类型，如向量、矩阵等。这 些特性的加入
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0绘制基础图形-点、线、三角</title>
    <link href="http://yoursite.com/2019/06/26/OpenGL-ES-3-0%E7%BB%98%E5%88%B6%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2-%E7%82%B9%E3%80%81%E7%BA%BF%E3%80%81%E4%B8%89%E8%A7%92/"/>
    <id>http://yoursite.com/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/</id>
    <published>2019-06-26T01:15:36.000Z</published>
    <updated>2019-06-26T07:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<p>开始正式学习OpenGL ES开发！</p><p>本博客是我在学习过程中做的记录，也希望和各位分享我的学习过程，如有错误，欢迎留言指正，共同学习。</p><h3 id="定义输入坐标"><a href="#定义输入坐标" class="headerlink" title="定义输入坐标"></a>定义输入坐标</h3><p>开始绘制图形之前，我们必须先给OpenGL输入一些顶点数据。OpenGL是一个3D图形库，所以我们在OpenGL中指定的所有坐标都是3D坐标（x、y和z）。OpenGL不是简单地把所有的3D坐标变换为屏幕上的2D像素；OpenGL仅当3D坐标在3个轴（x、y和z）上都为-1.0到1.0的范围内时才处理它。所有在所谓的标准化设备坐标(Normalized Device Coordinates)范围内的坐标才会最终呈现在屏幕上（在这个范围以外的坐标都不会显示）。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个3D位置。我们会将它们以标准化设备坐标的形式（OpenGL的可见区域）定义为一个<code>float</code>数组。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">float</span>[] vertexPoints = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于OpenGL是在3D空间中工作的，而我们渲染的是一个2D三角形，我们将它顶点的z坐标设置为0.0。这样子的话三角形每一点的深度都是一样的，从而使它看上去像是2D的。</p><p>定义这样的顶点数据以后，我们会把它作为输入发送给图形渲染管线的第一个处理阶段：顶点着色器。它会在GPU上创建内存用于储存我们的顶点数据，还要配置OpenGL如何解释这些内存，并且指定其如何发送给显卡。顶点着色器接着会处理我们在内存中指定数量的顶点。</p><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是<strong>标准化设备坐标</strong>了，标准化设备坐标是一个x、y和z值在-1.0到1.0的一小段空间。任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/OpenGLES3-2-1.png" alt=""></p><p>与通常的屏幕坐标不同，y轴正方向为向上，(0, 0)坐标是这个图像的中心，而不是左上角。最终你希望所有(变换过的)坐标都在这个坐标空间中，否则它们就不可见了。</p><h3 id="分配本地内存"><a href="#分配本地内存" class="headerlink" title="分配本地内存"></a>分配本地内存</h3><p>因为<code>OpenGL</code>作为本地系统库运行在系统中，虚拟机需要分配本地内存，供其存取。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SimpleRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//分配内存空间,每个浮点型占4字节空间</span></span><br><span class="line">    vertexBuffer = ByteBuffer.allocateDirect(vertexPoints.length * <span class="number">4</span>)</span><br><span class="line">            .order(ByteOrder.nativeOrder())</span><br><span class="line">            .asFloatBuffer();</span><br><span class="line">    <span class="comment">//传入指定的坐标数据</span></span><br><span class="line">    vertexBuffer.put(vertexPoints);</span><br><span class="line">    vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 顶点着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String vertextShader =</span><br><span class="line">        <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">        <span class="string">"layout (location = 0) in vec4 vPosition;\n"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">        <span class="string">"     gl_Position  = vPosition;\n"</span> + <span class="comment">//</span></span><br><span class="line">        <span class="string">"     gl_PointSize = 10.0;\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p><code>输入属性的数组</code>(一个名为<code>vPosition</code>的4分量向量)，<code>layout (location = 0)</code>表示这个变量的位置是顶点属性0。</p><p>将<code>vPosition</code>输入属性拷贝到名为<code>gl_Position</code>的特殊输出变量。</p><p>将浮点数据<code>10.0</code>拷贝到<code>gl_PointSize</code>的变量中。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 片段着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> String fragmentShader =</span><br><span class="line">        <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">        <span class="string">"precision mediump float;\n"</span> +</span><br><span class="line">        <span class="string">"out vec4 fragColor;\n"</span> +</span><br><span class="line">        <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">        <span class="string">"     fragColor = vec4(1.0,1.0,1.0,1.0);\n"</span> +</span><br><span class="line">        <span class="string">"&#125;\n"</span>;</span><br></pre></td></tr></table></figure><p>声明着色器中浮点变量的默认精度。</p><p>着色器声明一个<code>输出变量fragColor</code>，这个是一个4分量的向量。</p><p>表示将颜色值<code>(1.0,1.0,1.0,1.0)</code>，输出到颜色缓冲区。</p><h3 id="编译着色器"><a href="#编译着色器" class="headerlink" title="编译着色器"></a>编译着色器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 编译</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> type       顶点着色器:GLES30.GL_VERTEX_SHADER</span></span><br><span class="line"><span class="comment"> *                   片段着色器:GLES30.GL_FRAGMENT_SHADER</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileShader</span><span class="params">(<span class="keyword">int</span> type, String shaderCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//创建一个着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> shaderId = GLES30.glCreateShader(type);</span><br><span class="line">    <span class="keyword">if</span> (shaderId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//加载到着色器</span></span><br><span class="line">        GLES30.glShaderSource(shaderId, shaderCode);</span><br><span class="line">        <span class="comment">//编译着色器</span></span><br><span class="line">        GLES30.glCompileShader(shaderId);</span><br><span class="line">        <span class="comment">//检测状态</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            String logInfo = GLES30.glGetShaderInfoLog(shaderId);</span><br><span class="line">            System.err.println(logInfo);</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            GLES30.glDeleteShader(shaderId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shaderId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建-OpenGL-程序和着色器链接"><a href="#创建-OpenGL-程序和着色器链接" class="headerlink" title="创建 OpenGL 程序和着色器链接"></a>创建 OpenGL 程序和着色器链接</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 链接</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> vertexShaderId   顶点着色器</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> fragmentShaderId 片段着色器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linkProgram</span><span class="params">(<span class="keyword">int</span> vertexShaderId, <span class="keyword">int</span> fragmentShaderId)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> programId = GLES30.glCreateProgram();</span><br><span class="line">    <span class="keyword">if</span> (programId != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//将顶点着色器加入到程序</span></span><br><span class="line">        GLES30.glAttachShader(programId, vertexShaderId);</span><br><span class="line">        <span class="comment">//将片元着色器加入到程序中</span></span><br><span class="line">        GLES30.glAttachShader(programId, fragmentShaderId);</span><br><span class="line">        <span class="comment">//链接着色器程序</span></span><br><span class="line">        GLES30.glLinkProgram(programId);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//验证OpenGL程序是否可用</span></span><br><span class="line">        GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">            String logInfo = GLES30.glGetProgramInfoLog(programId);</span><br><span class="line">            System.err.println(logInfo);</span><br><span class="line">            GLES30.glDeleteProgram(programId);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> programId;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//创建失败</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制"><a href="#绘制" class="headerlink" title="绘制"></a>绘制</h3><p>准备工作结束，下来就开始绘制图形了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRenderer</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span></span></span><br></pre></td></tr></table></figure><p>实现<code>GLSurfaceView.Renderer</code>接口</p><h4 id="onSurfaceCreated"><a href="#onSurfaceCreated" class="headerlink" title="onSurfaceCreated"></a>onSurfaceCreated</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl10, EGLConfig eglConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//设置背景颜色</span></span><br><span class="line">    GLES30.glClearColor(<span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.5f</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 编译顶点着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = compileShader(GLES30.GL_VERTEX_SHADER, vertextShader);</span><br><span class="line">    <span class="comment">// 编译片段着色器</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = compileShader(GLES30.GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">    <span class="comment">//在OpenGLES环境中使用程序</span></span><br><span class="line">    GLES30.glUseProgram(linkProgram(vertexShaderId, fragmentShaderId));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onSurfaceChanged"><a href="#onSurfaceChanged" class="headerlink" title="onSurfaceChanged"></a>onSurfaceChanged</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl10, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">     <span class="comment">//设置视图窗口</span></span><br><span class="line">    GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="onDrawFrame"><a href="#onDrawFrame" class="headerlink" title="onDrawFrame"></a>onDrawFrame</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl10)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//把颜色缓冲区设置为我们预设的颜色</span></span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//准备坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">//启用顶点的句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绘制三个点</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_POINTS, 0, 3);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制直线</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_LINE_STRIP, 0, 2);</span></span><br><span class="line"><span class="comment">//        GLES30.glLineWidth(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="点-GLES30-GL-POINTS"><a href="#点-GLES30-GL-POINTS" class="headerlink" title="点 GLES30.GL_POINTS"></a>点 GLES30.GL_POINTS</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/point.jpg" alt=""></p><h5 id="线-GLES30-GL-LINE-STRIP"><a href="#线-GLES30-GL-LINE-STRIP" class="headerlink" title="线 GLES30.GL_LINE_STRIP"></a>线 GLES30.GL_LINE_STRIP</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/line.jpg" alt=""></p><h5 id="三角形-GLES30-GL-TRIANGLES"><a href="#三角形-GLES30-GL-TRIANGLES" class="headerlink" title="三角形 GLES30.GL_TRIANGLES"></a>三角形 GLES30.GL_TRIANGLES</h5><p><img src="/2019/06/26/OpenGL-ES-3-0绘制基础图形-点、线、三角/triangles.jpg" alt=""></p><p>通过<code>glDrawArrays</code>方法来执行最后的绘制，<code>GL_POINTS</code>代表绘制的类型（图元类型），而参数<code>0，1</code>则代表绘制的点的范围，它是一个左闭右开的区间。</p><h4 id="常用图元类型"><a href="#常用图元类型" class="headerlink" title="常用图元类型"></a>常用图元类型</h4><table><thead><tr><th style="text-align:left">图元类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">GL_POINTS</td><td style="text-align:left">点精灵图元，对指定的每个顶点进行绘制。</td></tr><tr><td style="text-align:left">GL_LINES</td><td style="text-align:left">绘制一系列不相连的线段。</td></tr><tr><td style="text-align:left">GL_LINE_STRIP</td><td style="text-align:left">绘制一系列相连的线段。</td></tr><tr><td style="text-align:left">GL_LINE_LOOP</td><td style="text-align:left">绘制一系列相连的线段，首尾相连。</td></tr><tr><td style="text-align:left">GL_TRIANGLES</td><td style="text-align:left">绘制一系列单独的三角形。</td></tr><tr><td style="text-align:left">GL_TRIANGLE_STRIP</td><td style="text-align:left">绘制一系列相互连接的三角形。</td></tr><tr><td style="text-align:left">GL_TRIANGLE_FAN</td><td style="text-align:left">绘制一系列相互连接的三角形</td></tr></tbody></table><h3 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SimpleRenderer</span> <span class="keyword">implements</span> <span class="title">GLSurfaceView</span>.<span class="title">Renderer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span>[] vertexPoints = <span class="keyword">new</span> <span class="keyword">float</span>[]&#123;</span><br><span class="line">            <span class="number">0.0f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            -<span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">            <span class="number">0.5f</span>, -<span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> FloatBuffer vertexBuffer;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 顶点着色器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String vertextShader =</span><br><span class="line">            <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                    <span class="string">"layout (location = 0) in vec4 vPosition;\n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"     gl_Position  = vPosition;\n"</span> +</span><br><span class="line">                    <span class="string">"     gl_PointSize = 10.0;\n"</span> +</span><br><span class="line">                    <span class="string">"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 片段着色器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> String fragmentShader =</span><br><span class="line">            <span class="string">"#version 300 es\n"</span> +</span><br><span class="line">                    <span class="string">"precision mediump float;\n"</span> +</span><br><span class="line">                    <span class="string">"out vec4 fragColor;\n"</span> +</span><br><span class="line">                    <span class="string">"void main() &#123;\n"</span> +</span><br><span class="line">                    <span class="string">"     fragColor = vec4(1.0,1.0,1.0,1.0);\n"</span> +</span><br><span class="line">                    <span class="string">"&#125;\n"</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SimpleRenderer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//分配内存空间,每个浮点型占4字节空间</span></span><br><span class="line">        vertexBuffer = ByteBuffer.allocateDirect(vertexPoints.length * <span class="number">4</span>)</span><br><span class="line">                .order(ByteOrder.nativeOrder())</span><br><span class="line">                .asFloatBuffer();</span><br><span class="line">        <span class="comment">//传入指定的坐标数据</span></span><br><span class="line">        vertexBuffer.put(vertexPoints);</span><br><span class="line">        vertexBuffer.position(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceCreated</span><span class="params">(GL10 gl10, EGLConfig eglConfig)</span> </span>&#123;</span><br><span class="line">        GLES30.glClearColor(<span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>, <span class="number">0f</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> vertexShaderId = compileShader(GLES30.GL_VERTEX_SHADER, vertextShader);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> fragmentShaderId = compileShader(GLES30.GL_FRAGMENT_SHADER, fragmentShader);</span><br><span class="line">        GLES30.glUseProgram(linkProgram(vertexShaderId, fragmentShaderId));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSurfaceChanged</span><span class="params">(GL10 gl10, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">        GLES30.glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDrawFrame</span><span class="params">(GL10 gl10)</span> </span>&#123;</span><br><span class="line">        GLES30.glClear(GLES30.GL_COLOR_BUFFER_BIT);</span><br><span class="line">        <span class="comment">//准备坐标数据</span></span><br><span class="line">        GLES30.glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GLES30.GL_FLOAT, <span class="keyword">false</span>, <span class="number">0</span>, vertexBuffer);</span><br><span class="line">        <span class="comment">//启用顶点的句柄</span></span><br><span class="line">        GLES30.glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//绘制三个点</span></span><br><span class="line">        GLES30.glDrawArrays(GLES30.GL_LINE_LOOP, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制直线</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_LINE_STRIP, 0, 2);</span></span><br><span class="line"><span class="comment">//        GLES30.glLineWidth(10);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//绘制三角形</span></span><br><span class="line"><span class="comment">//        GLES30.glDrawArrays(GLES30.GL_TRIANGLES, 0, 3);</span></span><br><span class="line">        <span class="comment">//禁止顶点数组的句柄</span></span><br><span class="line">        GLES30.glDisableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 编译</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">compileShader</span><span class="params">(<span class="keyword">int</span> type, String shaderCode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//创建一个着色器</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> shaderId = GLES30.glCreateShader(type);</span><br><span class="line">        <span class="keyword">if</span> (shaderId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//加载到着色器</span></span><br><span class="line">            GLES30.glShaderSource(shaderId, shaderCode);</span><br><span class="line">            <span class="comment">//编译着色器</span></span><br><span class="line">            GLES30.glCompileShader(shaderId);</span><br><span class="line">            <span class="comment">//检测状态</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] compileStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            GLES30.glGetShaderiv(shaderId, GLES30.GL_COMPILE_STATUS, compileStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (compileStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                String logInfo = GLES30.glGetShaderInfoLog(shaderId);</span><br><span class="line">                System.err.println(logInfo);</span><br><span class="line">                <span class="comment">//创建失败</span></span><br><span class="line">                GLES30.glDeleteShader(shaderId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> shaderId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 链接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">linkProgram</span><span class="params">(<span class="keyword">int</span> vertexShaderId, <span class="keyword">int</span> fragmentShaderId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> programId = GLES30.glCreateProgram();</span><br><span class="line">        <span class="keyword">if</span> (programId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//将顶点着色器加入到程序</span></span><br><span class="line">            GLES30.glAttachShader(programId, vertexShaderId);</span><br><span class="line">            <span class="comment">//将片元着色器加入到程序中</span></span><br><span class="line">            GLES30.glAttachShader(programId, fragmentShaderId);</span><br><span class="line">            <span class="comment">//链接着色器程序</span></span><br><span class="line">            GLES30.glLinkProgram(programId);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span>[] linkStatus = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">            GLES30.glGetProgramiv(programId, GLES30.GL_LINK_STATUS, linkStatus, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (linkStatus[<span class="number">0</span>] == <span class="number">0</span>) &#123;</span><br><span class="line">                String logInfo = GLES30.glGetProgramInfoLog(programId);</span><br><span class="line">                System.err.println(logInfo);</span><br><span class="line">                GLES30.glDeleteProgram(programId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> programId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//创建失败</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> GLSurfaceView mGLSurfaceView;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setupViews();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setupViews</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mGLSurfaceView = <span class="keyword">new</span> GLSurfaceView(<span class="keyword">this</span>);</span><br><span class="line">        setContentView(mGLSurfaceView);</span><br><span class="line">        mGLSurfaceView.setEGLContextClientVersion(<span class="number">3</span>);</span><br><span class="line">        GLSurfaceView.Renderer renderer = <span class="keyword">new</span> SimpleRenderer();</span><br><span class="line">        mGLSurfaceView.setRenderer(renderer);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考：<br>《OpenGL ES 3.0 编程指南第2版》<br>《OpenGL ES应用开发实践指南Android卷》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;开始正式学习OpenGL ES开发！&lt;/p&gt;
&lt;p&gt;本博客是我在学习过程中做的记录，也希望和各位分享我的学习过程，如有错误，欢迎留言指正，共同学习。&lt;/p&gt;
&lt;h3 id=&quot;定义输入坐标&quot;&gt;&lt;a href=&quot;#定义输入坐标&quot; class=&quot;headerlink&quot; title
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL ES 3.0基础概念笔记</title>
    <link href="http://yoursite.com/2019/06/24/OpenGL-ES-3-0%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2019/06/24/OpenGL-ES-3-0基础概念/</id>
    <published>2019-06-24T02:37:06.000Z</published>
    <updated>2019-06-26T07:35:16.000Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，该协会主要关注图形和多媒体方面的开放标准。</p></blockquote><h3 id="OpenGL-渲染流程"><a href="#OpenGL-渲染流程" class="headerlink" title="OpenGL 渲染流程"></a>OpenGL 渲染流程</h3><p>在OpenGL中，任何事物都在3D空间中，而屏幕和窗口却是2D像素数组，这导致OpenGL的大部分工作都是关于把3D坐标转变为适应你屏幕的2D像素。3D坐标转为2D坐标的处理过程是由OpenGL的图形渲染管线（Graphics Pipeline，大多译为管线，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程）管理的。图形渲染管线可以被划分为两个主要部分：第一部分把你的3D坐标转换为2D坐标，第二部分是把2D坐标转变为实际的有颜色的像素。</p><p>一个用来渲染图像的OpenGL程序需要执行的主要操作如下所示：</p><ul><li>从OpenGL的几何图元中设置数据 ，用于构建图形。</li><li>使用不同的着色器(shader)对输入的图元数据执行计算操作，判断它们的位置、颜色，以及其他渲染属性。</li><li>将输入图原点额数学描述转换为与屏幕位置相对应的像素片元(fragment)。这一步也被称为光栅化(rasterization)。</li><li>最后，针对光栅化过程产生的每个片元，执行片元着色器(fragment shader)，从而决定这个片元的最终颜色和位置。</li><li>如果有必要，还需要对每个片元执行一些额外的操作，例如判断片元对应的对象是否可见，或者将片元的颜色与当前屏幕位置的颜色进行融合。</li></ul><p>OpenGL是使用客户端 - 服务端的形式实现的，我们编写的应用程序可以看做客户端，而计算机图形硬件厂商所提供的OpenGL实现可以看做服务端。</p><h3 id="OpenGL-ES对Android平台的支持情况"><a href="#OpenGL-ES对Android平台的支持情况" class="headerlink" title="OpenGL ES对Android平台的支持情况"></a>OpenGL ES对Android平台的支持情况</h3><p>OpenGL ES当前主要版本有1.0/1.1/2.0/3.0/3.1。</p><table><thead><tr><th>OpenGL ES版本</th><th>Android版本</th><th>描述</th></tr></thead><tbody><tr><td>OpenGL ES1.0</td><td>Ａndroid 1.0+</td><td>OpenGL ES 1.x是针对固定硬件管线的，Ａndroid 1.0和更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES2.0</td><td>Android 2.2(API 8)+</td><td>OpenGL ES 2.x是针对可编程硬件管线的，不兼容OpenGL ES 1.x，Android 2.2(API 8)和更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES3.0</td><td>Android 4.3(API 18)+</td><td>向下兼容OpenGL ES 2.x，Android 4.3(API 18)及更高的版本支持这个API规范。</td></tr><tr><td>OpenGL ES3.1</td><td>Android 5.0 (API 21)+</td><td>向下兼容OpenGL ES3.0/2.0，Android 5.0（API 21）和更高的版本支持这个API规范</td></tr></tbody></table><h3 id="OpenGL-ES-3-0主要新功能有："><a href="#OpenGL-ES-3-0主要新功能有：" class="headerlink" title="OpenGL ES 3.0主要新功能有："></a>OpenGL ES 3.0主要新功能有：</h3><ul><li>1、渲染管线多重增强，实现先进视觉效果的加速，包括遮挡查询(Occlusion Query)、变缓反馈(Transform Feedback)、实例渲染(Instanced Rendering)、四个或更多渲染目标支持。</li><li>2、高质量ETC2/EAC纹理压缩格式成为一项标准功能，不同平台上不再需要需要不同的纹理集。</li><li>3、新版GLSL ES 3.0着色语言，全面支持整数和32位浮点操作。</li><li>4、纹理功能大幅增强，支持浮点纹理、3D纹理、深度纹理、顶点纹理、NPOT纹理、R/RG单双通道纹理、不可变纹理、2D阵列纹理、无二次幂限制纹理、阴影对比、调配(swizzle)、LOD与mip level clamps、无缝立方体贴图、采样对象、纹理MSAA抗锯齿渲染器。</li><li>5、一系列广泛的精确尺寸纹理和渲染缓冲格式，便携移动应用更简单。</li></ul><h3 id="OpenGL-ES-3-0图形管线图"><a href="#OpenGL-ES-3-0图形管线图" class="headerlink" title="OpenGL ES 3.0图形管线图"></a>OpenGL ES 3.0图形管线图</h3><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-1.png" alt=""></p><p>OpenGL ES 3.0实现了具有可编程着色功能的图形管线，由两个规范组成：<code>OpenGL ES 3.0 API 规范</code>和<code>OpenGL ES着色语言3.0规范(OpenGL ES SL)</code>。</p><p>图中蓝色方框代表OpenGL ES 3.0中管线的可编程阶段。</p><p>下图是一个图形渲染管线的每个阶段的抽象展示：</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-6.png" alt=""></p><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>顶点着色器实现了顶点操作的通用可编程方法。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-2.png" alt=""></p><p>顶点着色器的输入包括：</p><ul><li><strong>着色器程序</strong>一一描述顶点上执行操作的顶点着色器程序源代码或者可执行文件。</li><li><strong>顶点着色器输入(或者属性)</strong>一一用顶点数组提供的每个顶点的数据。</li><li><strong>统一变量(uniform)</strong>一一顶点(或者片段)着色器使用的不变数据。</li><li><strong>采样器</strong>一一代表顶点着色器使用纹理的特殊统一变量类型。</li></ul><p>顶点着色器的输出在OpenGL ES 2.0中称为可变（varying）变量，但在OpenGL ES 3.0中改名为顶点着色器输出变量。</p><p>顶点着色器可以用于通过矩阵变换位置、计算照明公式来生成逐顶点颜色以及生成或者变换纹理坐标等基于顶点的传统操作。</p><p>顶点着色器取得一个位置及相关的颜色数据作为输入属性，用一个 4x4矩阵变换位置，并输出变换后的位置和颜色。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es   <span class="comment">// OpenGL ES版本信息</span></span></span><br><span class="line">uniform mat4 u_mvpMatrix;  <span class="comment">// 同一变量u_mvpMatrix，它存储组合的模型视图和投影矩阵。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 描述顶点着色器的输入</span></span><br><span class="line">in vec4 a_postion; <span class="comment">// 输入顶点位置属性</span></span><br><span class="line">in vec4 a_color; <span class="comment">// 输入顶点颜色属性</span></span><br><span class="line"></span><br><span class="line">out vec4 v_color; <span class="comment">// 存储描述每个顶点颜色的顶点着色器输出</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123; <span class="comment">// 主函数</span></span><br><span class="line">v_color = a_color; <span class="comment">// 读入顶点属性输入a_color，并将其写入顶点输出颜色v_color</span></span><br><span class="line">gl_Position = u_mvpMatrix * a_postion <span class="comment">// gl_Position是自动生成的，将变换后的顶点位置写入gl_Position输出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="图元装配"><a href="#图元装配" class="headerlink" title="图元装配"></a>图元装配</h3><p>图元（Primitive）是三角形、直线或者点精灵等几何对象。图元的每个顶点被发送到顶点着色器的不同拷贝。在图元装配期间，这些顶点被组合为图元。</p><p>对于每个图元，必须确定图元是否位于视椎体（屏幕上可见的3D空间区域）内。如果没有完全在视锥体内，则可能需要进行裁剪。如果图元完全处于该区域之外，它就会被抛弃。裁剪之后，顶点位置被转换为屏幕坐标。裁剪和淘汰后，将数据传给下一阶段 - 光栅化阶段。</p><h3 id="光栅化"><a href="#光栅化" class="headerlink" title="光栅化"></a>光栅化</h3><p>在此阶段绘制对应的图元（点精灵、直线或者三角形）。光栅化是将图元转化为一组二维片段的过程，然后，这些片段由<strong>片段着色器</strong>处理。这些二维片段代表着可在屏幕上绘制的像素。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-3.png" alt=""></p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>片段着色器片段着色器为片段上的操作实现了通用的可编程方法。</p><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-4.png" alt=""></p><p>对光栅化阶段生成的每个片段执行这个着色器，采用如下输入：</p><ul><li>着色器程序——描述片段上所执行操作的片段着色器程序源代码或者可执行文件。</li><li>输入变量——光姗化单元用插值为每个片段生成的顶点着色器钧出。</li><li>统一变量——片段(或者顶点)着色器使用的不变数据。</li><li>采样器——代表片段着色器所用纹理的特殊统一变量类型。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 300 es <span class="comment">// OpenGL ES版本信息</span></span></span><br><span class="line">precision mediump <span class="keyword">float</span>; <span class="comment">// 设置默认的精度限定符</span></span><br><span class="line"></span><br><span class="line">in vec4 v_color; <span class="comment">// 描述片段着色器的输入</span></span><br><span class="line"></span><br><span class="line">out vec4 fragColor; <span class="comment">// 片段着色器输出变量的声明</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    fragColor = v_color;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="逐片段操作"><a href="#逐片段操作" class="headerlink" title="逐片段操作"></a>逐片段操作</h3><p><img src="/2019/06/24/OpenGL-ES-3-0基础概念/OpenGLES3-5.png" alt=""></p><p>在这个阶段中会对一个片段进行各种测试，来决定它是否可见。如果一个片段成功通过了所有测试，那么它就会被直接绘制到帧缓存中了， 它对应的像素的颜色值会被更新，如果开启了融合模式，那么片段的颜色会与该像素当前的颜色相叠加，形成一个新的颜色值并写入帧缓存中。</p><p>参考：<br>《OpenGL编程指南第8版》<br>《OpenGL ES 3.0编程指南》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;blockquote&gt;
&lt;p&gt;OpenGL ES (OpenGL for Embedded Systems) 是 OpenGL 三维图形 API 的子集，针对手机、PDA和游戏主机等嵌入式设备而设计。该API由Khronos集团定义推广，Khronos是一个图形软硬件行业协会，
      
    
    </summary>
    
      <category term="OpenGL ES 3.0" scheme="http://yoursite.com/categories/OpenGL-ES-3-0/"/>
    
    
      <category term="OpenGL ES" scheme="http://yoursite.com/tags/OpenGL-ES/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg+SDL2实现简易音视频同步播放器</title>
    <link href="http://yoursite.com/2019/05/05/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E7%AE%80%E6%98%93%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5%E6%92%AD%E6%94%BE%E5%99%A8/"/>
    <id>http://yoursite.com/2019/05/05/FFmpeg-SDL2实现简易音视频同步播放器/</id>
    <published>2019-05-05T13:58:20.000Z</published>
    <updated>2019-05-13T15:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p><a href="https://david1840.github.io/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现音频流播放</a></p><p><a href="https://david1840.github.io/2019/05/01/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/" target="_blank" rel="noopener">FFmpeg音视频同步</a></p><p><a href="">SDL2线程操作</a></p><p>经过前面一系列的SDL2学习，终于到最后实现一个完整的简易播放器了。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p><img src="/2019/05/05/FFmpeg-SDL2实现简易音视频同步播放器/SimplePlayer.png" alt=""></p><p>这是实现的简易播放器的线程模型，通过这张图再结合我们之前博客中学习的内容，基本可以了解播放器的一个整体运行流程。具体代码也是根据这张图来实现。</p><h2 id="重要结构体"><a href="#重要结构体" class="headerlink" title="重要结构体"></a>重要结构体</h2><h3 id="VideoState"><a href="#VideoState" class="headerlink" title="VideoState"></a>VideoState</h3><p>整个播放器中最重要的结构体，解复用、解码、音视频同步、渲染相关参数都在该结构体中，它贯穿了整个播放流程。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoState</span> &#123;</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> filename[<span class="number">1024</span>]; <span class="comment">// 文件名称</span></span><br><span class="line">    AVFormatContext *pFormatCtx; <span class="comment">// 上下文</span></span><br><span class="line">    <span class="keyword">int</span> videoStream, audioStream; <span class="comment">//音视频流index</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 同步相关</span></span><br><span class="line">    <span class="keyword">double</span> audio_clock;</span><br><span class="line">    <span class="keyword">double</span> frame_timer;</span><br><span class="line">    <span class="keyword">double</span> frame_last_pts;</span><br><span class="line">    <span class="keyword">double</span> frame_last_delay;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">double</span> video_clock; </span><br><span class="line">    <span class="keyword">double</span> video_current_pts; </span><br><span class="line">    <span class="keyword">int64_t</span> video_current_pts_time;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">//音频相关</span></span><br><span class="line">    AVStream *audio_st; <span class="comment">// 音频流</span></span><br><span class="line">    AVCodecContext *audio_ctx; <span class="comment">// 音频解码上下文</span></span><br><span class="line">    PacketQueue audioq; <span class="comment">// 音频队列</span></span><br><span class="line">    <span class="keyword">uint8_t</span> audio_buf[(MAX_AUDIO_FRAME_SIZE * <span class="number">3</span>) / <span class="number">2</span>]; <span class="comment">// 音频缓存</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf_size;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> audio_buf_index;</span><br><span class="line">    AVFrame audio_frame; <span class="comment">// 音频帧</span></span><br><span class="line">    AVPacket audio_pkt; <span class="comment">// 音频包</span></span><br><span class="line">    <span class="keyword">uint8_t</span> *audio_pkt_data;</span><br><span class="line">    <span class="keyword">int</span> audio_pkt_size;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">SwrContext</span> *<span class="title">audio_swr_ctx</span>;</span> <span class="comment">// 音频重采样</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//video</span></span><br><span class="line">    AVStream *video_st; <span class="comment">// 视频流</span></span><br><span class="line">    AVCodecContext *video_ctx; <span class="comment">// 视频流解码上下文</span></span><br><span class="line">    PacketQueue videoq; <span class="comment">// 视频流队列</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    VideoPicture pictq[VIDEO_PICTURE_QUEUE_SIZE]; <span class="comment">// 解码后视频帧数组</span></span><br><span class="line">    <span class="keyword">int</span> pictq_size, pictq_rindex, pictq_windex;</span><br><span class="line">    SDL_mutex *pictq_mutex;</span><br><span class="line">    SDL_cond *pictq_cond;</span><br><span class="line"></span><br><span class="line">    SDL_Thread *parse_tid; <span class="comment">// 解复用线程</span></span><br><span class="line">    SDL_Thread *video_tid;<span class="comment">// 视频解码线程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> quit; <span class="comment">// 退出标记位</span></span><br><span class="line">&#125; VideoState;</span><br></pre></td></tr></table></figure><h3 id="PacketQueue"><a href="#PacketQueue" class="headerlink" title="PacketQueue"></a>PacketQueue</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 解复用后音视频packet保存队列</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">PacketQueue</span> &#123;</span></span><br><span class="line">    AVPacketList *first_pkt, *last_pkt;</span><br><span class="line">    <span class="keyword">int</span> nb_packets;</span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line">    SDL_mutex *mutex;</span><br><span class="line">    SDL_cond *cond;</span><br><span class="line">&#125; PacketQueue;</span><br></pre></td></tr></table></figure><h3 id="VideoPicture"><a href="#VideoPicture" class="headerlink" title="VideoPicture"></a>VideoPicture</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 解码后视频帧</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VideoPicture</span> &#123;</span></span><br><span class="line">    AVFrame *frame;</span><br><span class="line">    <span class="keyword">int</span> width, height;</span><br><span class="line">    <span class="keyword">double</span> pts; <span class="comment">// 音视频同步后视频帧应该播放的时间</span></span><br><span class="line">&#125; VideoPicture;</span><br></pre></td></tr></table></figure><h2 id="具体代码"><a href="#具体代码" class="headerlink" title="具体代码"></a>具体代码</h2><h3 id="Main"><a href="#Main" class="headerlink" title="Main"></a>Main</h3><ol><li>初始化</li><li>创建定时器，定时视频帧的刷新</li><li>创建解复用线程</li><li>等待事件</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">WinMain</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> *file = <span class="string">"C:\\Users\\lenovo\\Desktop\\IMG_5950.mp4"</span>;</span><br><span class="line">    SDL_Event event;</span><br><span class="line">    VideoState *is;</span><br><span class="line">    is = av_mallocz(<span class="keyword">sizeof</span>(VideoState));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (SDL_Init(SDL_INIT_VIDEO | SDL_INIT_AUDIO | SDL_INIT_TIMER)) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Could not initialize SDL - %s\n"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//创建SDL Window</span></span><br><span class="line">    win = SDL_CreateWindow(<span class="string">"Media Player"</span>,</span><br><span class="line">                           <span class="number">100</span>,</span><br><span class="line">                           <span class="number">100</span>,</span><br><span class="line">                           <span class="number">640</span>, <span class="number">480</span>,</span><br><span class="line">                           SDL_WINDOW_RESIZABLE);</span><br><span class="line">    <span class="keyword">if</span> (!win) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"SDL_CreateWindow error，exit！"</span>, SDL_GetError());</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    renderer = SDL_CreateRenderer(win, <span class="number">-1</span>, <span class="number">0</span>);</span><br><span class="line">    text_mutex = SDL_CreateMutex();</span><br><span class="line">    </span><br><span class="line">    strlcpy(is-&gt;filename, file, <span class="keyword">sizeof</span>(is-&gt;filename));</span><br><span class="line">    is-&gt;pictq_mutex = SDL_CreateMutex();</span><br><span class="line">    is-&gt;pictq_cond = SDL_CreateCond();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定时刷新器，主要用来控制视频的刷新</span></span><br><span class="line">    schedule_refresh(is, <span class="number">40</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建解复用线程</span></span><br><span class="line">    is-&gt;parse_tid = SDL_CreateThread(demux_thread, <span class="string">"demux_thread"</span>, is);</span><br><span class="line">    <span class="keyword">if</span> (!is-&gt;parse_tid) &#123;</span><br><span class="line">        av_free(is);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 等待SDL事件，否则阻塞</span></span><br><span class="line">        SDL_WaitEvent(&amp;event);</span><br><span class="line">        <span class="keyword">switch</span> (event.type) &#123;</span><br><span class="line">            <span class="keyword">case</span> FF_QUIT_EVENT:</span><br><span class="line">            <span class="keyword">case</span> SDL_QUIT: <span class="comment">// 退出</span></span><br><span class="line">                is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">goto</span> Destroy;</span><br><span class="line">            <span class="keyword">case</span> SDL_KEYDOWN:<span class="comment">// ESC退出</span></span><br><span class="line">                <span class="keyword">if</span> (event.key.keysym.sym == SDLK_ESCAPE) &#123;</span><br><span class="line">                    is-&gt;quit = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">goto</span> Destroy;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FF_REFRESH_EVENT: <span class="comment">// 定时器刷新事件</span></span><br><span class="line">                video_refresh_timer(event.user.data1);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 退出</span></span><br><span class="line">    Destroy:</span><br><span class="line">    SDL_Quit();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解复用"><a href="#解复用" class="headerlink" title="解复用"></a>解复用</h3><ol><li>打开文件</li><li>找到音视频流</li><li>打开音频、视频流，创建视频解码线程，准备解码</li><li>读取packet，将音视频packet分别放入队列中，等待解码线程取出</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">demux_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> ((err_code = avformat_open_input(&amp;pFormatCtx, is-&gt;filename, <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the first video stream</span></span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; pFormatCtx-&gt;nb_streams; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_VIDEO &amp;&amp;</span><br><span class="line">            video_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            video_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (pFormatCtx-&gt;streams[i]-&gt;codecpar-&gt;codec_type == AVMEDIA_TYPE_AUDIO &amp;&amp;</span><br><span class="line">            audio_index &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            audio_index = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开音频流，创建解码器，配置参数</span></span><br><span class="line">    <span class="keyword">if</span> (audio_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, audio_index);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打开视频流，创建解码器，创建解码线程</span></span><br><span class="line">    <span class="keyword">if</span> (video_index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        stream_component_open(is, video_index);</span><br><span class="line">        <span class="comment">// video_tid = SDL_CreateThread(decode_video_thread, "decode_video_thread", is);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (av_read_frame(is-&gt;pFormatCtx, packet) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (is-&gt;pFormatCtx-&gt;pb-&gt;error == <span class="number">0</span>) &#123;</span><br><span class="line">                SDL_Delay(<span class="number">100</span>); <span class="comment">/* no error; wait for user input */</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将packet存入队列中</span></span><br><span class="line">        <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;videoStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;videoq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (packet-&gt;stream_index == is-&gt;audioStream) &#123;</span><br><span class="line">            packet_queue_put(&amp;is-&gt;audioq, packet);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            av_packet_unref(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频解码"><a href="#视频解码" class="headerlink" title="视频解码"></a>视频解码</h3><ol><li>从队列中取出视频packet</li><li>解码，同步</li><li>加码后Frame存入数组，等待视频渲染</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 视频解码</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">decode_video_thread</span><span class="params">(<span class="keyword">void</span> *arg)</span> </span>&#123;</span><br><span class="line">    VideoState *is = (VideoState *) arg;</span><br><span class="line">    AVPacket pkt1, *packet = &amp;pkt1;</span><br><span class="line">    AVFrame *pFrame;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    pFrame = av_frame_alloc();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">// 从视频队列中取出packet</span></span><br><span class="line">        <span class="keyword">if</span> (packet_queue_get(&amp;is-&gt;videoq, packet, <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 解码</span></span><br><span class="line">        avcodec_send_packet(is-&gt;video_ctx, packet);</span><br><span class="line">        <span class="keyword">while</span> (avcodec_receive_frame(is-&gt;video_ctx, pFrame) == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((pts = pFrame-&gt;best_effort_timestamp) != AV_NOPTS_VALUE) &#123;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                pts = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pts *= av_q2d(is-&gt;video_st-&gt;time_base);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 同步</span></span><br><span class="line">            pts = synchronize_video(is, pFrame, pts);</span><br><span class="line">            <span class="keyword">if</span> (queue_picture(is, pFrame, pts) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            av_packet_unref(packet);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    av_frame_free(&amp;pFrame);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="音频解码"><a href="#音频解码" class="headerlink" title="音频解码"></a>音频解码</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 音频设备回调</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">audio_callback</span><span class="params">(<span class="keyword">void</span> *userdata, Uint8 *stream, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    <span class="keyword">int</span> len1, audio_size;</span><br><span class="line">    <span class="keyword">double</span> pts;</span><br><span class="line"></span><br><span class="line">    SDL_memset(stream, <span class="number">0</span>, len);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;audio_buf_index &gt;= is-&gt;audio_buf_size) &#123;</span><br><span class="line">            <span class="comment">// 音频解码</span></span><br><span class="line">            audio_size = audio_decode_frame(is, is-&gt;audio_buf, <span class="keyword">sizeof</span>(is-&gt;audio_buf), &amp;pts);</span><br><span class="line">            <span class="keyword">if</span> (audio_size &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// 音频解码错误，播放静音</span></span><br><span class="line">                is-&gt;audio_buf_size = <span class="number">1024</span> * <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">                <span class="built_in">memset</span>(is-&gt;audio_buf, <span class="number">0</span>, is-&gt;audio_buf_size);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                is-&gt;audio_buf_size = audio_size;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;audio_buf_index = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        len1 = is-&gt;audio_buf_size - is-&gt;audio_buf_index;</span><br><span class="line">        <span class="keyword">if</span> (len1 &gt; len)</span><br><span class="line">            len1 = len;</span><br><span class="line">        <span class="comment">// 混音播放</span></span><br><span class="line">        SDL_MixAudio(stream, (<span class="keyword">uint8_t</span> *) is-&gt;audio_buf + is-&gt;audio_buf_index, len1, SDL_MIX_MAXVOLUME);</span><br><span class="line">        len -= len1;</span><br><span class="line">        stream += len1;</span><br><span class="line">        is-&gt;audio_buf_index += len1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="视频刷新播放"><a href="#视频刷新播放" class="headerlink" title="视频刷新播放"></a>视频刷新播放</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//// 视频刷新播放，并预测下一帧的播放时间，设置新的定时器</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">video_refresh_timer</span><span class="params">(<span class="keyword">void</span> *userdata)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    VideoState *is = (VideoState *) userdata;</span><br><span class="line">    VideoPicture *vp;</span><br><span class="line">    <span class="keyword">double</span> actual_delay, delay, sync_threshold, ref_clock, diff;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (is-&gt;video_st) &#123;</span><br><span class="line">        <span class="keyword">if</span> (is-&gt;pictq_size == <span class="number">0</span>) &#123;</span><br><span class="line">            schedule_refresh(is, <span class="number">1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 从数组中取出一帧视频帧</span></span><br><span class="line">            vp = &amp;is-&gt;pictq[is-&gt;pictq_rindex];</span><br><span class="line"></span><br><span class="line">            is-&gt;video_current_pts = vp-&gt;pts;</span><br><span class="line">            is-&gt;video_current_pts_time = av_gettime();</span><br><span class="line">            <span class="comment">// 当前Frame时间减去上一帧的时间，获取两帧间的时差</span></span><br><span class="line">            delay = vp-&gt;pts - is-&gt;frame_last_pts;</span><br><span class="line">            <span class="keyword">if</span> (delay &lt;= <span class="number">0</span> || delay &gt;= <span class="number">1.0</span>) &#123;</span><br><span class="line">                <span class="comment">// 延时小于0或大于1秒（太长）都是错误的，将延时时间设置为上一次的延时时间</span></span><br><span class="line">                delay = is-&gt;frame_last_delay;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 保存延时和PTS，等待下次使用</span></span><br><span class="line">            is-&gt;frame_last_delay = delay;</span><br><span class="line">            is-&gt;frame_last_pts = vp-&gt;pts;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取音频Audio_Clock</span></span><br><span class="line">            ref_clock = get_audio_clock(is);</span><br><span class="line">            <span class="comment">// 得到当前PTS和Audio_Clock的差值</span></span><br><span class="line">            diff = vp-&gt;pts - ref_clock;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// AV_SYNC_THRESHOLD 最小刷新时间</span></span><br><span class="line">            sync_threshold = (delay &gt; AV_SYNC_THRESHOLD) ? delay : AV_SYNC_THRESHOLD;</span><br><span class="line">            <span class="comment">// diff小于非同步阈值，可以进行同步</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">fabs</span>(diff) &lt; AV_NOSYNC_THRESHOLD) &#123;</span><br><span class="line">                <span class="keyword">if</span> (diff &lt;= -sync_threshold) &#123;</span><br><span class="line">                    <span class="comment">// 视频时间在音频时间之前，应该让视频尽快播放</span></span><br><span class="line">                    delay = <span class="number">0</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diff &gt;= sync_threshold) &#123;</span><br><span class="line">                     <span class="comment">// 视频时间在音频时间之后，应该让视频延迟播放</span></span><br><span class="line">                    delay = <span class="number">2</span> * delay;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            is-&gt;frame_timer += delay;</span><br><span class="line">            <span class="comment">// 最终真正要延时的时间</span></span><br><span class="line">            actual_delay = is-&gt;frame_timer - (av_gettime() / <span class="number">1000000.0</span>);</span><br><span class="line">            <span class="keyword">if</span> (actual_delay &lt; <span class="number">0.010</span>) &#123;</span><br><span class="line">                <span class="comment">// 延时时间过小就设置最小值</span></span><br><span class="line">                actual_delay = <span class="number">0.010</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 根据延时时间重新设置定时器，刷新视频</span></span><br><span class="line">            schedule_refresh(is, (<span class="keyword">int</span>) (actual_delay * <span class="number">1000</span> + <span class="number">0.5</span>));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 视频帧显示</span></span><br><span class="line">            video_display(is);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 更新视频帧数组下标</span></span><br><span class="line">            <span class="keyword">if</span> (++is-&gt;pictq_rindex == VIDEO_PICTURE_QUEUE_SIZE) &#123;</span><br><span class="line">                is-&gt;pictq_rindex = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            SDL_LockMutex(is-&gt;pictq_mutex);</span><br><span class="line">            <span class="comment">// 视频帧数组减一</span></span><br><span class="line">            is-&gt;pictq_size--;</span><br><span class="line">            SDL_CondSignal(is-&gt;pictq_cond);</span><br><span class="line">            SDL_UnlockMutex(is-&gt;pictq_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        schedule_refresh(is, <span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>大体的流程就是这样了，相比之前的Demo复杂度会高不少，但是所有的知识在前面的博客中都有涉及，在博客中也讲不了什么东西，还是直接自己运行，再去看代码会更好，理清流程，整个播放器的代码也不会很难看懂，这里附上<a href="https://github.com/David1840/SimplePlayer/blob/master/SimplePlayer.c" target="_blank" rel="noopener">源码 Github-SimplePlay</a></p><p>学习音视频推荐：</p><p>第一个当然推荐雷神雷霄骅，中国FFmpeg第一人，系统地整理了FFmpeg相关的知识点，入门必看，可惜早逝，缅怀雷神。<a href="https://me.csdn.net/leixiaohua1020" target="_blank" rel="noopener">雷霄骅的博客</a></p><p>第二个推荐大神李超的<a href="https://coding.imooc.com/class/279.html" target="_blank" rel="noopener">慕课网视频</a>，讲得非常实用，音视频小白入门值得一看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
  <entry>
    <title>SDL2线程操作</title>
    <link href="http://yoursite.com/2019/05/03/SDL2%E7%BA%BF%E7%A8%8B%E6%93%8D%E4%BD%9C/"/>
    <id>http://yoursite.com/2019/05/03/SDL2线程操作/</id>
    <published>2019-05-03T01:19:14.000Z</published>
    <updated>2019-05-13T15:08:57.000Z</updated>
    
    <content type="html"><![CDATA[<p>SDL2文章列表</p><p><a href="https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/" target="_blank" rel="noopener">SDL2入门</a></p><p><a href="https://david1840.github.io/2019/04/15/SDL2%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86/" target="_blank" rel="noopener">SDL2事件处理</a></p><p><a href="https://david1840.github.io/2019/04/16/SDL2%E7%BA%B9%E7%90%86%E6%B8%B2%E6%9F%93/" target="_blank" rel="noopener">SDL2纹理渲染</a></p><p><a href="https://david1840.github.io/2019/04/19/SDL2%E9%9F%B3%E9%A2%91%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">SDL2音频播放</a></p><p><a href="https://david1840.github.io/2019/04/22/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E8%A7%86%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现视频流播放</a></p><p><a href="https://david1840.github.io/2019/04/26/FFmpeg-SDL2%E5%AE%9E%E7%8E%B0%E9%9F%B3%E9%A2%91%E6%B5%81%E6%92%AD%E6%94%BE/" target="_blank" rel="noopener">FFmpeg+SDL2实现音频流播放</a></p><p><a href="https://david1840.github.io/2019/05/01/FFmpeg%E9%9F%B3%E8%A7%86%E9%A2%91%E5%90%8C%E6%AD%A5/" target="_blank" rel="noopener">FFmpeg音视频同步</a></p><p>今天一起了解下在SDL2中多线程的使用。</p><p>下面是SDL2中多线程相关的API。可以发现实际上SDL2中的多线程操作也只是提供了统一的接口，没有做其他操作。</p><h5 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_Thread* <span class="title">SDL_CreateThread</span><span class="params">(SDL_ThreadFunction fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">const</span> <span class="keyword">char</span>* name,</span></span></span><br><span class="line"><span class="function"><span class="params">                             <span class="keyword">void</span>* data)</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"> <span class="comment">// fn: 线程要运行的函数。</span></span></span><br><span class="line"><span class="function"> <span class="comment">// name: 线程名。</span></span></span><br><span class="line"><span class="function"> <span class="comment">// data: 函数参数。</span></span></span><br><span class="line"><span class="function">    </span></span><br><span class="line"><span class="function"><span class="comment">// 回调函数    </span></span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">int</span> <span class="params">(SDLCALL * SDL_ThreadFunction)</span> <span class="params">(<span class="keyword">void</span> *data)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="等待线程"><a href="#等待线程" class="headerlink" title="等待线程"></a>等待线程</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_WaitThread</span><span class="params">(SDL_Thread* thread,</span></span></span><br><span class="line"><span class="function"><span class="params">                    <span class="keyword">int</span>* status)</span></span></span><br><span class="line"><span class="function"><span class="comment">//等待线程结束</span></span></span><br></pre></td></tr></table></figure><h5 id="创建互斥量"><a href="#创建互斥量" class="headerlink" title="创建互斥量"></a>创建互斥量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_mutex* <span class="title">SDL_CreateMutex</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br></pre></td></tr></table></figure><h5 id="销毁互斥量"><a href="#销毁互斥量" class="headerlink" title="销毁互斥量"></a>销毁互斥量</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_LockMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_UnlockMutex</span><span class="params">(SDL_mutex* mutex)</span></span></span><br></pre></td></tr></table></figure><h5 id="信号量创建-销毁"><a href="#信号量创建-销毁" class="headerlink" title="信号量创建/销毁"></a>信号量创建/销毁</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SDL_cond * <span class="title">SDL_CreateCond</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SDL_DestroyCond</span><span class="params">(SDL_cond * cond)</span></span>;</span><br></pre></td></tr></table></figure><h5 id="信号量等待-通知"><a href="#信号量等待-通知" class="headerlink" title="信号量等待 / 通知"></a>信号量等待 / 通知</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_CondWait</span><span class="params">(SDL_cond * cond, SDL_mutex * mutex)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SDL_CondSignal</span><span class="params">(SDL_cond * cond)</span></span>;</span><br></pre></td></tr></table></figure><p>SDL2中的多线程其实并没有什么可以讲的，和我们用其他语言做多线程处理没有区别，在这里熟悉下API。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;SDL2文章列表&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://david1840.github.io/2019/04/11/SDL2%E9%9F%B3%E8%A7%86%E9%A2%91%E6%B8%B2%E6%9F%93%E5%85%A5%E9%97%A8/&quot; tar
      
    
    </summary>
    
      <category term="SDL2" scheme="http://yoursite.com/categories/SDL2/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="SDL2" scheme="http://yoursite.com/tags/SDL2/"/>
    
  </entry>
  
</feed>
