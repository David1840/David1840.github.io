<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Programmer Liu</title>
  
  <subtitle>精彩生活，不惧挑战，做一只有理想的的程序猿</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-05T11:04:28.000Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>刘伟</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Android JNI开发-Linux C程序移植</title>
    <link href="http://yoursite.com/2018/12/05/Android-JNI%E5%BC%80%E5%8F%91-LinuxC%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/"/>
    <id>http://yoursite.com/2018/12/05/Android-JNI开发-LinuxC程序移植/</id>
    <published>2018-12-05T09:51:16.000Z</published>
    <updated>2018-12-05T11:04:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要提供一些特有的接口给C就好了，以后只维护一套代码，简单方便。</p><p>经过一天的尝试，最终成功完成了一个满足需求的Demo，整体结构如下：</p><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni1.png" alt=""></p><p>整体来看也比较简单，Java调JNI，JNI启动Linux程序，Linux程序运行中需要操作界面时再用JNI的反射方法调用到Java层修改界面。</p><p>接下来看下具体实现：</p><h3 id="代码结构"><a href="#代码结构" class="headerlink" title="代码结构"></a>代码结构</h3><p><img src="/2018/12/05/Android-JNI开发-LinuxC程序移植/linuxjni2.png" alt=""></p><p><strong>LinuxHandler.java 定义native方法和等待反射调用方法</strong></p><p><strong>Androidhandle.c  Linux代码调用方法反射Java层</strong></p><p><strong>demo.c    Linux小组同事提供的测试代码，里面有他们简化的业务逻辑</strong></p><p><strong>linuxhandle.c   JNI方法</strong></p><h4 id="LinuxHandler-java"><a href="#LinuxHandler-java" class="headerlink" title="LinuxHandler.java"></a>LinuxHandler.java</h4><p>Java层启动</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LinuxHandle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">startLinux</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">speak</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"speak C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showMsg</span><span class="params">(String msg)</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"TEST"</span>, <span class="string">"showMsg C-&gt; "</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义了三个方法，native方法startLinux()从Java层启动Linux程序，另外两个是模拟等待反射调用的操作界面方法。</p><h4 id="linuxhandle-c"><a href="#linuxhandle-c" class="headerlink" title="linuxhandle.c"></a>linuxhandle.c</h4><p>真正去启动Linux程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"demo.h"</span> <span class="comment">//Linux C 头文件，调用main()方法</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">JavaVM *local_jvm = <span class="literal">NULL</span>; </span><br><span class="line">jobject local_object = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_***_linuxdemo_LinuxHandle</span></span><br><span class="line"><span class="comment"> * Method:    startLinux</span></span><br><span class="line"><span class="comment"> * Signature: ()V</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT <span class="keyword">void</span> JNICALL Java_com_***_linuxdemo_LinuxHandle_startLinux</span><br><span class="line">        (JNIEnv *env, jobject object) &#123;</span><br><span class="line">    (*env)-&gt;GetJavaVM(env, &amp;local_jvm); <span class="comment">//保存到全局变量JVM中</span></span><br><span class="line">    local_object = (*env)-&gt;NewGlobalRef(env, object); <span class="comment">/* 创建对象的本地变量 */</span></span><br><span class="line">    main(); <span class="comment">//启动Linux C程序</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Androidhandle-c"><a href="#Androidhandle-c" class="headerlink" title="Androidhandle.c"></a>Androidhandle.c</h3><p>等待Linux程序调用</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"linuxhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">showMessage_c</span><span class="params">(<span class="keyword">char</span> *message)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">extern</span> JavaVM *local_jvm; <span class="comment">//获取全局JVM，由它获取JNIEnv</span></span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">extern</span> jobject local_object;</span><br><span class="line">    (*local_jvm)-&gt;AttachCurrentThread(local_jvm, &amp;env, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jclass jclass1 = (*env)-&gt;FindClass(env, <span class="string">"com/***/linuxdemo/LinuxHandle"</span>);</span><br><span class="line">    </span><br><span class="line">    jmethodID methodID = (*env)-&gt;GetMethodID(env, jclass1, <span class="string">"showMsg"</span>,</span><br><span class="line">                                             <span class="string">"(Ljava/lang/String;)V"</span>);</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;CallVoidMethod(env, local_object, methodID, (*env)-&gt;NewStringUTF(env, message));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">speak_c</span><span class="params">(<span class="keyword">char</span> *text)</span> </span>&#123;</span><br><span class="line">    LOGE(<span class="string">"speak at C"</span>);</span><br><span class="line">    <span class="comment">//同样反射到Java层</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Demo-c"><a href="#Demo-c" class="headerlink" title="Demo.c"></a>Demo.c</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Androidhandle.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    ......  <span class="comment">//公司业务逻辑代码</span></span><br><span class="line">    speak_c(<span class="string">"1234"</span>);</span><br><span class="line">    showMessage_c(<span class="string">"adc"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我自己做完后也做了多次验证，并且导入第三方SO库测试也没有问题，但因为还只是个验证可行性的Demo，后面就要开始正式做移植的项目了，如果遇到了什么坑我会尽快补上。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在公司做一个项目，想把之前Linux小组做了三四年的一个项目移植到Android平台上。如果让Android从头开始做，估计又是三四年时间去对接不同平台，而且还需要两个组同时维护，这样太不划算了。所以就打算把Linux上的程序移植到Android上，Android只需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg中的时间戳与时间基</title>
    <link href="http://yoursite.com/2018/12/05/FFmpeg%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E6%88%B3%E4%B8%8E%E6%97%B6%E9%97%B4%E5%9F%BA/"/>
    <id>http://yoursite.com/2018/12/05/FFmpeg中的时间戳与时间基/</id>
    <published>2018-12-05T05:42:44.000Z</published>
    <updated>2018-12-05T03:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。</p><h3 id="PTS和DTS"><a href="#PTS和DTS" class="headerlink" title="PTS和DTS"></a>PTS和DTS</h3><p>这两个概念其实在刚开始的时候就提到过，今天的概念跟它们还是有很大关系的，所以再说一次概念，具体解释请看<a href="https://www.jianshu.com/p/e3acc140aa90" target="_blank" rel="noopener">音视频基础概念</a>。</p><ul><li>PTS: Decode Time Stamp，显示渲染用的时间戳，告诉我们什么时候需要显示</li><li>DTS: Presentation Time Stamp，视频解码时的时间戳，告诉我们什么时候需要解码</li></ul><h3 id="时间基"><a href="#时间基" class="headerlink" title="时间基"></a>时间基</h3><p>在写代码处理音视频流的时候经常会看到<code>in_stream-&gt;time_base</code>这样的代码，这表示的是输入流的时间基，time_base时间基的结构体定义如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * This is the fundamental unit of time (in seconds) in terms</span></span><br><span class="line"><span class="comment"> * of which frame timestamps are represented.</span></span><br><span class="line"><span class="comment"> * 这是表示帧时间戳的基本时间单位(以秒为单位)。</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVRational</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> num; <span class="comment">///&lt; Numerator 分子</span></span><br><span class="line">    <span class="keyword">int</span> den; <span class="comment">///&lt; Denominator 分母</span></span><br><span class="line">&#125; AVRational;</span><br></pre></td></tr></table></figure><p>可以看出时间基是一个分数，以秒为单位，比如1/50秒，那它到底表示的是什么意思呢？以帧率为例，如果它的时间基是1/50秒，那么就表示每隔1/50秒显示一帧数据，也就是每1秒显示50帧，帧率为50FPS。</p><p>每一帧数据都有对应的PTS，在播放视频或音频的时候我们需要将PTS时间戳转化为以秒为单位的时间，用来最后的展示。那如何计算一桢在整个视频中的时间位置？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">double</span> <span class="title">av_q2d</span><span class="params">(AVRational a)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a.num / (<span class="keyword">double</span>) a.den;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算一桢在整个视频中的时间位置</span></span><br><span class="line">timestamp(秒) = pts * av_q2d(st-&gt;time_base);</span><br><span class="line"></span><br><span class="line"><span class="comment">//计算视频长度的方法：</span></span><br><span class="line">time(秒) = st-&gt;duration * av_q2d(st-&gt;time_base);</span><br></pre></td></tr></table></figure><h4 id="内部时间基"><a href="#内部时间基" class="headerlink" title="内部时间基"></a>内部时间基</h4><p>FFmpeg中的所有时间都是以它为一个单位</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Internal time base represented as integer</span></span><br><span class="line"><span class="comment"> * 内部时间基</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE            1000000</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//内部时间基的分数表示，实际上它是AV_TIME_BASE的倒数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span>  AV_TIME_BASE_Q   (AVRational)&#123;1, AV_TIME_BASE&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//ffmpeg内部的时间与标准的时间转换方法</span></span><br><span class="line">timestamp(ffmpeg内部时间戳) = AV_TIME_BASE * time(秒)</span><br><span class="line">time(秒) = AV_TIME_BASE_Q * timestamp(ffmpeg内部时间戳)</span><br></pre></td></tr></table></figure><p>当需要把视频跳转到N秒的时候可以使用下面的方法：</p><figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">av_seek_frame(fmt_ctx, index_of_video, N * <span class="built_in">AV_TIME_BASE</span>, <span class="built_in">AVSEEK_FLAG_BACKWARD</span>);</span><br></pre></td></tr></table></figure><p>有时候我们需要在不同的时间基之间做换算。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> av_rescale_q(<span class="keyword">int64_t</span> a, AVRational bq, AVRational cq) av_const;</span><br></pre></td></tr></table></figure><p>这个方法实际的操作是 <code>a * bq / cq</code>，看起来简单，但它内部处理了数值溢出的问题，所以我们在操作的时候最好还是直接调用这个方法。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在学习FFmpeg的过程中发现，其他的知识点还比较清楚，就是对于FFmpeg中的时间基概念模糊，前面做Demo也只是照猫画虎，没有真正理解，所以今天花时间好好理解一下时间戳和时间基的概念。&lt;/p&gt;
&lt;h3 id=&quot;PTS和DTS&quot;&gt;&lt;a href=&quot;#PTS和DTS&quot; 
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之二叉树的所有路径</title>
    <link href="http://yoursite.com/2018/12/04/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84/"/>
    <id>http://yoursite.com/2018/12/04/每日一算法之二叉树的所有路径/</id>
    <published>2018-12-04T01:07:40.000Z</published>
    <updated>2018-12-05T03:20:41.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个二叉树，返回所有从根节点到叶子节点的路径。</p><p><strong>说明:</strong> 叶子节点是指没有子节点的节点。</p><p><strong>示例:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line"></span><br><span class="line">   <span class="number">1</span></span><br><span class="line"> /   \</span><br><span class="line"><span class="number">2</span>     <span class="number">3</span></span><br><span class="line"> \</span><br><span class="line">  <span class="number">5</span></span><br><span class="line"></span><br><span class="line">输出: [<span class="string">"1-&gt;2-&gt;5"</span>, <span class="string">"1-&gt;3"</span>]</span><br><span class="line"></span><br><span class="line">解释: 所有根节点到叶子节点的路径为: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">5</span>, <span class="number">1</span>-&gt;<span class="number">3</span></span><br></pre></td></tr></table></figure><p>有关二叉树的问题绝大多数都可以通过递归解决。先序遍历二叉树，将每个节点加在字符串的后面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * class TreeNode(var `val`: Int = 0) &#123;</span></span><br><span class="line"><span class="comment"> *     var left: TreeNode? = null</span></span><br><span class="line"><span class="comment"> *     var right: TreeNode? = null</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function">fun <span class="title">binaryTreePaths</span><span class="params">(root: TreeNode?)</span>: List&lt;String&gt; </span>&#123;</span><br><span class="line">        val result = ArrayList&lt;String&gt;()</span><br><span class="line">        binaryTreePaths2(root, <span class="string">""</span>, result)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> fun <span class="title">binaryTreePaths2</span><span class="params">(root: TreeNode?, str: String, result: MutableList&lt;String&gt;)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> mStr = str</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) <span class="keyword">return</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mStr.isEmpty())&#123;</span><br><span class="line">            mStr = root.`val`.toString() + <span class="string">""</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            mStr += <span class="string">"-&gt;"</span> + root.`val`</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (root.left != <span class="keyword">null</span> || root.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            binaryTreePaths2(root.left, mStr, result)</span><br><span class="line">            binaryTreePaths2(root.right, mStr, result)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            result.add(mStr)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>发现一个问题，在leetcode上，同样的代码逻辑，同样的测试用例，Java代码17ms，Kotlin却要用352 ms，这差距有点太大了吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个二叉树，返回所有从根节点到叶子节点的路径。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;说明:&lt;/strong&gt; 叶子节点是指没有子节点的节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight clean&quot;&gt;&lt;ta
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-使用第三方SO库</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-%E4%BD%BF%E7%94%A8%E7%AC%AC%E4%B8%89%E6%96%B9SO%E5%BA%93/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-使用第三方SO库/</id>
    <published>2018-12-03T11:09:27.000Z</published>
    <updated>2018-12-03T12:17:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要通过我自己的C文件再去调用so库中的方法。</p><h1 id="生成SO库"><a href="#生成SO库" class="headerlink" title="生成SO库"></a>生成SO库</h1><h3 id="Native方法"><a href="#Native方法" class="headerlink" title="Native方法"></a>Native方法</h3><p>新建项目JNISODemo，在MainActivity中定义Native方法：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function">String <span class="title">getString</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h3 id="头文件生成"><a href="#头文件生成" class="headerlink" title="头文件生成"></a>头文件生成</h3><p>.h文件的生成是在命令行cd到main目录下，再使用javah生成。</p><p>这次是想介绍下快捷方式。</p><p><strong>File -&gt; Settings -&gt; Tools -&gt; External tools -&gt; +</strong></p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-c4046ae731276f29.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Program:</span>   <span class="variable">$JDKPath</span><span class="variable">$\</span>bin\javah.exe </span><br><span class="line"><span class="symbol">Arguments:</span>  -classpath . -jni -o <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\jni\<span class="variable">$Prompt</span><span class="variable">$ </span> <span class="variable">$FileClass</span><span class="variable">$ </span></span><br><span class="line">Working <span class="symbol">directory:</span> <span class="variable">$ModuleFileDir</span><span class="variable">$\</span>src\main\java</span><br></pre></td></tr></table></figure><p>在我们声明native方法的类上点击右键，javah，输入命名（我命名为Test.h)，之后就会先自动创建一个jni文件夹，然后生成一个Test.h文件，copy Test.h，并将命名改为Test.c。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-469baae7078430a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码"><a href="#完成C代码" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>在Test.c中简单完成下我们定义的方法，返回一个字符串：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="comment">/* Header for class com_david_jnisodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jnisodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jnisodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> (*env)-&gt;NewStringUTF(env, <span class="string">"This is a test!"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><h3 id="CMakeList-txt"><a href="#CMakeList-txt" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION 3.4.1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">add_library( # Sets the name of the library.</span><br><span class="line">             Test</span><br><span class="line">             </span><br><span class="line">             # Sets the library as a shared library.</span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             # Provides a relative path to your source file(s).</span><br><span class="line">             src/main/jni/Test.c )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">find_library(log-lib log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( # Specifies the target library.</span><br><span class="line">                       Test</span><br><span class="line">                       $&#123;log-lib&#125; )</span><br></pre></td></tr></table></figure><h3 id="build-gradle"><a href="#build-gradle" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">ndk </span>&#123;</span><br><span class="line">    ldLibs <span class="string">"log"</span><span class="comment">//实现__android_log_print</span></span><br><span class="line">    abiFilters  <span class="string">"armeabi-v7a"</span> <span class="comment">//平台配置，因为在Android上，就只写了一个</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h3><p>编译完成后就如下图，产生一个libTest.so的文件，这就是我们要的。把它当做Linux最后打包成的so文件。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-caee5784088bdb17.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h1 id="导入第三方so"><a href="#导入第三方so" class="headerlink" title="导入第三方so"></a>导入第三方so</h1><p>新建一个项目JNIUseSoDemo，项目结构如下。同样是在MainActivity中定义Native方法，生成UseSo.c。将我们上一步生成的so文件拷贝到jniLibs下（armeabi-v7a是平台）。以及上一步中的头文件也拷贝到jni下。</p><p><img src="https://upload-images.jianshu.io/upload_images/3809817-120270e98dea640c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="完成C代码-1"><a href="#完成C代码-1" class="headerlink" title="完成C代码"></a>完成C代码</h3><p>我在UseSo中getString方法去调用了so库中的getString方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Test.h"</span> <span class="comment">//so库的头文件，必须要引用！</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Header for class com_david_jniusesodemo_MainActivity */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _Included_com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Class:     com_david_jniusesodemo_MainActivity</span></span><br><span class="line"><span class="comment"> * Method:    getString</span></span><br><span class="line"><span class="comment"> * Signature: ()Ljava/lang/String;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">JNIEXPORT jstring JNICALL Java_com_david_jniusesodemo_MainActivity_getString</span><br><span class="line">        (JNIEnv *env, jobject instance) &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> Java_com_david_jnisodemo_MainActivity_getString(env, instance);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __cplusplus</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>当然还没有完成。</p><h3 id="CMakeList-txt-1"><a href="#CMakeList-txt-1" class="headerlink" title="CMakeList.txt"></a>CMakeList.txt</h3><p>在CMake中将LibTest.so导入工程</p><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">cmake_minimum_required(VERSION <span class="number">3.4</span>.<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">add_library( <span class="comment"># Sets the name of the library.</span></span><br><span class="line">             UseSo</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Sets the library as a shared library.</span></span><br><span class="line">             SHARED</span><br><span class="line"></span><br><span class="line">             <span class="comment"># Provides a relative path to your source file(s).</span></span><br><span class="line">             src/main/jni/UseSo.c )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#导入第三方so包，并声明为 IMPORTED 属性，指明只是想把 so 导入到项目中</span></span><br><span class="line">add_library( Test</span><br><span class="line">             SHARED</span><br><span class="line">             IMPORTED )</span><br><span class="line">             </span><br><span class="line"><span class="comment">#指明 so 库的路径，CMAKE_SOURCE_DIR 表示 CMakeLists.txt 的路径             </span></span><br><span class="line">set_target_properties(</span><br><span class="line">             Test</span><br><span class="line">             PROPERTIES IMPORTED_LOCATION</span><br><span class="line">             $&#123;CMAKE_SOURCE_DIR&#125;/src/main/jniLibs/armeabi-v7a/libTest.so )</span><br><span class="line"></span><br><span class="line"><span class="comment">#指明头文件路径，不然会提示找不到 so 的方法</span></span><br><span class="line">include_directories(src/main/jni/)</span><br><span class="line"></span><br><span class="line">find_library(log-<span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line">              log )</span><br><span class="line"></span><br><span class="line">target_link_libraries( <span class="comment"># Specifies the target library.</span></span><br><span class="line">                       UseSo</span><br><span class="line"></span><br><span class="line">                       Test</span><br><span class="line"></span><br><span class="line">                       $&#123;log-<span class="class"><span class="keyword">lib</span>&#125; )</span></span><br></pre></td></tr></table></figure><h3 id="build-gradle-1"><a href="#build-gradle-1" class="headerlink" title="build.gradle"></a>build.gradle</h3><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">ndk</span> &#123;</span><br><span class="line">    <span class="attribute">abiFilters</span> <span class="string">'armeabi-v7a'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最终调用"><a href="#最终调用" class="headerlink" title="最终调用"></a>最终调用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        System.loadLibrary(<span class="string">"UseSo"</span>); <span class="comment">//加载SO库</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Log.e(<span class="string">"TEST"</span>,getString());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">native</span> String <span class="title">getString</span><span class="params">()</span></span>; <span class="comment">//它会调用Java_com_david_jniusesodemo_MainActivity_getString方法，然后该方法又回去调用so库中的Java_com_david_jnisodemo_MainActivity_getString方法，得到返回字符串。</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://upload-images.jianshu.io/upload_images/3809817-07915a8ceb23d42d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>验证没有问题，导入第三方so库完成。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;正在准备中的项目里，有一部分打算直接移殖Linux开发组在之前就完成的功能，他们是使用C语言开发。考虑到维护的问题，准备让他们将代码打包成so文件，再引用到我的项目中。这样也就相当于我去引用一个第三方库，并且这个库中的代码格式也不一定是我们JNI开发时规定的命名，因此，需要
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之奇偶链表</title>
    <link href="http://yoursite.com/2018/12/03/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%A5%87%E5%81%B6%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/12/03/每日一算法之奇偶链表/</id>
    <published>2018-12-03T07:02:11.000Z</published>
    <updated>2018-12-03T12:09:30.000Z</updated>
    
    <content type="html"><![CDATA[<p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><p><strong>示例 1:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">4</span>-&gt;<span class="number">5</span>-&gt;NULL</span><br><span class="line">输出: <span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">2</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">2</span>-&gt;<span class="number">1</span>-&gt;<span class="number">3</span>-&gt;<span class="number">5</span>-&gt;<span class="number">6</span>-&gt;<span class="number">4</span>-&gt;<span class="number">7</span>-&gt;NULL </span><br><span class="line">输出: <span class="number">2</span>-&gt;<span class="number">3</span>-&gt;<span class="number">6</span>-&gt;<span class="number">7</span>-&gt;<span class="number">1</span>-&gt;<span class="number">5</span>-&gt;<span class="number">4</span>-&gt;NULL</span><br></pre></td></tr></table></figure><p><strong>说明:</strong></p><ul><li>应当保持奇数节点和偶数节点的相对顺序。</li><li>链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</li></ul><p>这道题还是比较简单，下面的代码只是一种解决方法。odd节点指向奇节点，even指向偶节点，将even后的奇节点放在它的前面，然后-&gt;next往后依次，直到结束，所有的奇节点就在前面，偶节点在后，顺序没变。    </p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">oddEvenList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">odd</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">even</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(even &amp;&amp; even-&gt;next)&#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">tmp</span> = <span class="title">odd</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line">        odd-&gt;next = even-&gt;next;</span><br><span class="line">        even-&gt;next = even-&gt;next-&gt;next;</span><br><span class="line">        odd-&gt;next-&gt;next = tmp;</span><br><span class="line">        even = even-&gt;next;</span><br><span class="line">        odd = odd-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还有遍历节点，将奇偶节点分开成两个链表，最后再将偶链表连在奇链表后面也是可以的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。&lt;/p&gt;
&lt;p&gt;请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。&lt;/
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习-LOG日志</title>
    <link href="http://yoursite.com/2018/12/03/Android-JNI%E5%AD%A6%E4%B9%A0-LOG/"/>
    <id>http://yoursite.com/2018/12/03/Android-JNI学习-LOG/</id>
    <published>2018-12-03T02:43:38.000Z</published>
    <updated>2018-12-03T03:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便以后查看使用。</p><h3 id="修改build-gradle"><a href="#修改build-gradle" class="headerlink" title="修改build.gradle"></a>修改build.gradle</h3><pre><code>defaultConfig {   ndk {       ldLibs &quot;log&quot; //实现__android_log_print       moduleName &quot;demo&quot;  //设置库(so)文件名称       abiFilters  &quot;armeabi-v7a&quot;, &quot;x86&quot;   }}</code></pre><p><code>ldLibs &quot;log&quot;</code>是实现JNI Log的关键。</p><h3 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;android/log.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_TAG    <span class="meta-string">"MyDemo"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGI(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGE(...)  __android_log_print(ANDROID_LOG_ERROR, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOGD(...)  __android_log_print(ANDROID_LOG_INFO, LOG_TAG, __VA_ARGS__)</span></span><br></pre></td></tr></table></figure><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LOGE(<span class="string">"myName : %s"</span>, name); <span class="comment">// Log.e(TAG,"myName : $name")</span></span><br><span class="line">LOGD(<span class="string">"age: %d"</span>,age); <span class="comment">// Log.d(TAG,"age : $age")</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚好在准备一个有JNI开发的项目，就想着先用Demo练下手，毕竟好久没做过了。做的时候发现自己忘记了Log信息怎么打印的，就网上搜索了下，结果一堆让修改Android.mk的，这些都是以前eclipse或者旧版本AS的用法，所以在这里记录一下AS上JNI Log的使用，方便
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
  <entry>
    <title>每日一算法之判断回文联表</title>
    <link href="http://yoursite.com/2018/11/30/%E6%AF%8F%E6%97%A5%E4%B8%80%E7%AE%97%E6%B3%95%E4%B9%8B%E5%88%A4%E6%96%AD%E5%9B%9E%E6%96%87%E8%81%94%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/11/30/每日一算法之判断回文联表/</id>
    <published>2018-11-30T06:36:00.000Z</published>
    <updated>2018-11-30T07:03:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>请判断一个链表是否为回文链表。</p><p><strong>示例 1:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span></span><br><span class="line">输出: <span class="keyword">false</span></span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: <span class="number">1</span>-&gt;<span class="number">2</span>-&gt;<span class="number">2</span>-&gt;<span class="number">1</span></span><br><span class="line">输出: <span class="keyword">true</span></span><br></pre></td></tr></table></figure><p><strong>进阶：</strong><br>你能否用 O(n) 时间复杂度和 O(1) 空间复杂度解决此题？（<a href="https://leetcode-cn.com/problems/palindrome-linked-list/description/" target="_blank" rel="noopener">leetcode原题</a>）</p><p>拿到这个题的时候，看到给出的第二个示例以及要求O(1) 空间复杂度就知道要利用链表逆序思想，将链表后半部分逆序。然后从前到中和从后到中一一对比即可。</p><p>实现代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(head==<span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">bool</span> result = <span class="literal">true</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node1</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node2</span> = <span class="title">head</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">node3</span> = <span class="title">NULL</span>;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//node2每次跳两步，node1每次跳一步，当node2-&gt;next或者node2-&gt;next-&gt;next为空时</span></span><br><span class="line">    <span class="comment">//链表个数为奇数，node1就处在中间位置，</span></span><br><span class="line">    <span class="comment">//链表个数为偶数，node1和node1-&gt;next就是中间两个位置。</span></span><br><span class="line">    <span class="keyword">while</span>(node2-&gt;next!=<span class="literal">NULL</span> &amp;&amp; node2-&gt;next-&gt;next !=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node2 = node2-&gt;next-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//逆序后半段链表</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3-&gt;3-&gt;2-&gt;1</span></span><br><span class="line">    <span class="comment">//     转为</span></span><br><span class="line">    <span class="comment">// 1-&gt;2-&gt;3&lt;-3&lt;-2&lt;-1</span></span><br><span class="line">    node2 = node1-&gt;next;</span><br><span class="line">    node1-&gt; next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        node3 = node2-&gt;next;</span><br><span class="line">        node2-&gt;next = node1;</span><br><span class="line">        node1 = node2;</span><br><span class="line">        node2 = node3;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    node3 = node1;</span><br><span class="line">    node2 = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从前端和后端开始对比数字</span></span><br><span class="line">    <span class="keyword">while</span>(node2!=<span class="literal">NULL</span> &amp;&amp; node1!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(node2-&gt;val != node1-&gt;val)&#123;</span><br><span class="line">            result = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        node2 = node2-&gt;next;</span><br><span class="line">        node1 = node1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//在程序中应该把链表恢复原样，毕竟还有可能要用到这个链表，参照上面，这里就偷懒没写了</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好久没有写算法了，为了链表的逆序在纸上画了半天才理清逻辑。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;请判断一个链表是否为回文链表。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;示例 1:&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight elixir&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;
      
    
    </summary>
    
      <category term="数据结构与算法" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="http://yoursite.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Android模拟屏幕点击</title>
    <link href="http://yoursite.com/2018/11/30/Android%E6%A8%A1%E6%8B%9F%E5%B1%8F%E5%B9%95%E7%82%B9%E5%87%BB/"/>
    <id>http://yoursite.com/2018/11/30/Android模拟屏幕点击/</id>
    <published>2018-11-30T02:28:20.000Z</published>
    <updated>2018-11-30T02:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。</p><p>也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB中的”adb shell tap x y”来点击屏幕，亲测可行，并且代码很简单。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">click</span><span class="params">(x:<span class="type">Int</span>,y:<span class="type">Int</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> order = listOf(<span class="string">"input"</span>,</span><br><span class="line">                <span class="string">"tap"</span>,</span><br><span class="line">                <span class="string">""</span> + x,</span><br><span class="line">                <span class="string">""</span> + y)</span><br><span class="line">        ProcessBuilder(order).start()</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>需要传入要点击点的位置坐标，所以要提前计算好坐标，因为我的是专用的Android设备，不用考虑分辨率适配什么的，所以就这样OK了。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近在一个没有触摸屏的Android设备上做开发（无奈脸），结果过程中有一个不可避免的弹窗，没法触控就只能由程序去模拟点击事件了。&lt;/p&gt;
&lt;p&gt;也在网上找了一些方法，不是不能用就是需要Root权限什么的。最终使用ProcessBuilder来执行命令行语句，模拟使用ADB
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg代码实现抽取音频、视频数据</title>
    <link href="http://yoursite.com/2018/11/27/FFmpegd%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%8A%BD%E5%8F%96%E9%9F%B3%E9%A2%91%E3%80%81%E8%A7%86%E9%A2%91%E6%95%B0%E6%8D%AE/"/>
    <id>http://yoursite.com/2018/11/27/FFmpegd代码实现抽取音频、视频数据/</id>
    <published>2018-11-27T08:40:27.000Z</published>
    <updated>2018-11-30T02:32:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。</p><h2 id="IDE"><a href="#IDE" class="headerlink" title="IDE"></a>IDE</h2><p>应该是第一次在Mac上做C/C++开发，纠结过后选择使用CLion 开发。<a href="https://www.jetbrains.com/clion/" target="_blank" rel="noopener">CLion</a>是 JetBrains下专门用来开发C/C++的IDE，已经用习惯了Android studio和IntelliJ IDEA ，所以CLion用起来还是很顺手的。</p><p>在新建一个C项目后，需要把FFmpeg的库导入才能正常运行。我们修改项目的CMakeLists.txt文件。</p><p><img src="/2018/11/27/FFmpegd代码实现抽取音频、视频数据/extr_voice.png" alt=""></p><h2 id="抽取音频AAC数据"><a href="#抽取音频AAC数据" class="headerlink" title="抽取音频AAC数据"></a>抽取音频AAC数据</h2><p>其实我们要做的主要就是一个文件的操作，把一个文件打开，从里面拿出它的一部分数据，再把这部分数据放到另一个文件中保存。</p><h5 id="定义参数"><a href="#定义参数" class="headerlink" title="定义参数"></a>定义参数</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavutil/log.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;libavformat/avformat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//上下文</span></span><br><span class="line">AVFormatContext *fmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line">AVFormatContext *ofmt_ctx = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//支持各种各样的输出文件格式，MP4，FLV，3GP等等</span></span><br><span class="line">AVOutputFormat *output_fmt = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输入流</span></span><br><span class="line">AVStream *in_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出流</span></span><br><span class="line">AVStream *out_stream = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//存储压缩数据</span></span><br><span class="line">AVPacket packet;</span><br><span class="line"></span><br><span class="line"><span class="comment">//要拷贝的流</span></span><br><span class="line"><span class="keyword">int</span> audio_stream_index = <span class="number">-1</span>;</span><br></pre></td></tr></table></figure><h3 id="1-打开输入文件，提取参数"><a href="#1-打开输入文件，提取参数" class="headerlink" title="1.打开输入文件，提取参数"></a>1.打开输入文件，提取参数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//打开输入文件，关于输入文件的所有就保存到fmt_ctx中了</span></span><br><span class="line">err_code = avformat_open_input(&amp;fmt_ctx, src_fileName, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (err_code &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"cant open file:%s\n"</span>, av_err2str(err_code));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(fmt_ctx-&gt;nb_streams&lt;<span class="number">2</span>)&#123;</span><br><span class="line">      <span class="comment">//流数小于2，说明这个文件音频、视频流这两条都不能保证，输入文件有错误 </span></span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_ERROR, <span class="string">"输入文件错误，流不足2条\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//拿到文件中音频流</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"> <span class="comment">//参数信息</span></span><br><span class="line"> AVCodecParameters *in_codecpar = in_stream-&gt;codecpar;</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的音频流</span></span><br><span class="line">audio_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_AUDIO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(audio_stream_index &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"寻找最好音频流失败，请检查输入文件！\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> AVERROR(EINVAL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-准备输出文件，输出流"><a href="#2-准备输出文件，输出流" class="headerlink" title="2.准备输出文件，输出流"></a>2.准备输出文件，输出流</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 输出上下文</span></span><br><span class="line">ofmt_ctx = avformat_alloc_context();</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据目标文件名生成最适合的输出容器</span></span><br><span class="line">output_fmt = av_guess_format(<span class="literal">NULL</span>,dst_fileName,<span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span>(!output_fmt)&#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"根据目标生成输出容器失败！\n"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ofmt_ctx-&gt;oformat = output_fmt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新建输出流</span></span><br><span class="line"> out_stream = avformat_new_stream(ofmt_ctx, <span class="literal">NULL</span>);</span><br><span class="line"> <span class="keyword">if</span>(!out_stream)&#123;</span><br><span class="line">      av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"创建输出流失败！\n"</span>);</span><br><span class="line">      <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="3-数据拷贝"><a href="#3-数据拷贝" class="headerlink" title="3. 数据拷贝"></a>3. 数据拷贝</h3><h4 id="3-1-参数信息"><a href="#3-1-参数信息" class="headerlink" title="3.1 参数信息"></a>3.1 参数信息</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将参数信息拷贝到输出流中，我们只是抽取音频流，并不做音频处理，所以这里只是Copy</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avcodec_parameters_copy(out_stream-&gt;codecpar, in_codecpar)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">    av_strerror(err_code, errors, ERROR_STR_SIZE);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_ERROR,<span class="string">"拷贝编码参数失败！, %d(%s)\n"</span>,</span><br><span class="line">           err_code, errors);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-2-初始化AVIOContext"><a href="#3-2-初始化AVIOContext" class="headerlink" title="3.2 初始化AVIOContext"></a>3.2 初始化AVIOContext</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化AVIOContext,文件操作由它完成</span></span><br><span class="line"><span class="keyword">if</span>((err_code = avio_open(&amp;ofmt_ctx-&gt;pb, dst_fileName, AVIO_FLAG_WRITE)) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_strerror(err_code, errors, <span class="number">1024</span>);</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Could not open file %s, %d(%s)\n"</span>,</span><br><span class="line">           dst_fileName,</span><br><span class="line">           err_code,</span><br><span class="line">           errors);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-3-开始拷贝"><a href="#3-3-开始拷贝" class="headerlink" title="3.3 开始拷贝"></a>3.3 开始拷贝</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//初始化 AVPacket， 我们从文件中读出的数据会暂存在其中</span></span><br><span class="line">av_init_packet(&amp;packet);</span><br><span class="line">packet.data = <span class="literal">NULL</span>;</span><br><span class="line">packet.size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写头部信息</span></span><br><span class="line"><span class="keyword">if</span> (avformat_write_header(ofmt_ctx, <span class="literal">NULL</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">    av_log(<span class="literal">NULL</span>, AV_LOG_DEBUG, <span class="string">"Error occurred when opening output file"</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//每读出一帧数据</span></span><br><span class="line"><span class="keyword">while</span>(av_read_frame(fmt_ctx, &amp;packet) &gt;=<span class="number">0</span> )&#123;</span><br><span class="line">    <span class="keyword">if</span>(packet.stream_index == audio_stream_index)&#123;</span><br><span class="line">        <span class="comment">//时间基计算，音频pts和dts一致</span></span><br><span class="line">        packet.pts = av_rescale_q_rnd(packet.pts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br><span class="line">        packet.dts = packet.pts;</span><br><span class="line">        packet.duration = av_rescale_q(packet.duration, in_stream-&gt;time_base, out_stream-&gt;time_base);</span><br><span class="line">        packet.pos = <span class="number">-1</span>;</span><br><span class="line">        packet.stream_index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//将包写到输出媒体文件</span></span><br><span class="line">        av_interleaved_write_frame(ofmt_ctx, &amp;packet);</span><br><span class="line">        <span class="comment">//减少引用计数，避免内存泄漏</span></span><br><span class="line">        av_packet_unref(&amp;packet);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//写尾部信息</span></span><br><span class="line">av_write_trailer(ofmt_ctx);</span><br><span class="line"></span><br><span class="line"><span class="comment">//最后别忘了释放内存</span></span><br><span class="line">avformat_close_input(&amp;fmt_ctx);</span><br><span class="line">avio_close(ofmt_ctx-&gt;pb);</span><br></pre></td></tr></table></figure><h3 id="执行"><a href="#执行" class="headerlink" title="执行"></a>执行</h3><p><code>./MyC /Users/david/Desktop/1080p.mov /Users/david/Desktop/test.aac</code></p><h2 id="抽取视频数据"><a href="#抽取视频数据" class="headerlink" title="抽取视频数据"></a>抽取视频数据</h2><p>抽取视频信息并保存在文件中的流程甚至代码和上面抽取音频基本一致。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//拿到文件中音频流 或者 视频流，所有流都在streams数组中</span></span><br><span class="line"> in_stream = fmt_ctx-&gt;streams[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">//找到最好的视频流</span></span><br><span class="line">video_stream_index = av_find_best_stream(fmt_ctx, AVMEDIA_TYPE_VIDEO, <span class="number">-1</span>, <span class="number">-1</span>, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">packet.dts = av_rescale_q_rnd(packet.dts, in_stream-&gt;time_base, out_stream-&gt;time_base, (AV_ROUND_NEAR_INF|AV_ROUND_PASS_MINMAX));</span><br></pre></td></tr></table></figure><p>基本上就是一些参数的改变，所有流程和代码保持不变，就可以把一个音视频文件中的视频数据抽取出来了，mp4、H264等格式随便，就是这么简单。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天开始撸代码，首先使用FFmpeg的API抽取一个MP4文件的音频数据。&lt;/p&gt;
&lt;h2 id=&quot;IDE&quot;&gt;&lt;a href=&quot;#IDE&quot; class=&quot;headerlink&quot; title=&quot;IDE&quot;&gt;&lt;/a&gt;IDE&lt;/h2&gt;&lt;p&gt;应该是第一次在Mac上做C/C++开发，纠
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用结构体、方法简介</title>
    <link href="http://yoursite.com/2018/11/23/FFmpeg%E5%B8%B8%E7%94%A8%E7%BB%93%E6%9E%84%E4%BD%93%E3%80%81%E6%96%B9%E6%B3%95%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2018/11/23/FFmpeg常用结构体、方法简介/</id>
    <published>2018-11-23T11:58:59.000Z</published>
    <updated>2018-11-28T10:00:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。</p><h2 id="常用结构体"><a href="#常用结构体" class="headerlink" title="常用结构体"></a>常用结构体</h2><h3 id="AVFormatContext"><a href="#AVFormatContext" class="headerlink" title="AVFormatContext"></a>AVFormatContext</h3><p>AVFormatContext是音视频数据,也就是音视频文件的一种抽象和封装，该结构体中包含了多路流，包括音频流、视频流、字幕流等，是FFmpeg中一个贯穿全局的数据结构，很多函数都要以它为参数。 </p><p>结构体定义如下（主要参数）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">AVFormatContext</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVInputFormat</span> *<span class="title">iformat</span>;</span> <span class="comment">//输入容器格式,用于分流,通过avformat_open_input()设置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">AVOutputFormat</span> *<span class="title">oformat</span>;</span> <span class="comment">//输出容器格式,用于混流,必须在avformat_write_header()调用前设置</span></span><br><span class="line">    AVIOContext *pb;  <span class="comment">// I/O 上下文</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> nb_streams; <span class="comment">// 流的总数</span></span><br><span class="line">    AVStream **streams; <span class="comment">//所有流的列表,由avformat_new_stream()创建新的流</span></span><br><span class="line">    <span class="keyword">int64_t</span> duration; <span class="comment">//流的时长</span></span><br><span class="line">    <span class="keyword">int64_t</span> bit_rate; <span class="comment">//流的比特率</span></span><br><span class="line">    <span class="keyword">int64_t</span> probesize; <span class="comment">//从指定容器格式的输入中读取最大数据的大小,要足够起播首帧画面</span></span><br><span class="line">    <span class="keyword">int64_t</span> max_analyze_duration; <span class="comment">//从指定容器格式的输入中读取的最大数据时长</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID video_codec_id; <span class="comment">// 视频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID audio_codec_id; <span class="comment">// 音频的codec_id</span></span><br><span class="line">    <span class="keyword">enum</span> AVCodecID subtitle_codec_id; <span class="comment">// 字幕的codec_id</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_index_size; <span class="comment">// 每条流的最大内存字节数</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> max_picture_buffer; <span class="comment">//从设备获取的实时帧缓冲的最大内存大小</span></span><br><span class="line">    AVDictionary *metadata; <span class="comment">// 整个文件的元数据</span></span><br><span class="line">    。。。 实在太多了，以后再慢慢了解吧</span><br><span class="line">&#125;AVFormatContext;</span><br></pre></td></tr></table></figure><h3 id="AVInputFormat"><a href="#AVInputFormat" class="headerlink" title="AVInputFormat"></a>AVInputFormat</h3><p>FFmpeg的解复用器对象，是类似COM接口的数据结构，表示输入文件容器格式，一个文件容器格式对应一个AVInputFormat结构，在程序运行时有多个实例。</p><h3 id="AVStream"><a href="#AVStream" class="headerlink" title="AVStream"></a>AVStream</h3><p>是存储每一个视频/音频流信息的结构体，位于avoformat.h文件中。使用解复用器从容器中解析出不同的流，在FFmpeg中流的对象就是AVStream，保存在AVFormatContext的streams数组中。</p><h3 id="AVCodecContext"><a href="#AVCodecContext" class="headerlink" title="AVCodecContext"></a>AVCodecContext</h3><p>描述编解码器上下文的数据结构，包含众多编解码器需要的参数信息。</p><h3 id="AVPacket"><a href="#AVPacket" class="headerlink" title="AVPacket"></a>AVPacket</h3><p>FFmpeg使用AVPacket来存放编码后的视频帧数据，AVPacket保存了解复用之后、解码之前的数据（仍然是压缩后的数据）和关于这些数据的一些附加信息。AVPacket实际上可用做一个容器，它本身不包含压缩的媒体数据，而是通过data指针引用数据的缓存空间。</p><h3 id="AVCodec"><a href="#AVCodec" class="headerlink" title="AVCodec"></a>AVCodec</h3><p>存储编解码器信息的结构体。</p><h3 id="AVFrame"><a href="#AVFrame" class="headerlink" title="AVFrame"></a>AVFrame</h3><p>用来描述解码出的音视频数据，必须使用av_frame_alloc分配，av_frame_free释放。</p><h3 id="AVIOContext"><a href="#AVIOContext" class="headerlink" title="AVIOContext"></a>AVIOContext</h3><p>文件操作的顶层结构，实现了带缓冲的读写操作。</p><h3 id="URLProtocol"><a href="#URLProtocol" class="headerlink" title="URLProtocol"></a>URLProtocol</h3><p>是FFmpeg操作文件的结构，包括open、close、read、write、seek等操作。</p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><h3 id="av-register-all"><a href="#av-register-all" class="headerlink" title="av_register_all"></a>av_register_all</h3><p>初始化所有组件，只有调用了该函数，才能使用复用器和编解码器(FFmpeg4.0以上被废弃，不推荐使用，可以不调用)。</p><h3 id="avformat-alloc-context"><a href="#avformat-alloc-context" class="headerlink" title="avformat_alloc_context"></a>avformat_alloc_context</h3><p>AVFormatContext要用avformat_alloc_context()进行初始化，分配内存空间。</p><h3 id="avformat-open-input"><a href="#avformat-open-input" class="headerlink" title="avformat_open_input"></a>avformat_open_input</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avformat_open_input</span><span class="params">(AVFormatContext **ps, <span class="keyword">const</span> <span class="keyword">char</span> *url, AVInputFormat *fmt, AVDictionary **options)</span></span>;</span><br></pre></td></tr></table></figure><p>主要功能是打开一个文件，读取header，不会涉及打开解码器，与之对应的是avformat_close_input函数关闭文件。如果打开文件成功，AVFormatContext  ps就会在函数中初始化完成。</p><h3 id="av-guess-format"><a href="#av-guess-format" class="headerlink" title="av_guess_format"></a>av_guess_format</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVOutputFormat *<span class="title">av_guess_format</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *short_name,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *filename,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">const</span> <span class="keyword">char</span> *mime_type)</span></span>;</span><br></pre></td></tr></table></figure><p>从所编译的ffmpeg库支持的muxer中查找与文件名有关联的容器类型。</p><h3 id="avformat-new-stream"><a href="#avformat-new-stream" class="headerlink" title="avformat_new_stream"></a>avformat_new_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">AVStream *<span class="title">avformat_new_stream</span><span class="params">(AVFormatContext *s, <span class="keyword">const</span> AVCodec *c)</span></span>;</span><br></pre></td></tr></table></figure><p>在 AVFormatContext 中创建新的 Stream 流通道。</p><h3 id="avio-open"><a href="#avio-open" class="headerlink" title="avio_open"></a>avio_open</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">avio_open</span><span class="params">(AVIOContext **s, <span class="keyword">const</span> <span class="keyword">char</span> *url, <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>用于打开FFmpeg的输入/输出文件。</p><h3 id="av-find-best-stream"><a href="#av-find-best-stream" class="headerlink" title="av_find_best_stream"></a>av_find_best_stream</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_find_best_stream</span><span class="params">(AVFormatContext *ic,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">enum</span> AVMediaType type,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> wanted_stream_nb,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> related_stream,</span></span></span><br><span class="line"><span class="function"><span class="params">                        AVCodec **decoder_ret,</span></span></span><br><span class="line"><span class="function"><span class="params">                        <span class="keyword">int</span> flags)</span></span>;</span><br></pre></td></tr></table></figure><p>在文件中找到“最好”的用户所期望的流</p><h3 id="av-read-frame"><a href="#av-read-frame" class="headerlink" title="av_read_frame"></a>av_read_frame</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">av_read_frame</span><span class="params">(AVFormatContext *s, AVPacket *pkt)</span></span>;</span><br></pre></td></tr></table></figure><p>读取码流中的若干音频帧或者1帧视频。</p><h3 id="av-rescale-q"><a href="#av-rescale-q" class="headerlink" title="av_rescale_q"></a>av_rescale_q</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int64_t</span> av_rescale_q(<span class="keyword">int64_t</span> a, AVRational bq, AVRational cq)</span><br></pre></td></tr></table></figure><p>这个函数的作用是计算a * bq / cq，来把时间戳从一个时基调整到另外一个时基。</p><h3 id="av-write-frame"><a href="#av-write-frame" class="headerlink" title="av_write_frame"></a>av_write_frame</h3><p>FFmpeg调用<code>avformat_write_header</code>函数写头部信息，<code>av_write_frame</code>函数写1帧数据，调用<code>av_write_trailer</code>写尾部信息。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天先来了解下FFmpeg中我们常用的结构体和方法，防止我们在后面看代码、写代码的时候一脸懵逼。&lt;/p&gt;
&lt;h2 id=&quot;常用结构体&quot;&gt;&lt;a href=&quot;#常用结构体&quot; class=&quot;headerlink&quot; title=&quot;常用结构体&quot;&gt;&lt;/a&gt;常用结构体&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg实现简单直播系统</title>
    <link href="http://yoursite.com/2018/11/23/FFmpeg%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9B%B4%E6%92%AD%E7%B3%BB%E7%BB%9F/"/>
    <id>http://yoursite.com/2018/11/23/FFmpeg实现简单直播系统/</id>
    <published>2018-11-23T01:48:29.000Z</published>
    <updated>2018-11-23T02:43:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>现在市面上的各种直播应用越来越多，直播相关技术也成为最火热的技术方向之一，所以今天就用FFpmeg来实现一个简单的直播系统。</p><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><p>FFmpeg之前也看到它有直播推流和直播拉流的命令，那这个流推到哪里?又要从哪里拉?这个时候就需要我们的关键角色–<strong>流媒体服务器</strong>。</p><p>我使用Nginx服务，并配置好RTMP服务。</p><p><code>brew install nginx-full --with-rtmp-module</code></p><p>等安装完成后修改配置文件</p><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vi <span class="meta-keyword">/usr/</span>local<span class="meta-keyword">/etc/</span>nginx/nginx.conf</span><br><span class="line"></span><br><span class="line">添加如下:</span><br><span class="line"></span><br><span class="line"><span class="class">rtmp </span>&#123;</span><br><span class="line">      server&#123;</span><br><span class="line"></span><br><span class="line">            listen <span class="number">1935</span>; <span class="comment">//端口号</span></span><br><span class="line">            chunk_size <span class="number">4000</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//指定流应用</span></span><br><span class="line">            application live</span><br><span class="line">           &#123;</span><br><span class="line">                 live on;</span><br><span class="line">                 record off;</span><br><span class="line">                 allow play all;</span><br><span class="line">           &#125;</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后重启服务</p><p><code>nginx -s reload</code></p><h2 id="直播"><a href="#直播" class="headerlink" title="直播"></a>直播</h2><p>环境Ok了，接下来就可以试一下推流拉流直播了。</p><p>首先可以推一个视频</p><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://127.0.0.1:1935/live/room</code></p><p>使用FFplay播放</p><p><code>ffplay rtmp://localhost:1935/live/room</code></p><p><img src="/2018/11/23/FFmpeg实现简单直播系统/ffmpeglive.png" alt=""></p><p>图片左侧是推流，右侧ffplay拉流，中间为ffplay播放的视频。</p><p>然后可以试着直播下我的桌面:</p><p><code>ffmpeg -f avfoundation -i &quot;1&quot; -vcodec libx264 -preset ultrafast -acodec libfaac -f flv rtmp://127.0.0.1:1935/live/room</code></p><p>都是同样的原理，很简单，赶紧去试一下吧!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;现在市面上的各种直播应用越来越多，直播相关技术也成为最火热的技术方向之一，所以今天就用FFpmeg来实现一个简单的直播系统。&lt;/p&gt;
&lt;h2 id=&quot;环境搭建&quot;&gt;&lt;a href=&quot;#环境搭建&quot; class=&quot;headerlink&quot; title=&quot;环境搭建&quot;&gt;&lt;/a&gt;环境搭建
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg常用命令</title>
    <link href="http://yoursite.com/2018/11/22/FFmpeg%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <id>http://yoursite.com/2018/11/22/FFmpeg常用命令/</id>
    <published>2018-11-22T05:43:30.000Z</published>
    <updated>2018-11-29T08:32:50.000Z</updated>
    
    <content type="html"><![CDATA[<p>FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。本文将简单介绍FFmpeg库的基本目录结构及其功能，然后会介绍一些常用的FFmpeg命令，了解FFmpeg到底能做些什么。</p><h3 id="音视频基本处理流程"><a href="#音视频基本处理流程" class="headerlink" title="音视频基本处理流程"></a>音视频基本处理流程</h3><p>对于音视频的处理基本遵循下面的流程：</p><p><img src="/2018/11/22/FFmpeg常用命令/ffmpeg23.png" alt=""></p><h3 id="FFmpeg目录及功能"><a href="#FFmpeg目录及功能" class="headerlink" title="FFmpeg目录及功能"></a>FFmpeg目录及功能</h3><table><thead><tr><th>libavcodec</th><th>提供了一系列编解码器的实现</th></tr></thead><tbody><tr><td>libavcodec</td><td>用于各种音视频封装格式的生成和解析，包括获取解码所需信息以生成解码上下文结构和读取音视频帧等功能</td></tr><tr><td>libavutil</td><td>包含一些公共的工具函数</td></tr><tr><td>libavutil</td><td>提供了各种音视频过滤器</td></tr><tr><td>libavdevice</td><td>提供了各种音视频过滤器</td></tr><tr><td>libswscale</td><td>提供了视频场景比例缩放、色彩映射转换功能</td></tr><tr><td>libswresample</td><td>实现了混音和重采样</td></tr></tbody></table><h3 id="信息查询命令"><a href="#信息查询命令" class="headerlink" title="信息查询命令"></a>信息查询命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>FFmpeg -version</td><td>显示版本</td></tr><tr><td>-formats</td><td>显示可用的格式（包括设备）</td></tr><tr><td>-demuxers</td><td>显示可用的demuxers</td></tr><tr><td>-muxers</td><td>显示可用的muxers</td></tr><tr><td>-devices</td><td>显示可用的设备</td></tr><tr><td>-codecs</td><td>显示已知的所有编解码器</td></tr><tr><td>-decoders</td><td>显示可用的解码器</td></tr><tr><td>-encoders</td><td>显示所有可用的编码器</td></tr><tr><td>-bsfs</td><td>显示可用的比特流filter</td></tr><tr><td>-protocols</td><td>显示可用的协议</td></tr><tr><td>-filters</td><td>显示可用的过滤器</td></tr><tr><td>-pix_fmts</td><td>显示可用的像素格式</td></tr><tr><td>-sample_fmts</td><td>显示可用的采样格式</td></tr><tr><td>-layouts</td><td>显示channel名称和标准channel布局</td></tr><tr><td>-colors</td><td>显示识别的颜色名称</td></tr></tbody></table><h2 id="设备列表"><a href="#设备列表" class="headerlink" title="设备列表"></a>设备列表</h2><p><code>ffmpeg -f avfoundation -list_devices true -i “”</code></p><p>查看Mac上支持的设备列表</p><h2 id="录屏"><a href="#录屏" class="headerlink" title="录屏"></a>录屏</h2><p><code>ffmpeg -f avfoundation -i 1 -r 30 out.yuv</code></p><p>-f 指定使用 avfoundation 采集数据。<br>-i 指定从哪儿采集数据，它是一个文件索引号。<br>-r 指定帧率。</p><h2 id="录屏-声音"><a href="#录屏-声音" class="headerlink" title="录屏+声音"></a>录屏+声音</h2><p><code>ffmpeg -f avfoundation -i 1:0 -r 29.97 -c:v libx264 -crf 0 -c:a libfdk_aac -profile:a aac_he_v2 -b:a 32k out.flv</code></p><p>-i 1:0 冒号前面的 “1” 代表的屏幕索引号。冒号后面的”0”代表的声音索相号。<br>-c:v 与参数 -vcodec 一样，表示视频编码器。c 是 codec 的缩写，v 是video的缩写。<br>-crf 是 x264 的参数。 0 表式无损压缩。<br>-c:a 与参数 -acodec 一样，表示音频编码器。<br>-profile 是 fdk_aac 的参数。 aac_he_v2 表式使用 AAC_HE v2 压缩数据。<br>-b:a 指定音频码率。 b 是 bitrate的缩写, a是 audio的缩与。</p><h2 id="抽取音频和视频"><a href="#抽取音频和视频" class="headerlink" title="抽取音频和视频"></a>抽取音频和视频</h2><p><code>ffmpeg -i input_file -vcodec copy -an output_file_video　　//分离视频流</code></p><p><code>ffmpeg -i input_file -acodec copy -vn output_file_audio　　//分离音频流</code></p><p>vcodec: 指定视频编码器，copy 指明只拷贝，不做编解码。</p><p>an: a 代表视频，n 代表 no 也就是无音频的意思。</p><p>acodec: 指定音频编码器，copy 指明只拷贝，不做编解码。</p><p>vn: v 代表视频，n 代表 no 也就是无视频的意思。</p><h2 id="转格式"><a href="#转格式" class="headerlink" title="转格式"></a>转格式</h2><p><code>ffmpeg -i test.mp4 -vcodec copy -acodec copy test.flv</code></p><p>音频、视频都直接 copy，只是将 mp4 的封装格式转成了flv</p><h2 id="音视频合并"><a href="#音视频合并" class="headerlink" title="音视频合并"></a>音视频合并</h2><p><code>ffmpeg -i out.h264 -i out.aac -vcodec copy -acodec copy out.mp4</code></p><p>视频和音频直接拷贝，合成一个mp4格式文件</p><h2 id="YUV转H264"><a href="#YUV转H264" class="headerlink" title="YUV转H264"></a>YUV转H264</h2><p><code>ffmpeg -f rawvideo -pix_fmt yuv420p -s 320x240 -r 30 -i out.yuv -c:v libx264 -f rawvideo out.h264</code></p><h2 id="合并"><a href="#合并" class="headerlink" title="合并"></a>合并</h2><p>首先创建一个 inputs.txt 文件，文件内容如下：<br>file ‘1.flv’<br>file ‘2.flv’<br>file ‘3.flv’<br>然后执行下面的命令：<br><code>ffmpeg -f concat -i inputs.txt -c copy output.flv</code></p><h2 id="视频剪切"><a href="#视频剪切" class="headerlink" title="视频剪切"></a>视频剪切</h2><p><code>ffmpeg -ss 0:1:30 -t 0:0:20 -i input.avi -vcodec copy -acodec copy output.avi //剪切视频</code><br>-ss 开始时间<br>-t 持续时间</p><h2 id="视频缩小一倍"><a href="#视频缩小一倍" class="headerlink" title="视频缩小一倍"></a>视频缩小一倍</h2><p><code>ffmpeg -i out.mp4 -vf scale=iw/2:-1 scale.mp4</code><br>-vf scale 指定使用简单过滤器 scale，iw/2:-1 中的 iw 指定按整型取视频的宽度。 -1 表示高度随宽度一起变化。</p><h2 id="视频图片互转"><a href="#视频图片互转" class="headerlink" title="视频图片互转"></a>视频图片互转</h2><p><code>ffmpeg -i test.flv -r 1 -f image2 image-%3d.jpeg  //视频转JPEG</code><br><code>ffmpeg -i out.mp4 -ss 00:00:00 -t 10 out.gif  //视频转gif</code><br><code>ffmpeg -f image2 -i image-%3d.jpeg images.mp4 //图片转视频</code></p><h2 id="添加水印"><a href="#添加水印" class="headerlink" title="添加水印"></a>添加水印</h2><p><code>ffmpeg -i out.mp4 -vf “movie=logo.png,scale=64:48[watermask];[in][watermask] overlay=30:10 [out]” water.mp4</code></p><p>-vf中的 movie 指定logo位置。scale 指定 logo 大小。overlay 指定 logo 摆放的位置</p><h2 id="直播推流"><a href="#直播推流" class="headerlink" title="直播推流"></a>直播推流</h2><p><code>ffmpeg -re -i out.mp4 -c copy -f flv rtmp://server/live/streamName</code></p><h2 id="直播拉流保存"><a href="#直播拉流保存" class="headerlink" title="直播拉流保存"></a>直播拉流保存</h2><p><code>ffmpeg -i rtmp://server/live/streamName -c copy dump.flv</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FFmpeg 是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。本文将简单介绍FFmpeg库的基本目录结构及其功能，然后会介绍一些常用的FFmpeg命令，了解FFmpeg到底能做些什么。&lt;/p&gt;
&lt;h3 id=&quot;音视频基本处理流程&quot;&gt;&lt;a href=
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>FFmpeg的下载,编译和安装</title>
    <link href="http://yoursite.com/2018/11/21/Mac%E4%B8%8BFFmpeg%E7%9A%84%E4%B8%8B%E8%BD%BD-%E7%BC%96%E8%AF%91%E5%92%8C%E5%AE%89%E8%A3%85/"/>
    <id>http://yoursite.com/2018/11/21/Mac下FFmpeg的下载-编译和安装/</id>
    <published>2018-11-21T03:52:21.000Z</published>
    <updated>2018-11-21T04:12:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>FFmpeg的下载,编译和安装，本文所有操作均在Mac系统下完成。</p><figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">git clone https:<span class="string">//git.ffmpeg.org/ffmpeg.git</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">cd</span> ffmpeg</span><br><span class="line"></span><br><span class="line">make &amp;&amp; make install </span><br><span class="line"></span><br><span class="line"><span class="string">./configure</span> <span class="params">--cc=/usr/bin/clang</span> <span class="params">--prefix=/usr/local/ffmpeg</span> <span class="params">--enable-gpl</span> <span class="params">--enable-nonfree</span> <span class="params">--enable-libfdk-aac</span> <span class="params">--enable-libx264</span> <span class="params">--enable-libmp3lame</span> <span class="params">--enable-libx265</span>  <span class="params">--enable-filter=delogo</span> <span class="params">--enable-debug</span> <span class="params">--disable-optimizations</span> <span class="params">--enable-libspeex</span> <span class="params">--enable-videotoolbox</span> <span class="params">--enable-shared</span> <span class="params">--enable-pthreads</span> <span class="params">--enable-version3</span> <span class="params">--enable-hardcoded-tables</span> <span class="params">--host-cflags=</span> <span class="params">--host-ldflags=</span></span><br></pre></td></tr></table></figure><p>上面的指令执行结束后在<code>/usr/local/ffmpeg</code>目录下就会生成编译好的FFmpeg库。</p><p><img src="/2018/11/21/Mac下FFmpeg的下载-编译和安装/ffmpegInstall.png" alt=""></p><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">补充缺少的库</span><br><span class="line">brew <span class="keyword">install</span> speex</span><br><span class="line">brew <span class="keyword">install</span> x264</span><br><span class="line">brew <span class="keyword">install</span> x265</span><br><span class="line">sudo make &amp;&amp; make <span class="keyword">install</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">可能会出现/usr/<span class="keyword">local</span>/ffmpeg没有权限，可以自己新建一个并修改所有者</span><br><span class="line"></span><br><span class="line">sudo mkdir /usr/<span class="keyword">local</span>/ffmpeg</span><br><span class="line">sudo chown -R ***: ./ffmpeg</span><br></pre></td></tr></table></figure><p>OK！Mac下就是这么简单，然后就可以去玩一下FFmpeg的指令了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;FFmpeg的下载,编译和安装，本文所有操作均在Mac系统下完成。&lt;/p&gt;
&lt;figure class=&quot;highlight jboss-cli&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="FFmpeg" scheme="http://yoursite.com/tags/FFmpeg/"/>
    
  </entry>
  
  <entry>
    <title>音视频基础概念</title>
    <link href="http://yoursite.com/2018/11/19/%E9%9F%B3%E8%A7%86%E9%A2%91%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/11/19/音视频基础概念/</id>
    <published>2018-11-19T11:55:56.000Z</published>
    <updated>2018-11-21T03:36:54.000Z</updated>
    
    <content type="html"><![CDATA[<p>Android开发工作两年，真的是感觉Android应用层开发没什么前景了，于是打算在网络安全，智能硬件，音视频这几个方向发展，考虑了一段时间，最终决定选择音视频。理由就不说了，既然选择了就要好好学习了，今天就开始音视频的第一篇博客，从一些音视频的基础知识开始。</p><h4 id="硬解和软解"><a href="#硬解和软解" class="headerlink" title="硬解和软解"></a>硬解和软解</h4><p>视频解码分为硬解和软解，所谓“软解”就是通过软件让 CPU 进行视频解码处理；而“硬解”是指不依赖于 CPU，通过专用的设备（子卡）单独完成视频解码，比如曾经的 VCD/DVD 解压卡、视频压缩卡都被冠以“硬解”的称号。现在实现高清硬解不需要额外的子卡，也不需要额外的投入，因为硬解码模块被整合在了 GPU 内部，而目前主流的显卡（包括整合显卡）都能支持硬解码。</p><p> “硬解”其实更需要软件的支持，只是基本不需要 CPU 参与运算，从而为系统节约了很多资源开销。</p><h4 id="RGB-和-YUV"><a href="#RGB-和-YUV" class="headerlink" title="RGB 和 YUV"></a>RGB 和 YUV</h4><p>RGB 指的是红绿蓝，应用还是很广泛的，比如显示器显示， bmp 文件格式中的像素值等；而 yuv 主要指亮度和两个色差信号，被称为 luminance 和 chrominance 他们的转化关系可以自己去查一下，我们视频里面基本上都是用yuv格式。</p><p>YUV文件格式又分很多种，如果算上存储格式，就更多了，比如 yuv444、 yuv422、 yuv411、 yuv420 等等，视频压缩用到的是 420 格式，这是 因为人眼对亮度更敏感些，对色度相对要差些。</p><h4 id="帧-Frame"><a href="#帧-Frame" class="headerlink" title="帧 Frame"></a>帧 Frame</h4><p>简单的理解帧就是为视频或者动画中的每一张画面，而视频和动画特效就是由无数张画面组合而成，每一张画面都是一帧。</p><h4 id="帧数-Frames"><a href="#帧数-Frames" class="headerlink" title="帧数 Frames"></a>帧数 Frames</h4><p>帧数其实就是为帧生成数量的简称，可以解释为静止画面的数量</p><h4 id="帧率-Frame-Rate"><a href="#帧率-Frame-Rate" class="headerlink" title="帧率 Frame Rate"></a>帧率 Frame Rate</h4><p>帧率(Frame rate) = 帧数(Frames)/时间(Time)，单位为帧每秒(f/s, frames per second, fps)</p><p>帧率是用于测量显示帧数的量度，测量单位为“每秒显示帧数”（ Frame per Second， FPS）或“赫兹”（ Hz），一般来说 FPS 用于描述视频、电子绘图或游戏每秒播放多少幀。</p><h4 id="FPS（-Frame-per-Second）每秒显示帧数"><a href="#FPS（-Frame-per-Second）每秒显示帧数" class="headerlink" title="FPS（ Frame per Second）每秒显示帧数"></a>FPS（ Frame per Second）每秒显示帧数</h4><p>FPS 是图像领域中的定义，是指画面每秒传输帧数，通俗来讲就是指动画或视频的画面数。 FPS 是测量用于保存、显示动态视频的信息数量。每秒钟帧数愈多，所显示的动作就会愈流畅。</p><p><img src="/2018/11/19/音视频基础概念/FPS-Demo.gif" alt=""></p><h4 id="分辨率"><a href="#分辨率" class="headerlink" title="分辨率"></a>分辨率</h4><p>指视频成像产品所形成的图像大小或尺寸</p><h4 id="刷新率"><a href="#刷新率" class="headerlink" title="刷新率"></a>刷新率</h4><p>屏幕每秒画面被刷新的次数，分为垂直刷新率和水平刷新率，一般我们提到的都是指垂直刷新率，以赫兹(Hz)为单位，刷新率越高，图像就越稳定，图像显示就越自然清晰。</p><h4 id="编码格式"><a href="#编码格式" class="headerlink" title="编码格式"></a>编码格式</h4><p>编码的目的是压缩数据量，采用编码算法压缩冗余数据。常用的编码格式有:</p><ul><li>MPEG(MPEG-2  MPEG-4)</li><li>H.26X(H.263  H.264/AVC H.265/HEVC)<h4 id="码率"><a href="#码率" class="headerlink" title="码率"></a>码率</h4></li></ul><p>也就是比特率，比特率是单位时间播放连续的媒体(如压缩的音频和视频)的比特数量。比特率越高，带宽消耗得越多。</p><h4 id="视频帧"><a href="#视频帧" class="headerlink" title="视频帧"></a>视频帧</h4><p>常见的视频帧有I、P、B帧。</p><ul><li>I帧关键帧，采用帧内压缩技术</li><li>P帧向前参考帧，表示这一帧与上一帧的差别，属于帧间压缩技术</li><li>B帧表示双向参考帧，压缩时既参考前一帧也参考后一帧，帧间压缩技术</li></ul><p>一个 I 帧可以不依赖其他帧就解码出一幅完整的图像，而 P 帧、B 帧不行。P 帧需要依赖视频流中排在它前面的帧才能解码出图像。B 帧则需要依赖视频流中排在它前面或后面的帧才能解码出图像。</p><h4 id="GOP"><a href="#GOP" class="headerlink" title="GOP"></a>GOP</h4><p>GOP即Group of picture（图像组），指两个I帧之间的距离，Reference（参考周期）指两个P帧之间的距离。一个I帧所占用的字节数大于一个P帧，一个P帧所占用的字节数大于一个B帧。所以在码率不变的前提下，GOP值越大，P、B帧的数量会越多，平均每个I、P、B帧所占用的字节数就越多，也就更容易获取较好的图像质量；Reference越大，B帧的数量越多，同理也更容易获得较好的图像质量。</p><p><img src="/2018/11/19/音视频基础概念/gop.png" alt=""></p><h4 id="DTS和PTS"><a href="#DTS和PTS" class="headerlink" title="DTS和PTS"></a>DTS和PTS</h4><ul><li>DTS: Decode Time Stamp,主要用于标示读入内存的比特流在什么时候开始送入解码器中进行解码。</li><li>PTS: Presentation Time Stamp,主要用于度量解码后的视频帧什么时候被显示出来。</li></ul><p>由于B帧需要前后的帧才能解出图像，所以可能一个视频中帧的显示顺序是I B B P，但我们在解码B帧时需要P帧的信息，所以在传输的视频流中的顺序是I P B B。这时候就体现出每帧都有 DTS 和 PTS 的作用了。DTS 告诉我们该按什么顺序解码这几帧图像，PTS 告诉我们该按什么顺序显示这几帧图像。</p><p>PTS:    1 4 2 3</p><p>DTS:    1 2 3 4</p><p>Stream: I P B B</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Android开发工作两年，真的是感觉Android应用层开发没什么前景了，于是打算在网络安全，智能硬件，音视频这几个方向发展，考虑了一段时间，最终决定选择音视频。理由就不说了，既然选择了就要好好学习了，今天就开始音视频的第一篇博客，从一些音视频的基础知识开始。&lt;/p&gt;
&lt;
      
    
    </summary>
    
      <category term="音视频" scheme="http://yoursite.com/categories/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
    
      <category term="音视频" scheme="http://yoursite.com/tags/%E9%9F%B3%E8%A7%86%E9%A2%91/"/>
    
  </entry>
  
  <entry>
    <title>easyIM Netty开发(一)</title>
    <link href="http://yoursite.com/2018/08/28/Netty%E5%AD%A6%E4%B9%A0-%E4%B8%80/"/>
    <id>http://yoursite.com/2018/08/28/Netty学习-一/</id>
    <published>2018-08-28T11:25:06.000Z</published>
    <updated>2018-11-27T07:45:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前有做过消息推送相关的应用，使用的Netty框架，一直对这个框架非常感兴趣，也学习了一些它的原理，但感觉还是不够，所以想从今天开始对Netty框架写一个系列的使用及原理学习的博客，提升自己，也希望对看到这篇博客的朋友有所帮助，欢迎大家一起讨论。</p><blockquote><p>我一直从事Android开发岗位，后台知识是自学，没有真正参加一个后台项目，所以在文中后台开发比较简单，如有问题欢迎指出，共同学习。</p></blockquote><p>今天写第一篇博客，还是先从Netty框架的使用开始，我自己做了一个easyIM的简单Demo，可以实现简单的聊天功能，使用Protocol Buffer传输数据，以后会继续完善它的功能。</p><p>服务端代码地址 <a href="https://github.com/David1840/easyimServer" target="_blank" rel="noopener">Github/easyImServer</a></p><p>客户端代码地址 <a href="https://github.com/David1840/easyim" target="_blank" rel="noopener">Github/easyIm</a></p><h2 id="一、服务端"><a href="#一、服务端" class="headerlink" title="一、服务端"></a>一、服务端</h2><p>使用SpringBoot搭建的后台服务，比较简单。</p><h4 id="创建服务端主逻辑"><a href="#创建服务端主逻辑" class="headerlink" title="创建服务端主逻辑"></a>创建服务端主逻辑</h4><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span>() &#123;</span></span><br><span class="line"><span class="function">        <span class="title">val</span> <span class="title">boss</span> = <span class="title">NioEventLoopGroup</span>() <span class="comment">//用于处理服务器端接收客户端连接</span></span></span><br><span class="line"><span class="function">        <span class="title">val</span> <span class="title">worker</span> = <span class="title">NioEventLoopGroup</span>() <span class="comment">//进行网络通信（读写）</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">port</span> = <span class="title">nettyConfig</span>.<span class="title">port</span>  <span class="comment">//配置文件中配置端口</span></span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">bootStrap</span> = <span class="title">ServerBootstrap</span>()   <span class="comment">//辅助工具类，用于服务器通道配置</span></span></span><br><span class="line"><span class="function">            <span class="title">bootStrap</span>.<span class="title">group</span>(boss, worker)      <span class="comment">//绑定两个线程组</span></span></span><br><span class="line"><span class="function">                    .<span class="title">channel</span>(<span class="type">NioServerSocketChannel</span>::class.java) <span class="comment">//指定NIO的模式</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childHandler</span>(<span class="type">ProtocolPipeline</span>())            <span class="comment">//配置具体的数据处理方式</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_BACKLOG</span>, <span class="number">1024</span>)          <span class="comment">//设置TCP缓冲区</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_SNDBUF</span>, <span class="number">32</span> * <span class="number">1024</span>) <span class="comment">//设置发送数据缓冲大小</span></span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">SO_RCVBUF</span>, <span class="number">32</span> * <span class="number">1024</span>) <span class="comment">//设置接受数据缓冲大小</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childOption</span>(<span class="type">ChannelOption</span>.<span class="type">SO_KEEPALIVE</span>, true)  <span class="comment">//保持连接</span></span></span><br><span class="line"><span class="function">                    .<span class="title">childOption</span>(<span class="type">ChannelOption</span>.<span class="type">TCP_NODELAY</span>, true)   <span class="comment">//禁用Nagle算法，降低延迟</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">future</span> = <span class="title">bootStrap</span>.<span class="title">bind</span>(port).<span class="title">sync</span>() </span></span><br><span class="line"><span class="function">            <span class="title">logger</span>.<span class="title">info</span>("server start finish,the port is $port")</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">future</span>.<span class="title">channel</span>().<span class="title">closeFuture</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">        &#125; <span class="title">catch</span> (e: <span class="type">InterruptedException</span>) &#123;</span></span><br><span class="line"><span class="function">            <span class="title">logger</span>.<span class="title">error</span>("server start error $&#123;e.message.toString()&#125;")</span></span><br><span class="line"><span class="function">        &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">boss</span>.<span class="title">shutdownGracefully</span>()</span></span><br><span class="line"><span class="function">            <span class="title">worker</span>.<span class="title">shutdownGracefully</span>()</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h4 id="ProtocolPipeline数据处理"><a href="#ProtocolPipeline数据处理" class="headerlink" title="ProtocolPipeline数据处理"></a>ProtocolPipeline数据处理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtocolPipeline</span> : <span class="type">ChannelInitializer</span>&lt;<span class="type">SocketChannel</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">SocketChannel</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> pipeline = ch.pipeline()</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"send heartbeat"</span>, IdleStateHandler(<span class="number">60</span>, <span class="number">0</span>, <span class="number">0</span>, TimeUnit.SECONDS)) <span class="comment">//心跳机制，读空闲，60S</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 使用Protobuf，客户端和服务端必须保持一致</span></span><br><span class="line">        pipeline.addLast(ProtobufVarint32FrameDecoder())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto decoder"</span>, ProtobufDecoder(IMessage.Protocol.getDefaultInstance()))</span><br><span class="line">        pipeline.addLast(ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto encoder"</span>, ProtobufEncoder())</span><br><span class="line">        pipeline.addLast(ServerHandler()) <span class="comment">//接收到数据后的处理逻辑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="传输数据"><a href="#传输数据" class="headerlink" title="传输数据"></a>传输数据</h4><p>数据使用protobuf，</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">syntax = <span class="string">"proto2"</span>;</span><br><span class="line"></span><br><span class="line">message Protocol &#123;</span><br><span class="line">    optional ContentType contentType = <span class="number">1</span>;  <span class="comment">//类型</span></span><br><span class="line">    optional bytes content = <span class="number">2</span>;  <span class="comment">//内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数据类型</span></span><br><span class="line">enum ContentType &#123;</span><br><span class="line">    Register_INFO = <span class="number">0</span>;</span><br><span class="line">    Register_UUID = <span class="number">1</span>;</span><br><span class="line">    Message_INFO = <span class="number">2</span>;</span><br><span class="line">    HEART_BEAT = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//发送给所有人还是发给一个人</span></span><br><span class="line">enum MessageType &#123;</span><br><span class="line">    ALL = <span class="number">0</span>;</span><br><span class="line">    ONE = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册，客户端发给服务端</span></span><br><span class="line">message Register &#123;</span><br><span class="line">    optional <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注册返回，服务端发给客户端</span></span><br><span class="line">message RegisterUUID &#123;</span><br><span class="line">    optional <span class="type">string</span> name = <span class="number">1</span>;</span><br><span class="line">    optional <span class="type">string</span> UUID = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息类</span></span><br><span class="line">message Message &#123;</span><br><span class="line">    optional MessageType type = <span class="number">1</span>; <span class="comment">//个人还是全部</span></span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;    <span class="comment">//如果发送给个人，此项必填</span></span><br><span class="line">    optional <span class="type">string</span> message = <span class="number">3</span>; <span class="comment">//消息具体内容</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//客户端发送给服务端心跳包</span></span><br><span class="line">message HeartBeat_Ping&#123;</span><br><span class="line">    required <span class="type">string</span> time = <span class="number">1</span>;</span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务端返回客户端心跳包</span></span><br><span class="line">message HeartBeat_Pong&#123;</span><br><span class="line">    required <span class="type">string</span> time = <span class="number">1</span>;</span><br><span class="line">    required <span class="type">string</span> uuid = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ServerHandler处理逻辑"><a href="#ServerHandler处理逻辑" class="headerlink" title="ServerHandler处理逻辑"></a>ServerHandler处理逻辑</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ServerHandler</span> : <span class="type">ChannelInboundHandlerAdapter</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> logger = LoggerFactory.getLogger(ServerHandler::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 心跳丢失计数器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">var</span> counter: <span class="built_in">Int</span> = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Throws(Exception::class)</span></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelActive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        logger.info(<span class="string">"有人加入了！"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelInactive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        logger.info(<span class="string">"有人退出"</span>)</span><br><span class="line">        <span class="keyword">super</span>.channelInactive(ctx)</span><br><span class="line">        ChannelMapController.removeByChannle(ctx.channel())</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">userEventTriggered</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, evt: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">is</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (counter &gt;= <span class="number">3</span>) &#123;</span><br><span class="line">                <span class="comment">// 连续丢失3个心跳包 (断开连接)</span></span><br><span class="line">                ctx.channel()?.close()?.sync()</span><br><span class="line">                ChannelMapController.removeByChannle(ctx.channel())</span><br><span class="line">                logger.info(<span class="string">"已与Client断开连接"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                counter++</span><br><span class="line">                logger.info(<span class="string">"丢失了第 <span class="variable">$counter</span> 个心跳包"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> protoMsg = msg <span class="keyword">as</span> IMessage.Protocol  <span class="comment">//解析Protocol</span></span><br><span class="line">        <span class="keyword">val</span> contentType = protoMsg.contentType</span><br><span class="line">        <span class="keyword">if</span> (contentType == IMessage.ContentType.HEART_BEAT) &#123;</span><br><span class="line">            counter = <span class="number">0</span></span><br><span class="line">            logger.info(<span class="string">"收到心跳包"</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            handlerMessage(ctx, msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">fun</span> <span class="title">handlerMessage</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>, msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        counter = <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> contentType = msg.contentType</span><br><span class="line">        <span class="keyword">when</span> (contentType) &#123;</span><br><span class="line">            IMessage.ContentType.Message_INFO -&gt; &#123;</span><br><span class="line">                <span class="keyword">val</span> message: IMessage.Message = IMessage.Message.parseFrom(msg.content)</span><br><span class="line">                <span class="keyword">if</span> (message.type == IMessage.MessageType.ALL) &#123;</span><br><span class="line">                    logger.info(<span class="string">"收到全员广播消息: <span class="subst">$&#123;message.message&#125;</span>"</span>)</span><br><span class="line">                    ChannelMapController.sendMsgToAll(ProtocolFactory.getMessage(message.message, IMessage.MessageType.ONE, <span class="string">""</span>), ctx.channel())</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (message.type == IMessage.MessageType.ONE) &#123;</span><br><span class="line">                    logger.info(<span class="string">"收到个人消息: <span class="subst">$&#123;message.message&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            IMessage.ContentType.Register_INFO -&gt; &#123;</span><br><span class="line">                logger.info(<span class="string">"收到注册消息"</span>)</span><br><span class="line">                <span class="keyword">val</span> register: IMessage.Register = IMessage.Register.parseFrom(msg.content)</span><br><span class="line">                <span class="keyword">val</span> uuid = UUIDGenerator.getUUID()</span><br><span class="line">                ChannelMapController.put(uuid, ctx.channel())</span><br><span class="line">                ctx.writeAndFlush(ProtocolFactory.getUUIDProto(register.name, uuid))</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二、客户端"><a href="#二、客户端" class="headerlink" title="二、客户端"></a>二、客户端</h2><h4 id="创建连接"><a href="#创建连接" class="headerlink" title="创建连接"></a>创建连接</h4><figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">start</span>() &#123;</span></span><br><span class="line"><span class="function">        <span class="title">mGroup</span> = <span class="title">NioEventLoopGroup</span>()</span></span><br><span class="line"><span class="function">        <span class="title">try</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">val</span> <span class="title">b</span> = <span class="title">Bootstrap</span>()</span></span><br><span class="line"><span class="function">            <span class="title">b</span>.<span class="title">group</span>(mGroup)</span></span><br><span class="line"><span class="function">                    .<span class="title">channel</span>(<span class="type">NioSocketChannel</span>::class.java)</span></span><br><span class="line"><span class="function">                    .<span class="title">remoteAddress</span>(<span class="type">InetSocketAddress</span>("<span class="number">172.18</span><span class="number">.157</span><span class="number">.43</span>", <span class="number">1088</span>))</span></span><br><span class="line"><span class="function">                    .<span class="title">option</span>(<span class="type">ChannelOption</span>.<span class="type">CONNECT_TIMEOUT_MILLIS</span>, <span class="number">3000</span>)</span></span><br><span class="line"><span class="function">                    .<span class="title">handler</span>(<span class="type">ProtocolPipeline</span>())</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">            <span class="title">mChannelFuture</span> = <span class="title">b</span>.<span class="title">connect</span>().<span class="title">awaitUninterruptibly</span>()</span></span><br><span class="line"><span class="function">            <span class="title">mChannelFuture</span>!!.<span class="title">channel</span>().<span class="title">closeFuture</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function">        &#125; <span class="title">finally</span> &#123;</span></span><br><span class="line"><span class="function">            <span class="title">mGroup</span>!!.<span class="title">shutdownGracefully</span>().<span class="title">sync</span>()</span></span><br><span class="line"><span class="function">        &#125;</span></span><br><span class="line"><span class="function">    &#125;</span></span><br></pre></td></tr></table></figure><h4 id="ProtocolPipeline数据处理-1"><a href="#ProtocolPipeline数据处理-1" class="headerlink" title="ProtocolPipeline数据处理"></a>ProtocolPipeline数据处理</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ProtocolPipeline</span> : <span class="type">ChannelInitializer</span>&lt;<span class="type">SocketChannel</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">initChannel</span><span class="params">(ch: <span class="type">SocketChannel</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">val</span> pipeline = ch.pipeline()</span><br><span class="line"></span><br><span class="line">        pipeline.addLast(<span class="string">"send heartbeat"</span>, IdleStateHandler(<span class="number">0</span>, <span class="number">30</span>, <span class="number">0</span>, TimeUnit.SECONDS)) <span class="comment">//写延时30秒，表示30秒没有写操作就会触发心跳机制</span></span><br><span class="line">        <span class="comment">// 和服务端保持一致</span></span><br><span class="line">        pipeline.addLast(ProtobufVarint32FrameDecoder())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto decoder"</span>, ProtobufDecoder(IMessage.Protocol.getDefaultInstance()))</span><br><span class="line">        pipeline.addLast(ProtobufVarint32LengthFieldPrepender())</span><br><span class="line">        pipeline.addLast(<span class="string">"proto encoder"</span>, ProtobufEncoder())</span><br><span class="line">        pipeline.addLast(ClientHandler())</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="ClientHandler处理逻辑"><a href="#ClientHandler处理逻辑" class="headerlink" title="ClientHandler处理逻辑"></a>ClientHandler处理逻辑</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClientHandler</span> : <span class="type">SimpleChannelInboundHandler</span>&lt;<span class="type">IMessage.Protocol</span>&gt;</span>() &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">val</span> TAG = <span class="string">"ClientHandler"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelActive</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        SendMsgController.setChannelHandler(ctx) <span class="comment">// 将channel保存在一个单例中</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">channelRead0</span><span class="params">(p0: <span class="type">ChannelHandlerContext</span>?, message: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"get form server <span class="variable">$message</span>"</span>)</span><br><span class="line">        <span class="keyword">val</span> contentType = message.contentType</span><br><span class="line">        <span class="keyword">when</span> (contentType) &#123;</span><br><span class="line">            IMessage.ContentType.HEART_BEAT -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            IMessage.ContentType.Message_INFO -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            IMessage.ContentType.Register_UUID -&gt; &#123;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> -&gt; &#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">userEventTriggered</span><span class="params">(ctx: <span class="type">ChannelHandlerContext</span>?, evt: <span class="type">Any</span>?)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (evt <span class="keyword">is</span> IdleStateEvent) &#123;</span><br><span class="line">            <span class="keyword">if</span> (evt.state() == IdleState.WRITER_IDLE) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"send heartbeat!"</span>)</span><br><span class="line">                ctx?.writeAndFlush(ProtocolFactory.getHeartBeat())</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"其他超时：<span class="subst">$&#123;evt.state()&#125;</span>"</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">super</span>.userEventTriggered(ctx, evt)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="单例SendMsgController"><a href="#单例SendMsgController" class="headerlink" title="单例SendMsgController"></a>单例SendMsgController</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> SendMsgController &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> TAG = SendMsgController::<span class="class"><span class="keyword">class</span>.<span class="title">java</span>.<span class="title">simpleName</span></span></span><br><span class="line">    <span class="keyword">var</span> channelHandlerContext: ChannelHandlerContext? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">setChannelHandler</span><span class="params">(channelHandlerContext: <span class="type">ChannelHandlerContext</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.channelHandlerContext = channelHandlerContext</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelHandlerContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            channelHandlerContext!!.writeAndFlush(msg)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"channelHandlerContext is null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">sendMsg</span><span class="params">(msg: <span class="type">IMessage</span>.<span class="type">Protocol</span>, future: <span class="type">ChannelFutureListener</span>)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (channelHandlerContext != <span class="literal">null</span>) &#123;</span><br><span class="line">            channelHandlerContext!!.writeAndFlush(msg).addListener(future)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"channelHandlerContext is null"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> <span class="title">close</span><span class="params">()</span></span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在连接建立后就将channel保存在一个单例中，之后所有channel相关的操作都可以使用这个单例。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;之前有做过消息推送相关的应用，使用的Netty框架，一直对这个框架非常感兴趣，也学习了一些它的原理，但感觉还是不够，所以想从今天开始对Netty框架写一个系列的使用及原理学习的博客，提升自己，也希望对看到这篇博客的朋友有所帮助，欢迎大家一起讨论。&lt;/p&gt;
&lt;blockquo
      
    
    </summary>
    
      <category term="Netty" scheme="http://yoursite.com/categories/Netty/"/>
    
    
      <category term="Netty" scheme="http://yoursite.com/tags/Netty/"/>
    
  </entry>
  
  <entry>
    <title>Java内存分配及GC回收</title>
    <link href="http://yoursite.com/2018/08/24/Java%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E5%8F%8AGC%E5%9B%9E%E6%94%B6/"/>
    <id>http://yoursite.com/2018/08/24/Java内存分配及GC回收/</id>
    <published>2018-08-24T05:46:57.000Z</published>
    <updated>2018-08-24T07:47:39.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近要准备面试了，今天特意复习一下内存分配和GC相关知识。</p><h2 id="Java内存管理"><a href="#Java内存管理" class="headerlink" title="Java内存管理"></a>Java内存管理</h2><p><img src="/2018/08/24/Java内存分配及GC回收/gc1.jpeg" alt=""></p><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是用于存储每个线程下一步将执行的JVM指令，如该方法为native的，则程序计数器中不存储任何信息。</p><h4 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h4><p>一个线程的每个方法在执行的同时，都会创建一个栈帧（Statck Frame），栈帧中存储的有局部变量表、操作站、动态链接、方法出口等，当方法被调用时，栈帧在JVM栈中入栈，当方法执行完成时，栈帧出栈。</p><p>每个线程对应着一个虚拟机栈，因此虚拟机栈也是线程私有的。</p><h4 id="堆区"><a href="#堆区" class="headerlink" title="堆区"></a>堆区</h4><p>堆区是理解Java GC机制最重要的区域，没有之一。在JVM所管理的内存中，堆区是最大的一块，堆区也是Java GC机制所管理的主要内存区域，堆区由所有线程共享，在虚拟机启动时创建。堆区的存在是为了存储对象实例，原则上讲，所有的对象都在堆区上分配内存（不过现代技术里，也不是这么绝对的，也有栈上直接分配的）。</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>在Sun JDK中这块区域对应的为PermanetGeneration，又称为永久代。方法区域存放了所加载的类的信息（名称、修饰符等）、类中的静态变量、类中定义为final类型的常量、类中的Field信息、类中的方法信息，当开发人员在程序中通过Class对象中的getName、isInterface等方法来获取信息时，这些数据都来源于方法区域，同时方法区域也是全局共享的，在一定的条件下它也会被GC，当方法区域需要使用的内存超过其允许的大小时，会抛出OutOfMemory的错误信息。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>　　JVM采用本地方法栈来支持native方法的执行，此区域用于存储每个native方法调用的状态。</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>　　存放的为类中的固定的常量信息、方法和Field的引用信息等，其空间从方法区域中分配。JVM在加载类时会为每个class分配一个独立的常量池，但是运行时常量池中的字符串常量池是全局共享的。　　</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是JVM管理的内存，可以这样理解，直接内存，就是JVM以外的机器内存，比如，你有4G的内存，JVM占用了1G，则其余的3G就是直接内存，JDK中有一种基于通道（Channel）和缓冲区（Buffer）的内存分配方式，将由C语言实现的native函数库分配在直接内存中，用存储在JVM堆中的DirectByteBuffer来引用。由于直接内存收到本机器内存的限制，所以也可能出现OutOfMemoryError的异常。</p><h2 id="Java内存回收机制"><a href="#Java内存回收机制" class="headerlink" title="Java内存回收机制"></a>Java内存回收机制</h2><p>Java内存分配和回收的机制概括的说，就是：分代分配，分代回收。对象将根据存活的时间被分为：年轻代（Young Generation）、年老代（Old Generation）、永久代（Permanent Generation，也就是方法区）。</p><h3 id="年轻代（Young-Generation）"><a href="#年轻代（Young-Generation）" class="headerlink" title="年轻代（Young Generation）"></a>年轻代（Young Generation）</h3><p>对象被创建时，内存的分配首先发生在年轻代（大对象可以直接被创建在年老代），大部分的对象在创建后很快就不再使用，因此很快变得不可达，于是被年轻代的GC机制清理掉（IBM的研究表明，98%的对象都是很快消亡的），这个GC机制被称为Minor GC或叫Young GC。注意，Minor GC并不代表年轻代内存不足，它事实上只表示在Eden区上的GC。</p><p>新生代又被进一步划分为Eden(伊甸，初次创建)和Survivor(存活)区，Survivor区又分为Survivor1和Survivor2。这里为什么要将Young划分为Eden、Survivor1、Survivor2这三块，给出的解释是：</p><blockquote><p>“Young中的98%的对象都是死朝生夕死，所以将内存分为一块较大的Eden和两块较小的Survivor1、Survivor2，JVM默认分配是8:1:1，每次调用Eden和其中的Survivor1，当发生回收的时候，将Eden和Survivor1存活的对象复制到Survivor2，然后直接清理掉Eden和Survivor1的空间。”</p></blockquote><p>内存分配过程如下图：</p><p><img src="/2018/08/24/Java内存分配及GC回收/gc2.jpeg" alt=""></p><h3 id="年老代（Old-Generation）"><a href="#年老代（Old-Generation）" class="headerlink" title="年老代（Old Generation）"></a>年老代（Old Generation）</h3><p>对象如果在年轻代存活了足够长的时间而没有被清理掉（即在几次Young GC后存活了下来），则会被复制到年老代，年老代的空间一般比年轻代大，能存放更多的对象，在年老代上发生的GC次数也比年轻代少。当年老代内存不足时，将执行Major GC，也叫 Full GC。</p><h3 id="分代收集"><a href="#分代收集" class="headerlink" title="分代收集"></a>分代收集</h3><h4 id="年轻代"><a href="#年轻代" class="headerlink" title="年轻代"></a>年轻代</h4><p>在年轻代中，使用“停止-复制”算法进行清理，将新生代内存分为2部分，1部分 Eden区较大，1部分Survivor比较小，并被划分为两个等量的部分。每次进行清理时，将Eden区和一个Survivor中仍然存活的对象拷贝到 另一个Survivor中，然后清理掉Eden和刚才的Survivor。</p><h4 id="老年代"><a href="#老年代" class="headerlink" title="老年代"></a>老年代</h4><p>老年代存储的对象比年轻代多得多，而且不乏大对象，对老年代进行内存清理时，如果使用停止-复制算法，则相当低效。一般，老年代用的算法是标记-整理算法，即：标记出仍然存活的对象（存在引用的），将所有存活的对象向一端移动，以保证内存的连续。</p><h4 id="方法区（永久代）"><a href="#方法区（永久代）" class="headerlink" title="方法区（永久代）"></a>方法区（永久代）</h4><p>永久代的回收有两种：常量池中的常量，无用的类信息，常量的回收很简单，没有引用了就可以被回收。对于无用的类进行回收，必须保证3点：</p><ol><li>类的所有实例都已经被回收</li><li>加载类的ClassLoader已经被回收</li><li>类对象的Class对象没有被引用（即没有通过反射引用该类的地方）</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>以下是在看其他博客时看到的一个挺不错的问题。<a href="https://www.cnblogs.com/wjtaigwh/p/6635484.html" target="_blank" rel="noopener">原文链接</a></p><blockquote><p>思考“GC是在什么时候，对什么东西，做了什么事情？”</p></blockquote><h4 id="什么时候"><a href="#什么时候" class="headerlink" title="什么时候"></a>什么时候</h4><p>从字面上翻译过来就是什么时候触发我们的GC机制</p><p>① 在程序空闲的时候。这个回答无力吐槽</p><p>② 程序不可预知的时候/手动调用system.gc()。关于手动调用不推荐</p><p>③ Java堆内存不足时,GC会被调用。当应用线程在运行,并在运行过程中创建新对象,若这时内存空间不足,JVM就会强制地调用GC线程,以便回收内存用于新的分配。若GC一次之后仍不能满足内存分配的要求,JVM会再进行两次GC作进一步的尝试,若仍无法满足要求,则 JVM将报“out of memory”的错误,Java应用将停止。</p><h4 id="什么东西"><a href="#什么东西" class="headerlink" title="什么东西"></a>什么东西</h4><p>从字面的意思翻译过来就是能被GC回收的对象都有哪些特征</p><p>①超出作用域的对象/引用计数为空的对象。</p><blockquote><p>引用计数算法：给对象中添加一个引用计数器，每当有一个地方引用它时，计数器就加1；当引用失效时，计数器值就减1；任何时刻计数器都为0的对象就是不可能再被使用的。</p></blockquote><p>②从GC Root开始搜索，且搜索不到的对象</p><blockquote><p>跟搜索算法：以一系列名为 GC Root的对象作为起点，从这些节点开始往下搜索，搜索走过的路径称为引用链，当一个对象到GC Roots没有任何引用链的时候，则就证明此对象是不可用的。</p><p>这里会提出一个思考，什么样的对象能成为GC Root ： 虚拟机中的引用的对象、方法区中的类静态属性引用的对象、方法区中常量引用的对象、本地方法栈中jni的引用对象。</p></blockquote><p>③从root搜索不到，而且经过第一次标记、清理后，仍然没有复活的对象。</p><h4 id="做什么"><a href="#做什么" class="headerlink" title="做什么"></a>做什么</h4><p>不同年代、不同种类的收集器很多，不过总体的作用是删除不使用的对象，腾出内存空间。补充一些诸如停止其他线程执行、运行finalize等的说明。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近要准备面试了，今天特意复习一下内存分配和GC相关知识。&lt;/p&gt;
&lt;h2 id=&quot;Java内存管理&quot;&gt;&lt;a href=&quot;#Java内存管理&quot; class=&quot;headerlink&quot; title=&quot;Java内存管理&quot;&gt;&lt;/a&gt;Java内存管理&lt;/h2&gt;&lt;p&gt;&lt;img src=
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="内存" scheme="http://yoursite.com/tags/%E5%86%85%E5%AD%98/"/>
    
      <category term="GC" scheme="http://yoursite.com/tags/GC/"/>
    
  </entry>
  
  <entry>
    <title>Android中的ClassLoader简析</title>
    <link href="http://yoursite.com/2018/08/22/Android%E4%B8%AD%E7%9A%84ClassLoader%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/22/Android中的ClassLoader简析/</id>
    <published>2018-08-22T04:21:56.000Z</published>
    <updated>2018-08-22T05:27:29.000Z</updated>
    
    <content type="html"><![CDATA[<p>我们知道Java中的ClassLoader可以加载jar文件和Class文件（本质是加载Class文件），这一点在Android中并不适用，因为无论是DVM还是ART它们加载的不再是Class文件，而是dex文件，这就需要重新设计ClassLoader相关类，我们先来学习ClassLoader的类型。 </p><h2 id="ClassLoader类型"><a href="#ClassLoader类型" class="headerlink" title="ClassLoader类型"></a>ClassLoader类型</h2><p>Android中的ClassLoader类型和Java中的ClassLoader类型类似，也分为两种类型，分别是系统ClassLoader和自定义ClassLoader。其中系统ClassLoader包括三种分别是BootClassLoader、PathClassLoader和DexClassLoader。</p><h3 id="BootClassLoader"><a href="#BootClassLoader" class="headerlink" title="BootClassLoader"></a>BootClassLoader</h3><p>Android系统启动时会使用BootClassLoader来预加载常用类，与Java中的BootClassLoader不同，它并不是由C/C++代码实现，而是由Java实现的，BootClassLoade的代码如下所示。 </p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class BootClassLoader extends ClassLoader &#123;</span><br><span class="line">    private static BootClassLoader instance;</span><br><span class="line">    @FindBugsSuppressWarnings(<span class="string">"DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED"</span>)</span><br><span class="line">    public static synchronized BootClassLoader getInstance() &#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="literal">null</span>) &#123;</span><br><span class="line">           <span class="built_in"> instance </span>= new BootClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">        return instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="built_in">..</span>.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>BootClassLoader是ClassLoader的内部类，并继承自ClassLoader。BootClassLoader是一个单例类，需要注意的是BootClassLoader的访问修饰符是默认的，只有在同一个包中才可以访问，因此我们在应用程序中是无法直接调用的。</p><h3 id="PathClassLoader"><a href="#PathClassLoader" class="headerlink" title="PathClassLoader"></a>PathClassLoader</h3><p>Android系统使用PathClassLoader来加载系统类和应用程序的类，如果是加载非系统应用程序类，则会加载data/app/目录下的dex文件以及包含dex的apk文件或jar文件，不管是加载那种文件，最终都是要加载dex文件，在这里为了方便理解，我们将dex文件以及包含dex的apk文件或jar文件统称为dex相关文件。PathClassLoader不建议开发直接使用。来查看它的代码： </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">PathClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    public <span class="type">PathClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="literal">null</span>, <span class="literal">null</span>, parent);</span><br><span class="line">    &#125;</span><br><span class="line">    public <span class="type">PathClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">String</span> librarySearchPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="literal">null</span>, librarySearchPath, parent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>PathClassLoader继承自BaseDexClassLoader，很明显PathClassLoader的方法实现都在BaseDexClassLoader中。从PathClassLoader的构造方法也可以看出它遵循了双亲委托模式。</p><p>PathClassLoader的构造方法有三个参数：</p><ul><li>dexPath：dex文件以及包含dex的apk文件或jar文件的路径集合，多个路径用文件分隔符分隔，默认文件分隔符为‘：’。</li><li>librarySearchPath：包含 C/C++ 库的路径集合，多个路径用文件分隔符分隔分割，可以为null。</li><li>parent：ClassLoader的parent。</li></ul><h3 id="DexClassLoader"><a href="#DexClassLoader" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h3><p>DexClassLoader可以加载dex文件以及包含dex的apk文件或jar文件，也支持从SD卡进行加载，这也就意味着DexClassLoader可以在应用未安装的情况下加载dex相关文件。因此，它是热修复和插件化技术的基础。来查看它的代码，如下所示。 </p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="class"><span class="keyword">class</span> <span class="title">DexClassLoader</span> <span class="keyword">extends</span> <span class="title">BaseDexClassLoader</span> </span>&#123;</span><br><span class="line">    public <span class="type">DexClassLoader</span>(<span class="type">String</span> dexPath, <span class="type">String</span> optimizedDirectory,</span><br><span class="line">            <span class="type">String</span> librarySearchPath, <span class="type">ClassLoader</span> parent) &#123;</span><br><span class="line">        <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> <span class="type">File</span>(optimizedDirectory), librarySearchPath, parent);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DexClassLoader构造方法的参数要比PathClassLoader多一个optimizedDirectory参数，参数optimizedDirectory代表什么呢？我们知道应用程序第一次被加载的时候，为了提高以后的启动速度和执行效率，Android系统会对dex相关文件做一定程度的优化，并生成一个ODEX文件，此后再运行这个应用程序的时候，只要加载优化过的ODEX文件就行了，省去了每次都要优化的时间，而参数optimizedDirectory就是代表存储ODEX文件的路径，这个路径必须是一个内部存储路径。<br>PathClassLoader没有参数optimizedDirectory，这是因为PathClassLoader已经默认了参数optimizedDirectory的路径为：/data/dalvik-cache。DexClassLoader 也继承自BaseDexClassLoader ，方法实现也都在BaseDexClassLoader中。</p><h2 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h2><p><img src="/2018/08/22/Android中的ClassLoader简析/DexClassloader1.png" alt=""></p><p>可以看到上面一共有8个ClassLoader相关类，其中有一些和Java中的ClassLoader相关类十分类似，下面简单对它们进行介绍：</p><ul><li>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。BootClassLoader是它的内部类。</li><li>SecureClassLoader类和JDK8中的SecureClassLoader类的代码是一样的，它继承了抽象类ClassLoader。SecureClassLoader并不是ClassLoader的实现类，而是拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性。</li><li>URLClassLoader类和JDK8中的URLClassLoader类的代码是一样的，它继承自SecureClassLoader，用来通过URl路径从jar文件和文件夹中加载类和资源。</li><li>InMemoryDexClassLoader是Android8.0新增的类加载器，继承自BaseDexClassLoader，用于加载内存中的dex文件。</li><li>BaseDexClassLoader继承自ClassLoader，是抽象类ClassLoader的具体实现类，PathClassLoader和DexClassLoader都继承它。</li></ul><h2 id="DexClassLoader-1"><a href="#DexClassLoader-1" class="headerlink" title="DexClassLoader"></a>DexClassLoader</h2><p>介绍 DexClassLoader 之前，先来看看其官方描述：</p><blockquote><p>A class loader that loads classes from .jar and .apk filescontaining a classes.dex entry. This can be used to execute code notinstalled as part of an application.</p></blockquote><p>DexClassLoader 的源码里面只有一个构造方法，这里也是遵从双亲委托模型：</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DexClassLoader(<span class="keyword">String</span> dexPath, <span class="keyword">String</span> optimizedDirectory,</span><br><span class="line">        <span class="keyword">String</span> libraryPath, ClassLoader parent) &#123;</span><br><span class="line">    <span class="keyword">super</span>(dexPath, <span class="keyword">new</span> <span class="type">File</span>(optimizedDirectory), libraryPath, parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ol><li><p>String dexPath: 包含 class.dex 的 apk、jar 文件路径 ，多个用文件分隔符(默认是 ：)分隔</p></li><li><p>String optimizedDirectory : 用来缓存优化的 dex 文件的路径，即从 apk 或 jar 文件中提取出来的 dex 文件。该路径不可以为空，且应该是应用私有的，有读写权限的路径</p></li><li><p>String libraryPath: 存储 C/C++ 库文件的路径集</p></li><li><p>ClassLoader parent : 父类加载器，遵从双亲委托模型</p></li></ol><p>PathClassLoader 和 DexClassLoader，但这两者都是对 BaseDexClassLoader 的一层简单封装，真正的实现都在 BaseClassLoader 内。因此简单分析一下BaseClassLoader。</p><h2 id="BaseClassLoader"><a href="#BaseClassLoader" class="headerlink" title="BaseClassLoader"></a>BaseClassLoader</h2><p>先来看一眼 BaseClassLoader 的结构：</p><p><img src="/2018/08/22/Android中的ClassLoader简析/2.jpg" alt=""></p><p>其中有个重要的字段 private final DexPathList pathList，其继承 ClassLoader 实现的 findClass()、findResource()<br>均是基于 pathList 来实现的（省略了部分源码）：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    List&lt;Throwable&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;Throwable&gt;();</span><br><span class="line">    Class c = pathList.findClass(name, suppressedExceptions);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> c;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function">URL <span class="title">findResource</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findResource</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">protected</span> Enumeration&lt;URL&gt; findResources(String name) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findResources</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function">String <span class="title">findLibrary</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">return</span> pathList.<span class="title">findLibrary</span><span class="params">(name)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么重要的部分则是在 DexPathList 类的内部了，DexPathList 的构造方法也较为简单，和之前介绍的类似：</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> DexPathList(ClassLoader definingContext, <span class="keyword">String</span> dexPath,</span><br><span class="line">        <span class="keyword">String</span> libraryPath, <span class="built_in">File</span> optimizedDirectory) &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受之前传进来的包含 dex 的 apk/jar/dex 的路径集、native 库的路径集和缓存优化的 dex 文件的路径，然后调用 makePathElements()方法生成一个Element[] dexElements数组，Element 是 DexPathList 的一个嵌套类，其有以下字段：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">class</span> Element &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">File</span> dir;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> isDirectory;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">File</span> zip;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> DexFile dexFile;</span><br><span class="line">    <span class="keyword">private</span> ZipFile zipFile;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> initialized;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>makePathElements() 是如何生成 Element 数组的？继续看源码：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Element[] makePathElements(List&lt;<span class="keyword">File</span>&gt; files, <span class="keyword">File</span> optimizedDirectory,</span><br><span class="line">                                          List&lt;IOException&gt; suppressedExceptions) &#123;</span><br><span class="line">    List&lt;Element&gt; elements = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 遍历所有的包含 dex 的文件</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">File</span> <span class="keyword">file</span> : files) &#123;</span><br><span class="line">        <span class="keyword">File</span> zip = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">File</span> dir = <span class="keyword">new</span> <span class="keyword">File</span>(<span class="string">""</span>);</span><br><span class="line">        DexFile dex = <span class="keyword">null</span>;</span><br><span class="line">        String path = <span class="keyword">file</span>.getPath();</span><br><span class="line">        String name = <span class="keyword">file</span>.getName();</span><br><span class="line">        <span class="comment">// 判断是不是 zip 类型</span></span><br><span class="line">        <span class="keyword">if</span> (path.contains(zipSeparator)) &#123;</span><br><span class="line">            String split[] = path.split(zipSeparator, <span class="number">2</span>);</span><br><span class="line">            zip = <span class="keyword">new</span> <span class="keyword">File</span>(split[<span class="number">0</span>]);</span><br><span class="line">            dir = <span class="keyword">new</span> <span class="keyword">File</span>(split[<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isDirectory()) &#123;</span><br><span class="line">            <span class="comment">// 如果是文件夹,则直接添加 Element,这个一般是用来处理 native 库和资源文件</span></span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(<span class="keyword">file</span>, <span class="keyword">true</span>, <span class="keyword">null</span>, <span class="keyword">null</span>));</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">file</span>.isFile()) &#123;</span><br><span class="line">            <span class="comment">// 直接是 .dex 文件,而不是 zip/jar 文件(apk 归为 zip),则直接加载 dex 文件</span></span><br><span class="line">            <span class="keyword">if</span> (name.endsWith(DEX_SUFFIX)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line">                    System.logE(<span class="string">"Unable to load dex file: "</span> + <span class="keyword">file</span>, ex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 如果是 zip/jar 文件(apk 归为 zip),则将 file 值赋给 zip 字段,再加载 dex 文件</span></span><br><span class="line">                zip = <span class="keyword">file</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    dex = loadDexFile(<span class="keyword">file</span>, optimizedDirectory);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException suppressed) &#123;</span><br><span class="line">                    suppressedExceptions.add(suppressed);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.logW(<span class="string">"ClassLoader referenced unknown path: "</span> + <span class="keyword">file</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((zip != <span class="keyword">null</span>) || (dex != <span class="keyword">null</span>)) &#123;</span><br><span class="line">            elements.add(<span class="keyword">new</span> Element(dir, <span class="keyword">false</span>, zip, dex));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// list 转为数组</span></span><br><span class="line">    <span class="keyword">return</span> elements.toArray(<span class="keyword">new</span> Element[elements.<span class="keyword">size</span>()]);</span><br></pre></td></tr></table></figure><p>oadDexFile()方法最终会调用 JNI 层的方法来读取 dex 文件，这里不再深入探究。<br>接下来看以下 DexPathList 的 findClass()方法，其根据传入的完整的类名来加载对应的 class，源码如下：</p><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">Class</span> <span class="title">findClass</span>(<span class="title">String</span> <span class="title">name</span>, <span class="title">List</span>&lt;<span class="title">Throwable</span>&gt; <span class="title">suppressed</span>) &#123;</span></span><br><span class="line">    // 遍历 dexElements 数组，依次寻找对应的 <span class="class"><span class="keyword">class</span>，一旦找到就终止遍历</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : dexElements) &#123;</span><br><span class="line">        DexFile dex = element.dexFile;</span><br><span class="line">        <span class="keyword">if</span> (dex != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="class"><span class="keyword">Class</span> <span class="title">clazz</span> = <span class="title">dex</span>.<span class="title">loadClassBinaryName</span>(<span class="title">name</span>, <span class="title">definingContext</span>, <span class="title">suppressed</span>);</span></span><br><span class="line">            <span class="keyword">if</span> (clazz != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> clazz;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // 抛出异常</span><br><span class="line">    <span class="keyword">if</span> (dexElementsSuppressedExceptions != <span class="literal">null</span>) &#123;</span><br><span class="line">        suppressed.addAll(Arrays.asList(dexElementsSuppressedExceptions));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有关于热修复实现的一个点，就是将补丁 dex 文件放到 dexElements 数组前面，这样在加载 class 时，优先找到补丁包中的 dex 文件，加载到 class 之后就不再寻找，从而原来的 apk 文件中同名的类就不会再使用，从而达到修复的目的。</p><p>至此，BaseDexClassLader 寻找 class 的路线就清晰了：</p><ol><li>当传入一个完整的类名，调用 BaseDexClassLader 的 findClass(String name) 方法</li><li>BaseDexClassLader 的 findClass 方法会交给 DexPathList 的 findClass(String name, List<throwable> suppressed)方法处理</throwable></li><li>在 DexPathList 方法的内部，会遍历 dexFile ，通过 DexFile的dex.loadClassBinaryName(name,definingContext, suppressed)来完成类的加载</li></ol><p>需要注意到的是，在项目中使用 BaseDexClassLoader 或者 DexClassLoader 去加载某个 dex 或者 apk 中的 class 时，是无法调用 findClass()方法的，因为该方法是包访问权限，你需要调用 loadClass(String className)<br>，该方法其实是 BaseDexClassLoader 的父类 ClassLoader 内实现的：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String className) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">return</span> loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; loadClass(String className, <span class="keyword">boolean</span> resolve) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">    <span class="keyword">Class</span>&lt;?&gt; clazz = findLoadedClass(className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ClassNotFoundException suppressed = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            clazz = parent.loadClass(className, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            suppressed = e;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clazz = findClass(className);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                e.addSuppressed(suppressed);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> clazz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这段代码结合之前提到的双亲委托模型就很好理解了，先查找当前的 ClassLoader 是否已经加载过，如果没有就交给父 ClassLoader 去加载，如果父 ClassLoader 没有找到，才调用当前 ClassLoader 来加载，此时就是调用上面分析的 findClass() 方法了。</p><p>出自：</p><p><a href="https://www.jianshu.com/p/96a72d1a7974" target="_blank" rel="noopener">小小亭长博客</a> </p><p><a href="https://blog.csdn.net/itachi85" target="_blank" rel="noopener">刘望舒博客</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;我们知道Java中的ClassLoader可以加载jar文件和Class文件（本质是加载Class文件），这一点在Android中并不适用，因为无论是DVM还是ART它们加载的不再是Class文件，而是dex文件，这就需要重新设计ClassLoader相关类，我们先来学习C
      
    
    </summary>
    
      <category term="Android系统" scheme="http://yoursite.com/categories/Android%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="Android" scheme="http://yoursite.com/tags/Android/"/>
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
  </entry>
  
  <entry>
    <title>Java中的ClassLoader简析</title>
    <link href="http://yoursite.com/2018/08/22/Java%E4%B8%AD%E7%9A%84ClassLoader%E7%AE%80%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/22/Java中的ClassLoader简析/</id>
    <published>2018-08-22T04:21:15.000Z</published>
    <updated>2018-08-22T04:58:48.000Z</updated>
    
    <content type="html"><![CDATA[<p>插件化和热修复都是目前比较火热的技术，而它们的实现是基于ClassLoader，因此今天先来分析一下Java中的ClassLoader。</p><h2 id="类加载子系统"><a href="#类加载子系统" class="headerlink" title="类加载子系统"></a>类加载子系统</h2><p>首先看一下Java虚拟机结构，如下图</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader1.png" alt=""></p><p>从图中可以看到类加载子系统是在Class文件和JVM之间的桥梁，它的作用就是通过多种类加载器来查找和加载Class文件到Java虚拟机中。</p><p>Java中的类加载器主要有两种类型，系统类加载和自定义类加载器。其中系统类加载器包括3种，分别是Bootstrap ClassLoader、 Extensions ClassLoader和 Application ClassLoader。</p><h3 id="Bootstrap-ClassLoader"><a href="#Bootstrap-ClassLoader" class="headerlink" title="Bootstrap ClassLoader"></a>Bootstrap ClassLoader</h3><p>用C/C++代码实现的加载器，用于加载Java虚拟机运行时所需要的系统类，如<code>java.lang.*</code>、<code>java.uti.*</code>等这些系统类，它们默认在$JAVA_HOME/jre/lib目录中，也可以通过启动Java虚拟机时指定-Xbootclasspath选项，来改变Bootstrap ClassLoader的加载目录。 </p><p>Java虚拟机的启动就是通过 Bootstrap ClassLoader创建一个初始类来完成的。由于Bootstrap ClassLoader是使用C/C++语言实现的， 所以该加载器不能被Java代码访问到。需要注意的是Bootstrap ClassLoader并不继承java.lang.ClassLoader。 </p><h3 id="Extensions-ClassLoader"><a href="#Extensions-ClassLoader" class="headerlink" title="Extensions ClassLoader"></a>Extensions ClassLoader</h3><p>用于加载 Java 的拓展类 ，用来提供除了系统类之外的额外功能。也可以通过-Djava.ext.dirs选项添加和修改Extensions ClassLoader加载的路径。</p><h3 id="Application-ClassLoader"><a href="#Application-ClassLoader" class="headerlink" title="Application ClassLoader"></a>Application ClassLoader</h3><p>负责加载当前应用程序Classpath目录下的所有jar和Class文件。也可以加载通过-Djava.class.path选项所指定的目录下的jar和Class文件。</p><h3 id="Custom-ClassLoader"><a href="#Custom-ClassLoader" class="headerlink" title="Custom ClassLoader"></a>Custom ClassLoader</h3><p>除了系统提供的类加载器，还可以自定义类加载器，自定义类加载器通过继承java.lang.ClassLoader类的方式来实现自己的类加载器，Extensions ClassLoader和Application ClassLoader也继承了java.lang.ClassLoader类。</p><h2 id="ClassLoader的继承关系"><a href="#ClassLoader的继承关系" class="headerlink" title="ClassLoader的继承关系"></a>ClassLoader的继承关系</h2><p>运行一个Java程序需要用到几种类型的类加载器呢？如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">ClassLoaderTest</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>)</span> &#123;</span><br><span class="line">        ClassLoader loader = ClassLoaderTest.class.getClassLoader();</span><br><span class="line">        <span class="keyword">while</span> (loader != <span class="literal">null</span>) &#123;</span><br><span class="line">            System.<span class="keyword">out</span>.println(loader);</span><br><span class="line">            loader = loader.getParent();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印结果如下所示。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$AppClassLoader</span>@<span class="number">75</span>b84c92</span><br><span class="line">sun<span class="selector-class">.misc</span><span class="selector-class">.Launcher</span><span class="variable">$ExtClassLoader</span>@<span class="number">1</span>b6d3586</span><br></pre></td></tr></table></figure><p>第1行说明加载ClassLoaderTest的类加载器是AppClassLoader，第2行说明AppClassLoader的父加载器为ExtClassLoader。至于为何没有打印出ExtClassLoader的父加载器Bootstrap ClassLoader，这是因为Bootstrap ClassLoader是由C/C++编写的，并不是一个Java类，因此我们无法在Java代码中获取它的引用。</p><p>我们知道系统所提供的类加载器有3种类型，但是系统提供的ClassLoader相关类却不只3个。另外，AppClassLoader的父类加载器为ExtClassLoader，并不代表AppClassLoader继承自ExtClassLoader，ClassLoader的继承关系如下所示。</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader2.png" alt=""></p><p>可以看到上图中共有5个ClassLoader相关类，下面简单对它们进行介绍：</p><ul><li>ClassLoader是一个抽象类，其中定义了ClassLoader的主要功能。</li><li>SecureClassLoader继承了抽象类ClassLoader，但SecureClassLoader并不是ClassLoader的实现类，而是拓展了ClassLoader类加入了权限方面的功能，加强了ClassLoader的安全性。</li><li>URLClassLoader继承自SecureClassLoader，用来通过URl路径从jar文件和文件夹中加载类和资源。</li><li>ExtClassLoader和AppClassLoader都继承自URLClassLoader，它们都是Launcher 的内部类，Launcher 是Java虚拟机的入口应用，ExtClassLoader和AppClassLoader都是在Launcher中进行初始化的。</li></ul><h2 id="双亲委托模式"><a href="#双亲委托模式" class="headerlink" title="双亲委托模式"></a>双亲委托模式</h2><p>类加载器查找Class所采用的是双亲委托模式，所谓双亲委托模式就是首先判断该Class是否已经加载，如果没有则不是自身去查找而是委托给父加载器进行查找，这样依次的进行递归，直到委托到最顶层的Bootstrap ClassLoader，如果Bootstrap ClassLoader找到了该Class，就会直接返回，如果没找到，则继续依次向下查找，如果还没找到则最后会交由自身去查找。<br>这样讲可能会有些抽象，来看下面的图。</p><p><img src="/2018/08/22/Java中的ClassLoader简析/classloader3.png" alt=""></p><p>我们知道类加载子系统用来查找和加载Class文件到 Java 虚拟机中，假设我们要加载一个位于D盘的Class文件，这时系统所提供的类加载器不能满足条件，这时就需要我们自定义类加载器继承自java.lang.ClassLoader，并复写它的findClass方法。加载D盘的Class文件步骤如下：</p><ol><li>自定义类加载器首先从缓存中要查找Class文件是否已经加载，如果已经加载就返回该Class，如果没加载则委托给父加载器也就是App ClassLoader。</li><li>按照上图中红色虚线的方向递归步骤1。</li><li>一直委托到Bootstrap ClassLoader，如果Bootstrap ClassLoader在缓存中还没有查找到Class文件，则在自己的规定路径JAVA_HOME/jre/libr中或者-Xbootclasspath选项指定路径的jar包中进行查找，如果找到则返回该Class，如果没有则交给子加载器Extensions ClassLoader。</li><li>Extensions ClassLoader查找JAVA_HOME/jre/lib/ext目录下或者-Djava.ext.dirs选项指定目录下的jar包，如果找到就返回，找不到则交给App ClassLoader。</li><li>App ClassLoade查找Classpath目录下或者-Djava.ext.dirs选项所指定的目录下的jar包和Class文件，如果找到就返回，找不到交给我们自定义的类加载器，如果还找不到则抛出异常。</li></ol><p>总的来说就是Class文件加载到类加载子系统后，先沿着图中红色虚线的方向自下而上进行委托，再沿着黑色虚线的方向自上而下进行查找，整个过程就是先上后下。</p><p>类加载的步骤在JDK8的源码中也得到了体现，来查看抽象类的ClassLoader方法，如下所示。</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">Class</span>&lt;?&gt; More ...loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="keyword">Class</span>&lt;?&gt; c = findLoadedClass(name);<span class="comment">//1</span></span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);<span class="comment">//2</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);<span class="comment">//3</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;            </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// If still not found, then invoke findClass in order</span></span><br><span class="line">                    <span class="comment">// to find the class.</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);<span class="comment">//4</span></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">           <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注释1处用来检查类是否已经加载，如果已经加载则后面的代码不会执行，最后会返回该类。没有加载则会接着向下执行。 </p><p>注释2处，如果父类加载器不为null，则调用父类加载器的loadClass方法。如果父类加载器为null则调用注释3处的findBootstrapClassOrNull方法，这个方法内部调用了Native方法findLoadedClass0，findLoadedClass0方法中最终会用Bootstrap Classloader来查找类。如果Bootstrap Classloader仍没有找到该类，也就说明向上委托没有找到该类，则调用注释4处的findClass方法继续向下进行查找。</p><h4 id="双亲委托模式的好处"><a href="#双亲委托模式的好处" class="headerlink" title="双亲委托模式的好处"></a>双亲委托模式的好处</h4><p>采取双亲委托模式主要有两点好处： </p><ol><li>避免重复加载，如果已经加载过一次Class，就不需要再次加载，而是先从缓存中直接读取。 </li><li>更加安全，如果不使用双亲委托模式，就可以自定义一个String类来替代系统的String类，这显然会造成安全隐患，采用双亲委托模式会使得系统的String类在Java虚拟机启动时就被加载，也就无法自定义String类来替代系统的String类，除非我们修改类加载器搜索类的默认算法。还有一点，只有两个类名一致并且被同一个类加载器加载的类，Java虚拟机才会认为它们是同一个类，想要骗过Java虚拟机显然不会那么容易。</li></ol><h2 id="自定义ClassLoader"><a href="#自定义ClassLoader" class="headerlink" title="自定义ClassLoader"></a>自定义ClassLoader</h2><p>系统提供的类加载器只能够加载指定目录下的jar包和Class文件，如果想要加载网络上的或者是D盘某一文件中的jar包和Class文件则需要自定义ClassLoader。</p><p>实现自定义ClassLoader需要两个步骤： </p><ol><li>定义一个自定义ClassLoade并继承抽象类ClassLoader。 </li><li>复写findClass方法，并在findClass方法中调用defineClass方法。</li></ol><p>下面我们就自定义一个ClassLoader用来加载位于D:\lib的Class文件。</p><h4 id="编写测试Class文件"><a href="#编写测试Class文件" class="headerlink" title="编写测试Class文件"></a>编写测试Class文件</h4><p>首先编写测试类并生成Class文件，如下所示。</p><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">package com.example;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Jobs</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        System.<span class="keyword">out</span>.println(<span class="string">"One more thing"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将这个Jobs.java放入到D:\lib中，使用cmd命令进入D:\lib目录中，执行Javac Jobs.java对该java文件进行编译，这时会在D:\lib中生成Jobs.class。</p><h4 id="编写自定义ClassLoader"><a href="#编写自定义ClassLoader" class="headerlink" title="编写自定义ClassLoader"></a>编写自定义ClassLoader</h4><p>接下来编写自定义ClassLoader，如下所示。</p><figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.ByteArrayOutputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.File;</span><br><span class="line"><span class="keyword">import</span> java.io.FileInputStream;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> DiskClassLoader extends ClassLoader &#123;</span><br><span class="line">    <span class="keyword">private</span> String path;</span><br><span class="line">    <span class="keyword">public</span> DiskClassLoader(String path) &#123;</span><br><span class="line">        <span class="keyword">this</span>.path = path;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123;</span><br><span class="line">        Class clazz = <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">byte</span>[] classData = loadClassData(name);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">if</span> (classData == <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            clazz= defineClass(name, classData, <span class="number">0</span>, classData.length);<span class="comment">//2</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> clazz;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] loadClassData(String name) &#123;</span><br><span class="line">        String fileName = getFileName(name);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path,fileName);</span><br><span class="line">        InputStream <span class="keyword">in</span>=<span class="literal">null</span>;</span><br><span class="line">        ByteArrayOutputStream <span class="keyword">out</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">             <span class="keyword">in</span> = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">             <span class="keyword">out</span> = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">            <span class="keyword">byte</span>[] buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">            <span class="keyword">int</span> length=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> ((length = <span class="keyword">in</span>.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                <span class="keyword">out</span>.write(buffer, <span class="number">0</span>, length);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">out</span>.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">in</span>!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">in</span>.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">out</span>!=<span class="literal">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">out</span>.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (IOException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> String getFileName(String name) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = name.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        <span class="keyword">if</span>(index == -<span class="number">1</span>)&#123;<span class="comment">//如果没有找到'.'则直接在末尾添加.class</span></span><br><span class="line">            <span class="keyword">return</span> name+<span class="string">".class"</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name.substring(index+<span class="number">1</span>)+<span class="string">".class"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码有几点需要注意的，注释1处的loadClassData方法会获得class文件的字节码数组，并在注释2处调用defineClass方法将class文件的字节码数组转为Class类的实例。loadClassData方法中需要对流进行操作，关闭流的操作要放在finally语句块中，并且要对in和out分别采用try语句，如果in和out共同在一个try语句中，那么如果in.close()发生异常，则无法执行 out.close()。</p><p>最后我们来验证DiskClassLoader是否可用，代码如下所示。</p><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationTargetException;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassLoaderTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> void main(<span class="keyword">String</span>[] args) &#123;</span><br><span class="line">        DiskClassLoader diskClassLoader = <span class="keyword">new</span> <span class="type">DiskClassLoader</span>(<span class="string">"D:\\lib"</span>);<span class="comment">//1</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class c = diskClassLoader.loadClass(<span class="string">"com.example.Jobs"</span>);<span class="comment">//2</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="literal">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Object obj = c.<span class="keyword">new</span><span class="type">Instance</span>();</span><br><span class="line">                    System.out.println(obj.getClass().getClassLoader());</span><br><span class="line">                    Method method = c.getDeclaredMethod(<span class="string">"say"</span>, <span class="literal">null</span>);</span><br><span class="line">                    method.invoke(obj, <span class="literal">null</span>);<span class="comment">//3</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (InstantiationException | IllegalAccessException</span><br><span class="line">                        | NoSuchMethodException</span><br><span class="line">                        | SecurityException |</span><br><span class="line">                        IllegalArgumentException |</span><br><span class="line">                        InvocationTargetException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注释1出创建DiskClassLoader并传入要加载类的路径，注释2处加载Class文件，需要注意的是，不要在项目工程中存在名为com.example.Jobs的Java文件，否则就不会使用DiskClassLoader来加载，而是AppClassLoader来负责加载，这样我们定义DiskClassLoader就变得毫无意义。接下来在注释3通过反射来调用Jobs的say方法，打印结果如下：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">com</span><span class="selector-class">.example</span><span class="selector-class">.DiskClassLoader</span>@<span class="keyword">4554617c</span></span><br><span class="line"><span class="keyword">One</span> more thing</span><br></pre></td></tr></table></figure><p>使用了DiskClassLoader来加载Class文件，say方法也正确执行，显然我们的目的达到了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;插件化和热修复都是目前比较火热的技术，而它们的实现是基于ClassLoader，因此今天先来分析一下Java中的ClassLoader。&lt;/p&gt;
&lt;h2 id=&quot;类加载子系统&quot;&gt;&lt;a href=&quot;#类加载子系统&quot; class=&quot;headerlink&quot; title=&quot;类加载子
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="ClassLoader" scheme="http://yoursite.com/tags/ClassLoader/"/>
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap和LRU</title>
    <link href="http://yoursite.com/2018/08/20/LinkedHashMap%E5%92%8CLRU/"/>
    <id>http://yoursite.com/2018/08/20/LinkedHashMap和LRU/</id>
    <published>2018-08-20T06:28:05.000Z</published>
    <updated>2018-08-20T07:53:37.000Z</updated>
    
    <content type="html"><![CDATA[<p>刚好正在研究Android中LruCache缓存，它的实现其实也是使用了LinkedHashMap，所以今天就专门写博客记录一下相关知识。</p><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>LinkedHashMap实际上是使用HashMap+双向链表，有关HashMap的详细知识就请看之前相关博客<a href="https://david1840.github.io/2018/08/12/HashMap%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/" target="_blank" rel="noopener">HashMap源码分析</a>。我们知道HashMap是以散列表的形式存储数据的，LinkedHashMap继承HashMap，所以它也是使用散列表存储数据，但是，会有额外的“Linked”双向链表把所有的数据连接起来。为什么要这样做？HashMap是无序的，而加上双向链表，就将所有数据有序管理起来。具体如下图：</p><p><img src="/2018/08/20/LinkedHashMap和LRU/linkedhashmap.png" alt=""></p><p>在HashMap的基础上多了befor和after字段，用来形成双向链表。</p><h2 id="两个例子"><a href="#两个例子" class="headerlink" title="两个例子"></a>两个例子</h2><p>LinkedHashMap的核心就是存在存储顺序和可以实现LRU算法，所以下面我用两个例子证明这两种情况：</p><h4 id="存储顺序"><a href="#存储顺序" class="headerlink" title="存储顺序"></a>存储顺序</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span> map = new LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span>();</span><br><span class="line">        for (int i = 0; i <span class="tag">&lt; <span class="attr">10</span>; <span class="attr">i</span>++) &#123;//按顺序放入<span class="attr">1</span>~<span class="attr">9</span></span></span><br><span class="line"><span class="tag">            <span class="attr">map.put</span>(<span class="attr">i</span>, <span class="attr">i</span>);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("原数据："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.get</span>(<span class="attr">3</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("查询存在的某一个："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">4</span>, <span class="attr">4</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入已存在的某一个："+<span class="attr">map.toString</span>()); //直接调用已存在的<span class="attr">toString</span>方法，不然自己需要用迭代器实现</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">10</span>, <span class="attr">10</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入一个原本没存在的："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //输出结果</span></span><br><span class="line"><span class="tag">//  原数据：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  查询存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  插入已存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  插入一个原本没存在的：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">10</span>=<span class="string">10&#125;</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>观察以上代码，其实它是符合先进先出的规则的，不管你怎么查询插入已存在的数据，不会对排序造成影响，如果有新插入的数据将会放在最尾部。</p><h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><p>启用LinkedHashMap的LRU规则是要使用它的三个参数的构造方法。</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty &lt;tt&gt;LinkedHashMap&lt;/tt&gt; instance with the</span></span><br><span class="line"><span class="comment">     * specified initial capacity, load factor and ordering mode.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity the initial capacity</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  loadFactor      the load factor</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  accessOrder     the ordering mode - &lt;tt&gt;true&lt;/tt&gt; for</span></span><br><span class="line"><span class="comment">     *         access-order, &lt;tt&gt;false&lt;/tt&gt; for insertion-order</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the initial capacity is negative</span></span><br><span class="line"><span class="comment">     *         or the load factor is nonpositive</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> LinkedHashMap(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                         <span class="keyword">float</span> loadFactor,</span><br><span class="line">                         <span class="keyword">boolean</span> accessOrder) &#123;</span><br><span class="line">        <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.accessOrder = accessOrder;<span class="comment">//是否开启LRU规则</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public class LinkedHashMapTest &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span> map = new LinkedHashMap<span class="tag">&lt;<span class="name">Integer,</span> <span class="attr">Integer</span>&gt;</span>(20, 0.75f, true);</span><br><span class="line">        for (int i = 0; i <span class="tag">&lt; <span class="attr">10</span>; <span class="attr">i</span>++) &#123;//按顺序放入<span class="attr">1</span>~<span class="attr">9</span></span></span><br><span class="line"><span class="tag">            <span class="attr">map.put</span>(<span class="attr">i</span>, <span class="attr">i</span>);</span></span><br><span class="line"><span class="tag">        &#125;</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("原数据："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.get</span>(<span class="attr">3</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("查询存在的某一个："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">4</span>, <span class="attr">4</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入已存在的某一个："+<span class="attr">map.toString</span>()); //直接调用已存在的<span class="attr">toString</span>方法，不然自己需要用迭代器实现</span></span><br><span class="line"><span class="tag">        <span class="attr">map.put</span>(<span class="attr">10</span>, <span class="attr">10</span>);</span></span><br><span class="line"><span class="tag">        <span class="attr">System.out.println</span>("插入一个原本没存在的："+<span class="attr">map.toString</span>());</span></span><br><span class="line"><span class="tag">    &#125;</span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">    //输出结果</span></span><br><span class="line"><span class="tag">//  原数据：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9&#125;</span></span></span><br><span class="line"><span class="tag">//  查询存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3&#125;</span> //被访问（<span class="attr">get</span>）的<span class="attr">3</span>放到了最后面</span></span><br><span class="line"><span class="tag">//  插入已存在的某一个：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4&#125;//被访问（put）的4放到了最后面</span></span></span><br><span class="line"><span class="tag">//  插入一个原本没存在的：&#123;<span class="attr">0</span>=<span class="string">0,</span> <span class="attr">1</span>=<span class="string">1,</span> <span class="attr">2</span>=<span class="string">2,</span> <span class="attr">5</span>=<span class="string">5,</span> <span class="attr">6</span>=<span class="string">6,</span> <span class="attr">7</span>=<span class="string">7,</span> <span class="attr">8</span>=<span class="string">8,</span> <span class="attr">9</span>=<span class="string">9,</span> <span class="attr">3</span>=<span class="string">3,</span> <span class="attr">4</span>=<span class="string">4,</span> <span class="attr">10</span>=<span class="string">10&#125;//新增一个放到最后面</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">&#125;</span></span><br></pre></td></tr></table></figure><p>从上面可以看出，每当我get或者put一个已存在的数据，就会把这个数据放到双向链表的尾部，put一个新的数据也会放到双向链表的尾部。</p><h2 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h2><h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>();</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(Map&lt;? <span class="keyword">extends</span> K, ? <span class="keyword">extends</span> V&gt; m)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(m);</span><br><span class="line">       accessOrder = <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">public</span> LinkedHashMap(<span class="keyword">int</span> initialCapacity,</span><br><span class="line">                        <span class="keyword">float</span> loadFactor,</span><br><span class="line">                        <span class="keyword">boolean</span> accessOrder) &#123;</span><br><span class="line">       <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">       <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>5个构造函数，可以设置容量和加载因子，且默认情况下是不开启LRU规则。</p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * HashMap.Node subclass for normal LinkedHashMap entries.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   static <span class="class"><span class="keyword">class</span> <span class="title">Entry&lt;K</span>,<span class="title">V&gt;</span> <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node&lt;K</span>,<span class="title">V&gt;</span> </span>&#123;</span><br><span class="line">       <span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; before, after; <span class="comment">//指向前后节点</span></span><br><span class="line">       <span class="type">Entry</span>(int hash, <span class="type">K</span> key, <span class="type">V</span> value, <span class="type">Node</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; next) &#123;</span><br><span class="line">           <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The head (eldest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   transient <span class="type">LinkedHashMap</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; head;<span class="comment">//双向链表头节点（最老）</span></span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * The tail (youngest) of the doubly linked list.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   transient <span class="type">LinkedHashMap</span>.<span class="type">Entry</span>&lt;<span class="type">K</span>,<span class="type">V</span>&gt; tail;<span class="comment">//双向列表尾节点（最新</span></span><br></pre></td></tr></table></figure><h4 id="LRU实现"><a href="#LRU实现" class="headerlink" title="LRU实现"></a>LRU实现</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// 把当前节点e放到双向链表尾部</span></span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">        <span class="comment">//accessOrder就是我们前面说的LRU控制，当它为true，同时e对象不是尾节点（如果访问尾节点就不需要设置，该方法就是把节点放置到尾节点）</span></span><br><span class="line">        <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        <span class="comment">//用a和b分别记录该节点前面和后面的节点</span></span><br><span class="line">            LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">                (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">             <span class="comment">//释放当前节点与后节点的关系 </span></span><br><span class="line">            p.after = <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//如果当前节点的前节点是空，</span></span><br><span class="line">            <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//那么头节点就设置为a</span></span><br><span class="line">                head = a;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            <span class="comment">//如果b不为null，那么b的后节点指向a</span></span><br><span class="line">                b.after = a;</span><br><span class="line">            <span class="comment">//如果a节点不为空</span></span><br><span class="line">            <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">                <span class="comment">//a的后节点指向b</span></span><br><span class="line">                a.before = b;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//如果a为空，那么b就是尾节点</span></span><br><span class="line">                last = b;</span><br><span class="line">                <span class="comment">//如果尾节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//那么p为头节点</span></span><br><span class="line">                head = p;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//否则就把p放到双向链表最尾处</span></span><br><span class="line">                p.before = last;</span><br><span class="line">                last.after = p;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//设置尾节点为P</span></span><br><span class="line">            tail = p;</span><br><span class="line">            <span class="comment">//LinkedHashMap对象操作次数+1</span></span><br><span class="line">            ++modCount;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>开启LRU后，put，get等方法都会调用这个函数来调整顺序。</p><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> V <span class="built_in">get</span>(<span class="keyword">Object</span> <span class="built_in">key</span>) &#123;</span><br><span class="line">       Node&lt;K,V&gt; e;</span><br><span class="line">       <span class="keyword">if</span> ((e = getNode(hash(<span class="built_in">key</span>), <span class="built_in">key</span>)) == <span class="keyword">null</span>)</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">       <span class="keyword">if</span> (accessOrder)<span class="comment">//如果启用了LRU规则</span></span><br><span class="line">           afterNodeAccess(e);<span class="comment">//那么把该节点移到双向链表最后面</span></span><br><span class="line">       <span class="keyword">return</span> e.value;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h4 id="移除Eldest"><a href="#移除Eldest" class="headerlink" title="移除Eldest"></a>移除Eldest</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">boolean</span> <span class="title">removeEldestEntry</span><span class="params">(Map.Entry&lt;K,V&gt; eldest)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>LinkedHashMap有一个自带的移除最老数据的方法，默认返回false，我们可以在继承的时候重写这个方法，给定一个条件就可以控制存储在LinkedHashMap中的最老数据何时删除。触发这个删除机制，一般是在PUT一个数据进入的时候，但是LinkedHashMap并没有重写Put方法如何实现呢?在LinekdHashMap中，这个方法被包含在afterNodeInsertion()方法之中，而这个方法是重写了HashMap的，但是HashMap中并没有去实现它，所以在put的时候就会触发删除这个机制。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;刚好正在研究Android中LruCache缓存，它的实现其实也是使用了LinkedHashMap，所以今天就专门写博客记录一下相关知识。&lt;/p&gt;
&lt;h2 id=&quot;存储结构&quot;&gt;&lt;a href=&quot;#存储结构&quot; class=&quot;headerlink&quot; title=&quot;存储结构&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="Java" scheme="http://yoursite.com/categories/Java/"/>
    
    
      <category term="Java" scheme="http://yoursite.com/tags/Java/"/>
    
      <category term="LRU" scheme="http://yoursite.com/tags/LRU/"/>
    
  </entry>
  
  <entry>
    <title>Android JNI学习</title>
    <link href="http://yoursite.com/2018/08/17/Android-JNI%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/08/17/Android-JNI学习/</id>
    <published>2018-08-17T08:26:23.000Z</published>
    <updated>2018-12-03T03:17:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>JNI是Android中比较重要的一块知识，Java层与C/C++层进行调用的桥梁。所以今天就来学习一下JNI相关的知识。</p><h2 id="JNI（Java-Native-Interface）"><a href="#JNI（Java-Native-Interface）" class="headerlink" title="JNI（Java Native Interface）"></a>JNI（Java Native Interface）</h2><p>JNI(Java Native Interface):java本地开发接口,JNI是一个协议，这个协议用来沟通java代码和外部的本地代码(c/c++),外部的c/c++代码也可以调用java代码。</p><p>####为什么使用JNI？</p><ol><li>效率上 C/C++是本地语言，比java更高效</li><li>代码移植，如果之前用C语言开发过模块，可以复用已经存在的c代码</li><li>java反编译比C语言容易，一般加密算法都是用C语言编写，不容易被反编译</li></ol><h4 id="Java基本数据类型与C语言基本数据类型的对应"><a href="#Java基本数据类型与C语言基本数据类型的对应" class="headerlink" title="Java基本数据类型与C语言基本数据类型的对应"></a>Java基本数据类型与C语言基本数据类型的对应</h4><p><img src="/2018/08/17/Android-JNI学习/jni1.png" alt=""></p><h4 id="引用类型对应"><a href="#引用类型对应" class="headerlink" title="引用类型对应"></a>引用类型对应</h4><p><img src="/2018/08/17/Android-JNI学习/jni2.png" alt=""></p><h2 id="JNI例子"><a href="#JNI例子" class="headerlink" title="JNI例子"></a>JNI例子</h2><p>在AS3.0之后，AS对JNI的工程构建做了一些改动，可以非常方便地创建一个支持JNI的工程。</p><p><img src="/2018/08/17/Android-JNI学习/jni3.png" alt=""></p><p>只要在创建工程的时候选择包括C++，其他都是正常的创建流程。</p><p>最终创建出的工程结构如下图：</p><p><img src="/2018/08/17/Android-JNI学习/jni4.png" alt=""></p><p>默认生成一个<code>stringFromJNI</code>的方法，返回值为String类型。</p><p>生成的对应C代码为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;jni.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="string">"C"</span> JNIEXPORT jstring</span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_stringFromJNI(</span><br><span class="line">        JNIEnv *env,</span><br><span class="line">        jobject <span class="comment">/* this */</span>) &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> hello = <span class="string">"Hello from C++"</span>;</span><br><span class="line">    <span class="keyword">return</span> env-&gt;NewStringUTF(hello.c_str());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AS帮我们创建一个CPP文件夹用来保存我们的C／C++文件，CMakeList文件也帮我们创建成功，可以直接运行，极大方便了我们Android开发程序员。</p><blockquote><p>C/C++中生成方法的名称规范为：Java _ 包名 _ 类名 _ 方法名</p></blockquote><h3 id="JNI传递一个数组"><a href="#JNI传递一个数组" class="headerlink" title="JNI传递一个数组"></a>JNI传递一个数组</h3><p>上面AS自动生成的示例代码展示了JNI对String的操作，然后我们看一下JNI传递一个数组。</p><h4 id="Java代码"><a href="#Java代码" class="headerlink" title="Java代码"></a>Java代码</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">change</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>;</span><br></pre></td></tr></table></figure><h4 id="生成C-C-代码"><a href="#生成C-C-代码" class="headerlink" title="生成C/C++代码"></a>生成C/C++代码</h4><p>在AS3.0之后也不用我们去自己写对应的C/C++代码，AS可以帮我们自动生成。</p><p><img src="/2018/08/17/Android-JNI学习/jni5.png" alt=""></p><p>生成的模版代码：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> JNIEXPORT void </span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_change(<span class="name">JNIEnv</span> *env, jobject instance, jintArray arr_) &#123;</span><br><span class="line">    jint *arr = env-&gt;GetIntArrayElements(<span class="name">arr_</span>, NULL)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    // TODO</span><br><span class="line"></span><br><span class="line">    env-&gt;ReleaseIntArrayElements(<span class="name">arr_</span>, arr, <span class="number">0</span>)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自动生成的代码连获取数组数据以及释放数组内存都帮我们写好了，简直了～</p><p>然后我们做一些操作：</p><figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">extern <span class="string">"C"</span> JNIEXPORT void</span><br><span class="line"></span><br><span class="line">JNICALL</span><br><span class="line">Java_com_liuwei_ndktest_MainActivity_change(JNIEnv *<span class="keyword">env</span>, jobject <span class="keyword">instance</span>, jintArray arr_) &#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="keyword">env</span>-&gt;GetArrayLength(arr_);</span><br><span class="line">    jint *arr = <span class="keyword">env</span>-&gt;GetIntArrayElements(arr_, NULL);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//每个数据加10</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line">        *(arr + i) += <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">env</span>-&gt;ReleaseIntArrayElements(arr_, arr, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Java中调用该方法</p><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int[] a = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>&#125;;</span><br><span class="line"></span><br><span class="line"> change(a);</span><br><span class="line"></span><br><span class="line"> for (int i = <span class="number">0</span>; i &lt; a.length; i++) &#123;</span><br><span class="line">      Log.e(<span class="string">"Test"</span>, <span class="string">"a"</span> + i + <span class="string">"= "</span> + a[i]);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">E/Test: <span class="attr">a0=</span> <span class="number">11</span></span><br><span class="line">E/Test: <span class="attr">a1=</span> <span class="number">12</span></span><br><span class="line">   <span class="attr">a2=</span> <span class="number">13</span></span><br><span class="line">   <span class="attr">a3=</span> <span class="number">14</span></span><br><span class="line">   <span class="attr">a4=</span> <span class="number">15</span></span><br><span class="line">   <span class="attr">a5=</span> <span class="number">16</span></span><br></pre></td></tr></table></figure><p>每个数据都加了10，OK。</p><p>可以看到我们在这个方法中没有返回值，直接打印相同的数组，但实际结果也发生了改变，这是因为：<strong>传递数组其实是传递一个堆内存的数组首地址的引用过去，所以实际操作的是同一块内存，当调用完方法，不需要返回值,实际上参数内容已经改变，Android中很多操作硬件的方法都是这种C语言的传引用的思路。</strong></p><h3 id="在C-中调用java方法"><a href="#在C-中调用java方法" class="headerlink" title="在C++中调用java方法"></a>在C++中调用java方法</h3><p>Java中：</p><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">sayJavaHi</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Log.e(<span class="string">"Test"</span>, <span class="string">"Hi Java"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">native</span> <span class="function"><span class="keyword">void</span> <span class="title">say</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><p>我们调用say方法，然后由C调用sayJavaHi方法。</p><p>C++方法：</p><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">#include &lt;android/log.h&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#define LOG_TAG "System.out"</span></span><br><span class="line"><span class="comment">#define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, LOG_TAG, __VA_ARGS__)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern </span><span class="string">"C"</span> <span class="keyword">JNIEXPORT </span>void </span><br><span class="line"><span class="keyword">JNICALL</span></span><br><span class="line"><span class="keyword">Java_com_liuwei_ndktest_MainActivity_say(JNIEnv </span>*env, <span class="keyword">jobject </span><span class="keyword">instance) </span>&#123;</span><br><span class="line">    LOGD(<span class="string">"debug日志"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jclass </span><span class="keyword">jclass1 </span>= env-&gt;FindClass(<span class="string">"com/liuwei/ndktest/MainActivity"</span>)<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">jmethodID </span>methodID = env-&gt;GetMethodID(<span class="keyword">jclass1, </span><span class="string">"sayJavaHi"</span>, <span class="string">"()V"</span>)<span class="comment">;</span></span><br><span class="line">    env-&gt;CallVoidMethod(<span class="keyword">instance, </span>methodID)<span class="comment">;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在C++方法中我们使用反射调用Java层的代码。</p><p>最终结果：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">08</span>-<span class="number">17</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">05.637</span> <span class="number">8791</span>-<span class="number">8791</span>/com<span class="selector-class">.liuwei</span><span class="selector-class">.ndktest</span> D/System<span class="selector-class">.out</span>: debug日志</span><br><span class="line"><span class="number">08</span>-<span class="number">17</span> <span class="number">20</span>:<span class="number">30</span>:<span class="number">05.637</span> <span class="number">8791</span>-<span class="number">8791</span>/com<span class="selector-class">.liuwei</span><span class="selector-class">.ndktest</span> E/Test: Hi Java</span><br></pre></td></tr></table></figure><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><p>这里说一下GetMethodID方法，第一个参数：Java类对象；第二个参数：参数名（或方法名）；第三个参数：该参数（或方法）的签名。</p><p>比较麻烦的是第三个参数，JNI是以”(*)+”形式表示函数的有哪些传入参数，传入参数的类型，返回值的类型。”()” 中的字符表示传入参数，后面的则代表返回值。</p><p>例如：</p><p> “()V” 就表示void Func();</p><p> “(II)V” 表示 void Func(int, int);</p><p> “(Ljava/lang/String;Ljava/lang/String;)I”.表示 int Func(String,String)</p><p><img src="/2018/08/17/Android-JNI学习/jni6.png" alt=""></p><p>另外数组类型的简写,则用”[“加上如表A所示的对应类型的简写形式进行表示就可以了，<br>比如：<strong>[I</strong> 表示 int [];<strong>[L/java/lang/objects;</strong>表示Objects[],另外。引用类型（除基本类型的数组外）的标示最后都有个”;”</p><h2 id="补充二"><a href="#补充二" class="headerlink" title="补充二"></a>补充二</h2><p>对于这个方法参数中的JNIEnv* env参数的解释:</p><p>JNIEnv类型实际上代表了Java环境，通过这个JNIEnv* 指针，就可以对Java端的代码进行操作。例如，创建Java对象，调用Java对象的方法，获取Java对象中的属性等等。JNIEnv的指针会被JNI传入到本地方法的实现函数中来对Java端的代码进行操作。</p><p>JNIEnv类中有很多函数可以用：</p><p>NewObject:创建Java类中的对象</p><p>NewString:创建Java类中的String对象</p><p>New<type>Array:创建类型为Type的数组对象</type></p><p>Get<type>Field:获取类型为Type的字段</type></p><p>Set<type>Field:设置类型为Type的字段的值</type></p><p>GetStatic<type>Field:获取类型为Type的static的字段</type></p><p>SetStatic<type>Field:设置类型为Type的static的字段的值</type></p><p>Call<type>Method:调用返回类型为Type的方法</type></p><p>CallStatic<type>Method:调用返回值类型为Type的static方法</type></p><p>等许多的函数。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JNI是Android中比较重要的一块知识，Java层与C/C++层进行调用的桥梁。所以今天就来学习一下JNI相关的知识。&lt;/p&gt;
&lt;h2 id=&quot;JNI（Java-Native-Interface）&quot;&gt;&lt;a href=&quot;#JNI（Java-Native-Interface
      
    
    </summary>
    
      <category term="Android开发" scheme="http://yoursite.com/categories/Android%E5%BC%80%E5%8F%91/"/>
    
    
      <category term="JNI" scheme="http://yoursite.com/tags/JNI/"/>
    
      <category term="NDK" scheme="http://yoursite.com/tags/NDK/"/>
    
  </entry>
  
</feed>
